<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 5 Opèrations géométriques | Geocomputation avec R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="Prérequis Ce chapitre utilise les mêmes paquets que le chapitre 4 mais avec l’ajout de spDataLarge, qui a été installé dans le chapitre 2: library(sf) library(terra) library(dplyr) library(spData)...">
<meta name="generator" content="bookdown 0.31 with bs4_book()">
<meta property="og:title" content="Chapter 5 Opèrations géométriques | Geocomputation avec R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://geocompr.github.io/fr/geometry-operations.html">
<meta property="og:image" content="https://geocompr.github.io/es/images/cover.png">
<meta property="og:description" content="Prérequis Ce chapitre utilise les mêmes paquets que le chapitre 4 mais avec l’ajout de spDataLarge, qui a été installé dans le chapitre 2: library(sf) library(terra) library(dplyr) library(spData)...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 5 Opèrations géométriques | Geocomputation avec R">
<meta name="twitter:description" content="Prérequis Ce chapitre utilise les mêmes paquets que le chapitre 4 mais avec l’ajout de spDataLarge, qui a été installé dans le chapitre 2: library(sf) library(terra) library(dplyr) library(spData)...">
<meta name="twitter:image" content="https://geocompr.github.io/es/images/cover.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Lato-0.4.4/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.4/font.css" rel="stylesheet">
<link href="libs/Montserrat-0.4.4/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.4.2/transition.js"></script><script src="libs/bs3compat-0.4.2/tabs.js"></script><script src="libs/bs3compat-0.4.2/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/htmlwidgets-1.6.0/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.1.1/leaflet.js"></script><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation avec R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table des matières</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bienvenue!</a></li>
<li><a class="" href="foreword-1st-edition.html">Foreword (1st Edition)</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Introduction</a></li>
<li class="book-part">Foundations</li>
<li><a class="" href="spatial-class.html"><span class="header-section-number">2</span> La donnée géographique dans R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> Opérations sur les tables attributaires</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> Géotraitements</a></li>
<li><a class="active" href="geometry-operations.html"><span class="header-section-number">5</span> Opèrations géométriques</a></li>
<li><a class="" href="raster-vector.html"><span class="header-section-number">6</span> Interactions raster-vecteur</a></li>
<li><a class="" href="reproj-geo-data.html"><span class="header-section-number">7</span> Reprojeté des données geographiques</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/geocompx/geocompr-fr">Code source du livre <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="geometry-operations" class="section level1" number="5">
<h1>
<span class="header-section-number">5</span> Opèrations géométriques<a class="anchor" aria-label="anchor" href="#geometry-operations"><i class="fas fa-link"></i></a>
</h1>
<div id="prérequis-3" class="section level2 unnumbered">
<h2>Prérequis<a class="anchor" aria-label="anchor" href="#pr%C3%A9requis-3"><i class="fas fa-link"></i></a>
</h2>
<ul>
<li>Ce chapitre utilise les mêmes paquets que le chapitre <a href="spatial-operations.html#spatial-operations">4</a> mais avec l’ajout de <strong>spDataLarge</strong>, qui a été installé dans le chapitre <a href="spatial-class.html#spatial-class">2</a>:</li>
</ul>
<div class="sourceCode" id="cb160"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/terra/">terra</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org">dplyr</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://jakubnowosad.com/spData/">spData</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Nowosad/spData">spDataLarge</a></span><span class="op">)</span></span></code></pre></div>
</div>
<div id="introduction-2" class="section level2" number="5.1">
<h2>
<span class="header-section-number">5.1</span> Introduction<a class="anchor" aria-label="anchor" href="#introduction-2"><i class="fas fa-link"></i></a>
</h2>
<p>Jusqu’à présent, ce livre a abordé la structure des jeux de données géographiques (chapitre <a href="spatial-class.html#spatial-class">2</a>), et la manière de les manipuler en fonction de leurs attributs non géographiques (chapitre <a href="attr.html#attr">3</a>) et de leurs relations spatiales (chapitre <a href="spatial-operations.html#spatial-operations">4</a>).
Ce chapitre se concentre sur la manipulation des éléments géographiques des objets géographiques, par exemple en simplifiant et en convertissant les géométries vectorielles, en recadrant les rasters et en convertissant les objets vectoriels en rasters et les rasters en vecteurs.
Après l’avoir lu — et avoir fait les exercices à la fin — vous devriez comprendre et contrôler la colonne géométrique des objets <code>sf</code> ainsi que l’étendue et l’emplacement géographique des pixels représentés dans les rasters par rapport à d’autres objets géographiques.</p>
<p>La section <a href="geometry-operations.html#geo-vec">5.2</a> couvre la transformation des géométries vectorielles avec des opérations “unaires” (ou fonction avec un argument) et “binaires” (fonction avec plus d’un argument).
Les opérations unaires portent sur une seule géométrie de manière isolée, notamment la simplification (de lignes et de polygones), la création de tampons et de centroïdes, et le déplacement/la mise à l’échelle/la rotation de géométries uniques à l’aide de ” transformations affines ” (sections <a href="geometry-operations.html#simplification">5.2.1</a> à @ref(transformations affines)).
Les transformations binaires modifient une géométrie en fonction de la forme d’une autre, y compris l’écrêtage et les unions géométriques (), traités respectivement dans les sections @ref(écrêtage) et @ref(unions géométriques).
Les transformations de type (d’un polygone à une ligne, par exemple) sont présentées dans la section <a href="geometry-operations.html#type-trans">5.2.8</a>.</p>
<p>La section <a href="geometry-operations.html#geo-ras">5.3</a> couvre les transformations géométriques sur les objets rasters.
Il s’agit de modifier la taille et le nombre des pixels, et de leur attribuer de nouvelles valeurs.
Elle enseigne comment modifier la résolution (également appelée agrégation et désagrégation), l’étendue et l’origine d’un objet matriciel.
Ces opérations sont particulièrement utiles si l’on souhaite aligner des rasters provenant de sources diverses.
Les objets rasters alignés partagent une correspondance biunivoque entre les pixels, ce qui permet de les traiter à l’aide d’opérations d’algèbre raster, décrites dans la section <a href="#map-algebra"><strong>??</strong></a>.
L’interaction entre les objets raster et vectoriels est traitée au chapitre <a href="raster-vector.html#raster-vector">6</a>.
Elle montre comment les valeurs matricielles peuvent être “masquées” et “extraites” par des géométries vectorielles.
Il est important de noter qu’elle montre comment ” polygoniser ” les données raster et ” rastériser ” les veceurs, ce qui rend les deux modèles de données plus interchangeables.</p>
</div>
<div id="geo-vec" class="section level2" number="5.2">
<h2>
<span class="header-section-number">5.2</span> Opérations géométriques sur les données vectorielles<a class="anchor" aria-label="anchor" href="#geo-vec"><i class="fas fa-link"></i></a>
</h2>
<p>Cette section traite des opérations qui, d’une manière ou d’une autre, modifient la géométrie des objets vectoriels (<code>sf</code>).
Elle est plus avancée que les opérations sur les données spatiales présentées dans le chapitre précédent (dans la section <a href="spatial-operations.html#spatial-vec">4.2</a>), parce qu’ici nous allons plus loin dans la géométrie :
les fonctions présentées dans cette section fonctionnent sur les objets de la classe <code>sfc</code> en plus des objets de la classe <code>sf</code>.</p>
<div id="simplification" class="section level3" number="5.2.1">
<h3>
<span class="header-section-number">5.2.1</span> Simplification<a class="anchor" aria-label="anchor" href="#simplification"><i class="fas fa-link"></i></a>
</h3>
<p>
La simplification est un processus de généralisation des objets vectoriels (lignes et polygones) généralement destiné à être utilisé dans des cartes à plus petite échelle.
Une autre raison de simplifier les objets est de réduire la quantité de mémoire, d’espace disque et de bande passante qu’ils consomment :
il peut être judicieux de simplifier des géométries complexes avant de les publier sous forme de cartes interactives.
Le paquet <strong>sf</strong> fournit <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code>, qui utilise l’implémentation GEOS de l’algorithme de Douglas-Peucker pour réduire le nombre de sommets.
<code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code> utilise la <code>dTolerance</code> pour contrôler le niveau de généralisation des unités de la carte <span class="citation">(voir <a href="reproj-geo-data.html#ref-douglas_algorithms_1973" role="doc-biblioref">Douglas and Peucker 1973</a> pour plus de détails)</span>.
La figure <a href="geometry-operations.html#fig:seine-simp">5.1</a> illustre la simplification d’une géométrie <code>LINESTRING</code> représentant la Seine et ses affluents.
La géométrie simplifiée a été créée par la commande suivante :</p>
<div class="sourceCode" id="cb161"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">seine_simp</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify</a></span><span class="op">(</span><span class="va">seine</span>, dTolerance <span class="op">=</span> <span class="fl">2000</span><span class="op">)</span>  <span class="co"># 2000 m</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:seine-simp"></span>
<img src="05-geometry-operations_files/figure-html/seine-simp-1.png" alt="Comparaison de la géométrie originale et simplifiée de la Seine." width="100%"><p class="caption">
FIGURE 5.1: Comparaison de la géométrie originale et simplifiée de la Seine.
</p>
</div>
<p>L’objet <code>seine_simp</code> résultant est une copie de l’objet original <code>seine</code> mais avec moins de vertices.
Le résultat étant visuellement plus simple (Figure <a href="geometry-operations.html#fig:seine-simp">5.1</a>, à droite) et consommant moins de mémoire que l’objet original, comme vérifié ci-dessous :</p>
<div class="sourceCode" id="cb162"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/object.size.html">object.size</a></span><span class="op">(</span><span class="va">seine</span><span class="op">)</span></span>
<span><span class="co">#&gt; 18096 bytes</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/object.size.html">object.size</a></span><span class="op">(</span><span class="va">seine_simp</span><span class="op">)</span></span>
<span><span class="co">#&gt; 9112 bytes</span></span></code></pre></div>
<p>La simplification est également applicable aux polygones.
Ceci est illustré par l’utilisation de <code>us_states</code>, représentant les États-Unis contigus.
Comme nous le montrons dans le chapitre <a href="reproj-geo-data.html#reproj-geo-data">7</a>, GEOS suppose que les données sont dans un CRS projeté et cela pourrait conduire à des résultats inattendus lors de l’utilisation d’un CRS géographique.
Par conséquent, la première étape consiste à projeter les données dans un CRS projeté adéquat, tel que le US National Atlas Equal Area (epsg = 2163) (à gauche sur la figure <a href="geometry-operations.html#fig:us-simp">5.2</a>) :</p>
<div class="sourceCode" id="cb163"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">us_states2163</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">us_states</span>, <span class="st">"EPSG:2163"</span><span class="op">)</span></span>
<span><span class="va">us_states2163</span> <span class="op">=</span> <span class="va">us_states2163</span></span></code></pre></div>
<p><code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code> works equally well with projected polygons:</p>
<div class="sourceCode" id="cb164"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">us_states_simp1</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify</a></span><span class="op">(</span><span class="va">us_states2163</span>, dTolerance <span class="op">=</span> <span class="fl">100000</span><span class="op">)</span>  <span class="co"># 100 km</span></span></code></pre></div>
<p>Une limitation de <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code> est qu’il simplifie les objets sur une base géométrique.
Cela signifie que la “topologie” est perdue, ce qui donne lieu à des polygones se superposant ou séparés par des vides, comme le montre la figure <a href="geometry-operations.html#fig:us-simp">5.2</a> (panneau du milieu).
<code>ms_simplify()</code> de <strong>rmapshaper</strong> fournit une alternative qui surmonte ce problème.
Par défaut, il utilise l’algorithme de Visvalingam, qui surmonte certaines limitations de l’algorithme de Douglas-Peucker <span class="citation">(<a href="reproj-geo-data.html#ref-visvalingam_line_1993" role="doc-biblioref">Visvalingam and Whyatt 1993</a>)</span>.
<!-- https://bost.ocks.org/mike/simplify/ -->
L’extrait de code suivant utilise cette fonction pour simplifier <code>us_states2163</code>.
Le résultat n’a que 1% des sommets de l’entrée (fixée à l’aide de l’argument <code>keep</code>) mais son nombre d’objets reste intact car nous avons fixé <code>keep_shapes = TRUE</code> :<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
La simplification des objets multi-polygones peut supprimer les petits polygones internes, même si l’argument &lt;code&gt;keep_shapes&lt;/code&gt; est défini à TRUE. Pour éviter cela, vous devez définir &lt;code&gt;explode = TRUE&lt;/code&gt;. Cette option convertit tous les mutlipolygones en polygones séparés avant leur simplification.&lt;/p&gt;"><sup>21</sup></a></p>
<div class="sourceCode" id="cb165"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># proportion des points à garder (0-1; par defaut 0.05)</span></span>
<span><span class="va">us_states_simp2</span> <span class="op">=</span> <span class="fu">rmapshaper</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/rmapshaper/man/ms_simplify.html">ms_simplify</a></span><span class="op">(</span><span class="va">us_states2163</span>, keep <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>                                          keep_shapes <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Une alternative à la simplification est le lissage des limites des géométries des polygones et des linéaires (<em>linestring</em>). Elle est implémenté dans le package <strong>smoothr</strong>.
Le lissage interpole les arêtes des géométries et n’entraîne pas nécessairement une réduction du nombre de sommets, mais il peut être particulièrement utile lorsque l’on travaille avec des géométries qui résultent de la vectorisation spatiale d’un raster (un sujet traité dans le chapitre <a href="raster-vector.html#raster-vector">6</a>.
<strong>smoothr</strong> implémente trois techniques de lissage : une régression à noyau gaussien, l’algorithme de découpage en coins de Chaikin et l’interpolation par splines, qui sont tous décrits dans la vignette du paquetage et dans <a href="https://strimas.com/smoothr/">website</a>.
Notez que, comme pour <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code>, les algorithmes de lissage ne préservent pas la ‘topologie’.
La fonction phare de <strong>smoothr</strong> est <code><a href="https://rdrr.io/r/stats/smooth.html">smooth()</a></code>, où l’argument <code>method</code> spécifie la technique de lissage à utiliser.
Vous trouverez ci-dessous un exemple d’utilisation de la régression à noyau gaussien pour lisser les frontières des états américains en utilisant <code>method=ksmooth</code>.
L’argument <code>smoothness</code> contrôle la largeur de bande de la gaussienne qui est utilisée pour lisser la géométrie et a une valeur par défaut de 1.</p>
<div class="sourceCode" id="cb166"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">us_states_simp3</span> <span class="op">=</span> <span class="fu">smoothr</span><span class="fu">::</span><span class="fu"><a href="https://strimas.com/smoothr/reference/smooth.html">smooth</a></span><span class="op">(</span><span class="va">us_states2163</span>, method <span class="op">=</span> <span class="st">'ksmooth'</span>, smoothness <span class="op">=</span> <span class="fl">6</span><span class="op">)</span></span></code></pre></div>
<p>Enfin, la comparaison visuelle de l’ensemble de données originales et des deux versions simplifiées montre des différences entre les sorties des algorithmes de Douglas-Peucker (<code>st_simplify</code>), de Visvalingam (<code>ms_simplify</code>) et de régression à noyau gaussien (<code>smooth(method=ksmooth)</code>) (Figure <a href="geometry-operations.html#fig:us-simp">5.2</a>) :</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:us-simp"></span>
<img src="05-geometry-operations_files/figure-html/us-simp-1.png" alt="Simplification des polygones, comparant la géométrie originale des États-Unis continentaux avec des versions simplifiées, générées avec les fonctions des paquets sf (haut à droite) et rmapshaper (bas à gauche) et smoothr (bas à droite)." width="100%"><p class="caption">
FIGURE 5.2: Simplification des polygones, comparant la géométrie originale des États-Unis continentaux avec des versions simplifiées, générées avec les fonctions des paquets sf (haut à droite) et rmapshaper (bas à gauche) et smoothr (bas à droite).
</p>
</div>
</div>
<div id="centroïdes" class="section level3" number="5.2.2">
<h3>
<span class="header-section-number">5.2.2</span> Centroïdes<a class="anchor" aria-label="anchor" href="#centro%C3%AFdes"><i class="fas fa-link"></i></a>
</h3>
<p>
Les opérations de centroïdes identifient le centre des objets géographiques.
Comme pour les mesures statistiques de tendance centrale (y compris les définitions de la moyenne et de la médiane), il existe de nombreuses façons de définir le centre géographique d’un objet.
Toutes créent des représentations par un point unique d’objets vectoriels plus complexes.</p>
<p>Le <em>centroïde géographique</em> est sans doute l’opération la plus couramment utilisée.
Ce type d’opération (souvent jute appelé “centroïde”) représente le centre de masse d’un objet spatial (pensez à une assiette en équilibre sur votre doigt).
Les centroïdes géographiques ont de nombreuses utilisations, par exemple pour créer une représentation ponctuelle simple de géométries complexes, ou pour estimer les distances entre polygones.
Ils peuvent être calculés à l’aide de la fonction <strong>sf</strong> <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code>, comme le montre le code ci-dessous, qui génère les centroïdes géographiques de régions de Nouvelle-Zélande et d’affluents de la Seine, illustrés par des points noirs sur la figure <a href="geometry-operations.html#fig:centr">5.3</a>.</p>
<div class="sourceCode" id="cb167"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_centroid</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">nz</span><span class="op">)</span></span>
<span><span class="va">seine_centroid</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">seine</span><span class="op">)</span></span></code></pre></div>
<p>Parfois, le centroïde géographique se trouve en dehors des limites de l’objet parent (pensez à un beignet).
Dans ce cas, les opérations dites de <em>point sur la surface</em> peuvent être utilisées pour garantir que le point se trouvera dans l’objet parent (par exemple, pour étiqueter des objets de type multipolygones irréguliers tels que des îles), comme l’illustrent les points rouges de la figure <a href="geometry-operations.html#fig:centr">5.3</a>.
Remarquez que ces points rouges se trouvent toujours sur leurs objets parents.
Ils ont été créés avec <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_point_on_surface()</a></code> comme suit :<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Une description du fonctionnement de &lt;code&gt;st_point_on_surface()&lt;/code&gt; est fournie sur &lt;a href="https://gis.stackexchange.com/q/76498" class="uri"&gt;https://gis.stackexchange.com/q/76498&lt;/a&gt;.&lt;/p&gt;'><sup>22</sup></a></p>
<div class="sourceCode" id="cb168"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_pos</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_point_on_surface</a></span><span class="op">(</span><span class="va">nz</span><span class="op">)</span></span>
<span><span class="va">seine_pos</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_point_on_surface</a></span><span class="op">(</span><span class="va">seine</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:centr"></span>
<img src="05-geometry-operations_files/figure-html/centr-1.png" alt="Centroïdes (points noirs) et points sur la surface (points rouges) des ensembles de données des régions de Nouvelle-Zélande (à gauche) et de la Seine (à droite)." width="100%"><p class="caption">
FIGURE 5.3: Centroïdes (points noirs) et points sur la surface (points rouges) des ensembles de données des régions de Nouvelle-Zélande (à gauche) et de la Seine (à droite).
</p>
</div>
<p>Il existe d’autres types de centroïdes, notamment le <em>centre de Chebyshev</em> et le <em>centre visuel</em>.
Nous ne les explorerons pas ici, mais il est possible de les calculer à l’aide de R, comme nous le verrons dans le chapitre <a href="#algorithms"><strong>??</strong></a>.</p>
</div>
<div id="bufferstampons" class="section level3" number="5.2.3">
<h3>
<span class="header-section-number">5.2.3</span> Buffers/tampons<a class="anchor" aria-label="anchor" href="#bufferstampons"><i class="fas fa-link"></i></a>
</h3>
<p>
Les buffers ou tampons sont des polygones représentant la zone située à une distance donnée d’une caractéristique géométrique :
Que le type d’origine soit un point, une ligne ou un polygone, la sortie est toujours un polygone.
Contrairement à la simplification (qui est souvent utilisée pour la visualisation et la réduction de la taille des fichiers), la mise en mémoire tampon est généralement utilisée pour l’analyse des données géographiques.
Combien de points se trouvent à une distance donnée de cette ligne ?
Quels groupes démographiques se trouvent à une distance de déplacement de ce nouveau magasin ?
Il est possible de répondre à ce genre de questions et de les visualiser en créant des tampons autour des entités géographiques d’intérêt.</p>
<p>La figure <a href="geometry-operations.html#fig:buffs">5.4</a> illustre des buffers de différentes tailles (5 et 50 km) entourant la Seine et ses affluents.
Les commandes ci-dessous, utilisées pour créer ces buffers, montrent que la commande <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer()</a></code> nécessite au moins deux arguments : une géométrie d’entrée et une distance, fournie dans les unités du SRC (dans ce cas, les mètres) :</p>
<div class="sourceCode" id="cb169"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">seine_buff_5km</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">seine</span>, dist <span class="op">=</span> <span class="fl">5000</span><span class="op">)</span></span>
<span><span class="va">seine_buff_50km</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">seine</span>, dist <span class="op">=</span> <span class="fl">50000</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:buffs"></span>
<img src="05-geometry-operations_files/figure-html/buffs-1.png" alt="Tampons de 5 km autour du jeu de données de la Seine  (à gauche) et de 50 km (à droite). Notez les couleurs, qui reflètent le fait qu'un tampon est créé par élément géométrique." width="75%"><p class="caption">
FIGURE 5.4: Tampons de 5 km autour du jeu de données de la Seine (à gauche) et de 50 km (à droite). Notez les couleurs, qui reflètent le fait qu’un tampon est créé par élément géométrique.
</p>
</div>

<div class="rmdnote">
Le troisième et dernier argument de <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer()</a></code> est <code>nQuadSegs</code>, qui signifie ‘nombre de segments par quadrant’ et qui est fixé par défaut à 30 (ce qui signifie que les cercles créés par les buffers sont composés de <span class="math inline">\(4 \times 30 = 120\)</span> lignes).
Cet argument a rarement besoin d´être défini.
Les cas inhabituels où il peut être utile incluent lorsque la mémoire consommée par la sortie d´une opération de tampon est une préoccupation majeure (dans ce cas, il devrait être réduit) ou lorsque la très haute précision est nécessaire (dans ce cas, il devrait être augmenté).
</div>
</div>
<div id="application-affine" class="section level3" number="5.2.4">
<h3>
<span class="header-section-number">5.2.4</span> Application affine<a class="anchor" aria-label="anchor" href="#application-affine"><i class="fas fa-link"></i></a>
</h3>
<p>
Une application affine est une transformation qui préserve les lignes et le parallélisme.
Cependant, les angles ou la longueur ne sont pas nécessairement préservés.
Les transformations affines comprennent, entre autres, le déplacement (translation), la mise à l’échelle et la rotation.
En outre, il est possible d’utiliser n’importe quelle combinaison de celles-ci.
Les applications affines sont une partie essentielle de la géocomputation.
Par exemple, le décalage est nécessaire pour le placement d’étiquettes, la mise à l’échelle est utilisée dans les cartogrammes de zones non contiguës (voir la section <a href="#other-mapping-packages"><strong>??</strong></a>), et de nombreuses transformations affines sont appliquées lors de la reprojection ou de l’amélioration de la géométrie créée à partir d’une carte déformée ou mal projetée.
Le paquet <strong>sf</strong> implémente la transformation affine pour les objets des classes <code>sfg</code> et <code>sfc</code>.</p>
<div class="sourceCode" id="cb170"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_sfc</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_geometry</a></span><span class="op">(</span><span class="va">nz</span><span class="op">)</span></span></code></pre></div>
<p>Le décalage déplace chaque point de la même distance en unités cartographiques.
Cela peut être fait en ajoutant un vecteur numérique à un objet vectoriel.
Par exemple, le code ci-dessous déplace toutes les coordonnées y de 100 000 mètres vers le nord, mais laisse les coordonnées x intactes (panneau gauche de la figure <a href="geometry-operations.html#fig:affine-trans">5.5</a>).</p>
<div class="sourceCode" id="cb171"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_shift</span> <span class="op">=</span> <span class="va">nz_sfc</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">100000</span><span class="op">)</span></span></code></pre></div>
<p>La mise à l’échelle agrandit ou rétrécit les objets par un facteur.
Elle peut être appliquée de manière globale ou locale.
La mise à l’échelle globale augmente ou diminue toutes les valeurs des coordonnées par rapport aux coordonnées d’origine, tout en gardant intactes les relations topologiques de toutes les géométries.
Elle peut être effectuée par soustraction ou multiplication d’un objet <code>sfg</code> ou <code>sfc</code>.</p>
<p>Le changement à l’échelle locale traite les géométries indépendamment et nécessite des points autour desquels les géométries vont être mises à l’échelle, par exemple des centroïdes.
Dans l’exemple ci-dessous, chaque géométrie est réduite d’un facteur deux autour des centroïdes (panneau central de la figure <a href="geometry-operations.html#fig:affine-trans">5.5</a>).
Pour cela, chaque objet est d’abord décalé de manière à ce que son centre ait les coordonnées <code>0, 0</code> (<code>(nz_sfc - nz_centroid_sfc)</code>).
Ensuite, les tailles des géométries sont réduites de moitié (<code>* 0.5</code>).
Enfin, le centroïde de chaque objet est ramené aux coordonnées des données d’entrée (<code>+ nz_centroid_sfc</code>).</p>
<div class="sourceCode" id="cb172"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_centroid_sfc</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">nz_sfc</span><span class="op">)</span></span>
<span><span class="va">nz_scale</span> <span class="op">=</span> <span class="op">(</span><span class="va">nz_sfc</span> <span class="op">-</span> <span class="va">nz_centroid_sfc</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="va">nz_centroid_sfc</span></span></code></pre></div>
<p>La rotation de coordonnées bidimensionnelles nécessite une matrice de rotation :</p>
<p><span class="math display">\[
R =
\begin{bmatrix}
\cos \theta &amp; -\sin \theta \\  
\sin \theta &amp; \cos \theta \\
\end{bmatrix}
\]</span></p>
<p>Elle fait tourner les points dans le sens des aiguilles d’une montre.
La matrice de rotation peut être implémentée dans R comme suit :</p>
<div class="sourceCode" id="cb173"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rotation</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">a</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">r</span> <span class="op">=</span> <span class="va">a</span> <span class="op">*</span> <span class="va">pi</span> <span class="op">/</span> <span class="fl">180</span> <span class="co">#degrées en radians</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span>, <span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">r</span><span class="op">)</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">2</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span> </span></code></pre></div>
<p>La fonction <code>rotation</code> accepte un argument <code>a</code> - un angle de rotation en degrés.
La rotation peut être effectuée autour de points sélectionnés, comme les centroïdes (panneau de droite de la figure <a href="geometry-operations.html#fig:affine-trans">5.5</a>).
Voir <code><a href="https://r-spatial.github.io/sf/articles/sf3.html">vignette("sf3")</a></code> pour plus d’exemples.</p>
<div class="sourceCode" id="cb174"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_rotate</span> <span class="op">=</span> <span class="op">(</span><span class="va">nz_sfc</span> <span class="op">-</span> <span class="va">nz_centroid_sfc</span><span class="op">)</span> <span class="op">*</span> <span class="fu">rotation</span><span class="op">(</span><span class="fl">30</span><span class="op">)</span> <span class="op">+</span> <span class="va">nz_centroid_sfc</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:affine-trans"></span>
<img src="05-geometry-operations_files/figure-html/affine-trans-1.png" alt="Illustrations des transformations affines : décalage, échelle et rotation." width="100%"><p class="caption">
FIGURE 5.5: Illustrations des transformations affines : décalage, échelle et rotation.
</p>
</div>
<p>Enfin, les géométries nouvellement créées peuvent remplacer les anciennes avec la fonction <code><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_set_geometry()</a></code> :</p>
<div class="sourceCode" id="cb175"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nz_scale_sf</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_set_geometry</a></span><span class="op">(</span><span class="va">nz</span>, <span class="va">nz_scale</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="clipping" class="section level3" number="5.2.5">
<h3>
<span class="header-section-number">5.2.5</span> Découper<a class="anchor" aria-label="anchor" href="#clipping"><i class="fas fa-link"></i></a>
</h3>
<p>
Le découpage spatial est une forme de sélection spatiale qui implique des changements dans les colonnes <code>géométriques</code> d’au moins certaines des entités affectées.</p>
<p>Le découpage ne peut s’appliquer qu’à des éléments plus complexes que des points :
les lignes, les polygones et leurs équivalents “multi”.
Pour illustrer le concept, nous allons commencer par un exemple simple :
deux cercles superposés dont le point central est distant d’une unité et dont le rayon est de un (Figure <a href="geometry-operations.html#fig:points">5.6</a>).</p>
<div class="sourceCode" id="cb176"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">b</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="co"># créer 2 points</span></span>
<span><span class="va">b</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">b</span>, dist <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># convertir les points en cercles</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">b</span>, border <span class="op">=</span> <span class="st">"grey"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/text.html">text</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span><span class="op">)</span>, y <span class="op">=</span> <span class="fl">1</span>, labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span>, cex <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="co"># ajout du texte</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:points"></span>
<img src="05-geometry-operations_files/figure-html/points-1.png" alt="cercles superposés." width="100%"><p class="caption">
FIGURE 5.6: cercles superposés.
</p>
</div>
<p>Imaginez que vous voulez sélectionner non pas un cercle ou l’autre, mais l’espace couvert par les deux <code>x</code> <em>et</em> <code>y</code>.
Cela peut être fait en utilisant la fonction <code><a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html">st_intersection()</a></code>, illustrée en utilisant des objets nommés <code>x</code> et <code>y</code> qui représentent les cercles de gauche et de droite (Figure <a href="geometry-operations.html#fig:circle-intersection">5.7</a>).</p>
<div class="sourceCode" id="cb177"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">=</span> <span class="va">b</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">y</span> <span class="op">=</span> <span class="va">b</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">x_and_y</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html">st_intersection</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">b</span>, border <span class="op">=</span> <span class="st">"grey"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">x_and_y</span>, col <span class="op">=</span> <span class="st">"lightgrey"</span>, border <span class="op">=</span> <span class="st">"grey"</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="co"># surface intersectée</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:circle-intersection"></span>
<img src="05-geometry-operations_files/figure-html/circle-intersection-1.png" alt="Cercles superposés avec une couleur grise pour indiquer l'intersection entre eux" width="100%"><p class="caption">
FIGURE 5.7: Cercles superposés avec une couleur grise pour indiquer l’intersection entre eux
</p>
</div>
<p>Le passage de code suivant montre comment cela fonctionne pour toutes les combinaisons du diagramme de Venn représentant <code>x</code> et <code>y</code>, inspiré de la <a href="http://r4ds.had.co.nz/transform.html#logical-operators">Figure 5.1</a> du livre <em>R for Data Science</em> <span class="citation">(<a href="reproj-geo-data.html#ref-grolemund_r_2016" role="doc-biblioref">Grolemund and Wickham 2016</a>)</span>.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:venn-clip"></span>
<img src="05-geometry-operations_files/figure-html/venn-clip-1.png" alt="Équivalents spatiaux des opérateurs logiques." width="100%"><p class="caption">
FIGURE 5.8: Équivalents spatiaux des opérateurs logiques.
</p>
</div>
</div>
<div id="sélection-et-découpage" class="section level3" number="5.2.6">
<h3>
<span class="header-section-number">5.2.6</span> Sélection et découpage<a class="anchor" aria-label="anchor" href="#s%C3%A9lection-et-d%C3%A9coupage"><i class="fas fa-link"></i></a>
</h3>
<p>Le découpage d’objets peut modifier leur géométrie, mais il peut également sélectionner des objets, en ne renvoyant que les entités qui intersectent (ou intersectent partiellement) un objet de découpage/sélection.
Pour illustrer ce point, nous allons sélectionner les points qui incluent dans le cadre englobant (<em>bounding box</em>) des cercles <code>x</code> et <code>y</code> de la figure <a href="geometry-operations.html#fig:venn-clip">5.8</a>.
Certains points seront à l’intérieur d’un seul cercle, d’autres à l’intérieur des deux et d’autres encore à l’intérieur d’aucun.
<code><a href="https://r-spatial.github.io/sf/reference/st_sample.html">st_sample()</a></code> est utilisé ci-dessous pour générer une distribution <em>simple et aléatoire</em> de points à l’intérieur de l’étendue des cercles <code>x</code> et <code>y</code>, ce qui donne le résultat illustré dans la Figure <a href="geometry-operations.html#fig:venn-subset">5.9</a>, ce qui soulève la question suivante : comment sous-ensembler les points pour ne renvoyer que le point qui intersecte <em>à la fois</em> <code>x</code> et <code>y</code> ?</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:venn-subset"></span>
<img src="05-geometry-operations_files/figure-html/venn-subset-1.png" alt="Points distribués de manière aléatoire dans le cadre englobant les cercles x et y. Les points qui croisent les deux objets x et y sont mis en évidence." width="100%"><p class="caption">
FIGURE 5.9: Points distribués de manière aléatoire dans le cadre englobant les cercles x et y. Les points qui croisent les deux objets x et y sont mis en évidence.
</p>
</div>
<div class="sourceCode" id="cb178"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bb</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_bbox.html">st_bbox</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_combine.html">st_union</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">box</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sfc.html">st_as_sfc</a></span><span class="op">(</span><span class="va">bb</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">2017</span><span class="op">)</span></span>
<span><span class="va">p</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_sample.html">st_sample</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">box</span>, size <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">x_and_y</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html">st_intersection</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span></code></pre></div>
<p>Le code ci-dessous montre trois façons d’obtenir le même résultat.
Nous pouvons utiliser directement l’intersection <code>index{vecteur!intersection} de</code>x<code>et</code>y<code>(représentée par</code>x_et_y<code>dans l'extrait de code précédent) comme objet de sélection, comme le montre la première ligne du morceau de code ci-dessous. Nous pouvons également trouver l'intersection entre les points d'entrée représentés par</code>p<code>et l'objet de sélection et de découpage</code>x_et_y<code>, comme le montre la deuxième ligne du code ci-dessous. Cette deuxième approche renvoie les entités qui ont une intersection partielle avec</code>x_and_y<code>mais avec des géométries modifiées pour les entités dont les surfaces recoupent celle de l'objet de sélection. La troisième approche consiste à créer un objet de sélection en utilisant le prédicat spatial binaire</code>st_intersects()`, introduit dans le chapitre précédent.
Les résultats sont identiques (à l’exception de différences superficielles dans les noms d’attributs), mais l’implémentation diffère substantiellement :</p>
<div class="sourceCode" id="cb179"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p_xy1</span> <span class="op">=</span> <span class="va">p</span><span class="op">[</span><span class="va">x_and_y</span><span class="op">]</span></span>
<span><span class="va">p_xy2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html">st_intersection</a></span><span class="op">(</span><span class="va">p</span>, <span class="va">x_and_y</span><span class="op">)</span></span>
<span><span class="va">sel_p_xy</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_binary_pred.html">st_intersects</a></span><span class="op">(</span><span class="va">p</span>, <span class="va">x</span>, sparse <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">&amp;</span></span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_binary_pred.html">st_intersects</a></span><span class="op">(</span><span class="va">p</span>, <span class="va">y</span>, sparse <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">p_xy3</span> <span class="op">=</span> <span class="va">p</span><span class="op">[</span><span class="va">sel_p_xy</span><span class="op">]</span></span></code></pre></div>
<p>Bien que l’exemple ci-dessus soit plutôt trivial et fourni à des fins éducatives plutôt qu’appliquées, et que nous encouragions le lecteur à reproduire les résultats pour approfondir sa compréhension de la manipulation des objets vectoriels géographiques dans R, il soulève une question importante : quelle implémentation utiliser ?
En général, les implémentations les plus concises doivent être privilégiées, ce qui signifie la première approche ci-dessus.
Nous reviendrons sur la question du choix entre différentes implémentations d’une même technique ou d’un même algorithme au chapitre <a href="#algorithmes"><strong>??</strong></a>.</p>
</div>
<div id="gunions-de-géométries" class="section level3" number="5.2.7">
<h3>
<span class="header-section-number">5.2.7</span> GUnions de géométries<a class="anchor" aria-label="anchor" href="#gunions-de-g%C3%A9om%C3%A9tries"><i class="fas fa-link"></i></a>
</h3>
<p>
Comme nous l’avons vu dans la section <a href="#vector-attribute-aggregation"><strong>??</strong></a>, l’agrégation spatiale peut dissoudre silencieusement les géométries des polygones se touchant dans le même groupe.
Cela est démontré dans le code ci-dessous dans lequel 49 <code>us_states</code> sont agrégés en 4 régions à l’aide des fonctions de R base et du <strong>tidyverse</strong> (voir les résultats dans la figure <a href="geometry-operations.html#fig:us-regions">5.10</a>) :</p>
<div class="sourceCode" id="cb180"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">regions</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/aggregate.html">aggregate</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">us_states</span><span class="op">[</span>, <span class="st">"total_pop_15"</span><span class="op">]</span>, by <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">us_states</span><span class="op">$</span><span class="va">REGION</span><span class="op">)</span>,</span>
<span>                    FUN <span class="op">=</span> <span class="va">sum</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">regions2</span> <span class="op">=</span> <span class="va">us_states</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span><span class="op">(</span><span class="va">REGION</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarize</a></span><span class="op">(</span>pop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">total_pop_15</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:us-regions"></span>
<img src="05-geometry-operations_files/figure-html/us-regions-1.png" alt="Agrégation spatiale sur des polygones contigus, illustrée par l'agrégation de la population des États américains en régions, la population étant représentée par une couleur. Notez que l'opération dissout automatiquement les frontières entre les états." width="100%"><p class="caption">
FIGURE 5.10: Agrégation spatiale sur des polygones contigus, illustrée par l’agrégation de la population des États américains en régions, la population étant représentée par une couleur. Notez que l’opération dissout automatiquement les frontières entre les états.
</p>
</div>
<p>Que se passe-t-il au niveau des géométries ?
En coulisses, <code><a href="https://rdrr.io/pkg/terra/man/aggregate.html">aggregate()</a></code> et <code><a href="https://dplyr.tidyverse.org/reference/summarise.html">summarize()</a></code> combinent les géométries et dissolvent les frontières entre elles en utilisant <code><a href="https://r-spatial.github.io/sf/reference/geos_combine.html">st_union()</a></code>.
Ceci est démontré par le code ci-dessous qui crée une union des Etats-Unis de l’Ouest :</p>
<div class="sourceCode" id="cb181"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">us_west</span> <span class="op">=</span> <span class="va">us_states</span><span class="op">[</span><span class="va">us_states</span><span class="op">$</span><span class="va">REGION</span> <span class="op">==</span> <span class="st">"West"</span>, <span class="op">]</span></span>
<span><span class="va">us_west_union</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_combine.html">st_union</a></span><span class="op">(</span><span class="va">us_west</span><span class="op">)</span></span></code></pre></div>
<p>La fonction peut prendre deux géométries et les unir, comme le montre ll code ci-dessous qui crée un bloc occidental uni incorporant le Texas (défi : reproduire et représenter le résultat) :</p>
<div class="sourceCode" id="cb182"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">texas</span> <span class="op">=</span> <span class="va">us_states</span><span class="op">[</span><span class="va">us_states</span><span class="op">$</span><span class="va">NAME</span> <span class="op">==</span> <span class="st">"Texas"</span>, <span class="op">]</span></span>
<span><span class="va">texas_union</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_combine.html">st_union</a></span><span class="op">(</span><span class="va">us_west_union</span>, <span class="va">texas</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="type-trans" class="section level3" number="5.2.8">
<h3>
<span class="header-section-number">5.2.8</span> Transformations de type<a class="anchor" aria-label="anchor" href="#type-trans"><i class="fas fa-link"></i></a>
</h3>
<p>
La transformation d’un type de géométrie en un autre (<em>casting</em>) est une opération puissante.
Elle est implémentée dans la fonction <code><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast()</a></code> du package <strong>sf</strong>.
Il est important de noter que la fonction <code><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast()</a></code> se comporte différemment selon qu’il s’agit d’un objet géométrique simple (<code>sfg</code>), d’une entité avec une colonne géométrique simple (<code>sfc</code>) ou d’un objet entité simple.</p>
<p>Créons un multipoint pour illustrer le fonctionnement des transformations de type géométrique sur des objets de géométrie simple (<code>sfg</code>) :</p>
<div class="sourceCode" id="cb183"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multipoint</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipoint</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, <span class="fl">5</span>, <span class="fl">1</span>, <span class="fl">3</span>, <span class="fl">1</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Dans ce cas, <code><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast()</a></code> peut être utile pour transformer le nouvel objet en <em>linestring</em> (linéaire) ou en polygone (Figure <a href="geometry-operations.html#fig:single-cast">5.11</a>) :</p>
<div class="sourceCode" id="cb184"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">linestring</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">multipoint</span>, <span class="st">"LINESTRING"</span><span class="op">)</span></span>
<span><span class="va">polyg</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">multipoint</span>, <span class="st">"POLYGON"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:single-cast"></span>
<img src="05-geometry-operations_files/figure-html/single-cast-1.png" alt="Exemples de lignes et de polygones créés à partir d'une géométrie multipoint" width="100%"><p class="caption">
FIGURE 5.11: Exemples de lignes et de polygones créés à partir d’une géométrie multipoint
</p>
</div>
<p>La conversion de multipoint en ligne est une opération courante qui crée un objet ligne à partir d’observations ponctuelles ordonnées, telles que des mesures GPS ou des sources géolocalisés.
Cela permet d’effectuer des opérations spatiales telles que la longueur du chemin parcouru.
La conversion de multipoint ou de <em>linestring</em> en polygone est souvent utilisée pour calculer une surface, par exemple à partir de l’ensemble des mesures GPS prises autour d’un lac ou des coins d’un terrain à bâtir.</p>
<p>Le processus de transformation peut également être inversé en utilisant <code><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast()</a></code> :</p>
<div class="sourceCode" id="cb185"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multipoint_2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">linestring</span>, <span class="st">"MULTIPOINT"</span><span class="op">)</span></span>
<span><span class="va">multipoint_3</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">polyg</span>, <span class="st">"MULTIPOINT"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/all.equal.html">all.equal</a></span><span class="op">(</span><span class="va">multipoint</span>, <span class="va">multipoint_2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/all.equal.html">all.equal</a></span><span class="op">(</span><span class="va">multipoint</span>, <span class="va">multipoint_3</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>

<div class="rmdnote">
Pour les entités de géométries simples (<code>sfg</code>), <code>st_cast</code> permet également de transformer des géométries de non-multi-types vers des multi-types (par exemple, <code>POINT</code> vers <code>MULTIPOINT</code>) et de multi-types vers des non-multi-types.
Toutefois, dans le deuxième groupe de cas, seul le premier élément de l´ancien objet est conservé.
</div>
<p>La transformation en différent types géométrique des d’entités de type simple colonne (<code>sfc</code>) et des objets d’entités simples fonctionnent de la même manière que pour les entités de géométries simples (<code>sfg</code>) dans la plupart des cas.
Une différence importante est la conversion des multi-types en non-multi-types.
À la suite de ce processus, les multi-objets, <code>sf</code> ou <code>sfg</code> sont divisés en plusieurs non-multi-objets.</p>
<p>Le tableau <a href="geometry-operations.html#tab:sfs-st-cast">5.1</a> montre les transformations de type géométrique possibles sur les objets d’entités simples.
Les géométries d’entités simples (représentées par la première colonne du tableau) peuvent être transformées en plusieurs types de géométrie, représentés par les colonnes du tableau <a href="geometry-operations.html#tab:sfs-st-cast">5.1</a>
Plusieurs des transformations ne sont pas possibles, par exemple, vous ne pouvez pas convertir un point unique en un multilinéaire (<em>multilinestring</em>) ou un polygone (ainsi les cellules <code>[1, 4:5]</code> dans le tableau sont NA).
Certaines transformations divisent un seul élément en plusieurs sous-éléments, en “étendant” les objets <code>sf</code> (en ajoutant de nouvelles lignes avec des valeurs d’attributs dupliquées).
Par exemple, lorsqu’une géométrie multipoint composée de cinq paires de coordonnées est transformée en une géométrie “POINT”, la sortie contiendra cinq entités.</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:sfs-st-cast">TABLE 5.1: </span>Transformation de type de géométrie sur des entités simples (voir section 2.1) avec un type d’entrée par ligne et type de sortie par colonne
</caption>
<thead><tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
POI
</th>
<th style="text-align:right;">
MPOI
</th>
<th style="text-align:right;">
LIN
</th>
<th style="text-align:right;">
MLIN
</th>
<th style="text-align:right;">
POL
</th>
<th style="text-align:right;">
MPOL
</th>
<th style="text-align:right;">
GC
</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:left;">
POI(1)
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
MPOI(1)
</td>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
LIN(1)
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
MLIN(1)
</td>
<td style="text-align:right;">
7
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
POL(1)
</td>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
</tr>
<tr>
<td style="text-align:left;">
MPOL(1)
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
1
</td>
</tr>
<tr>
<td style="text-align:left;">
GC(1)
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
NA
</td>
<td style="text-align:right;">
1
</td>
</tr>
</tbody>
<tfoot><tr>
<td style="padding: 0; border:0;" colspan="100%">
<sup></sup> Note : Les valeurs comme (1) représentent le nombre d’entités ; NA signifie que l’opération n’est pas possible. Abréviations : POI, LIN, POL et GC font référence à POINT, LINESTRING, POLYGON et GEOMETRYCOLLECTION. La version MULTI de ces types de géométrie est indiquée par un M précédent, par exemple, MPOI est l’acronyme de MULTIPOINT.
</td>
</tr></tfoot>
</table></div>
<p>Essayons d’appliquer des transformations de type géométrique sur un nouvel objet, <code>multilinestring_sf</code>, à titre d’exemple (à gauche sur la Figure <a href="geometry-operations.html#fig:line-cast">5.12</a>) :</p>
<div class="sourceCode" id="cb186"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multilinestring_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">4</span>, <span class="fl">5</span>, <span class="fl">3</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>, </span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>,</span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span>, <span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">multilinestring</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multilinestring</a></span><span class="op">(</span><span class="va">multilinestring_list</span><span class="op">)</span></span>
<span><span class="va">multilinestring_sf</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sf.html">st_sf</a></span><span class="op">(</span>geom <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">multilinestring</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">multilinestring_sf</span></span>
<span><span class="co">#&gt; Simple feature collection with 1 feature and 0 fields</span></span>
<span><span class="co">#&gt; Geometry type: MULTILINESTRING</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5</span></span>
<span><span class="co">#&gt; CRS:           NA</span></span>
<span><span class="co">#&gt;                             geom</span></span>
<span><span class="co">#&gt; 1 MULTILINESTRING ((1 5, 4 3)...</span></span></code></pre></div>
<p>Vous pouvez l’imaginer comme un réseau routier ou fluvial.
Le nouvel objet n’a qu’une seule ligne qui définit toutes les lignes.
Cela limite le nombre d’opérations qui peuvent être faites, par exemple, cela empêche d’ajouter des noms à chaque segment de ligne ou de calculer les longueurs des lignes individuelles.
La fonction <code><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast()</a></code> peut être utilisée dans cette situation, car elle sépare un mutlilinestring en trois linestrings :</p>
<div class="sourceCode" id="cb187"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">linestring_sf2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_cast.html">st_cast</a></span><span class="op">(</span><span class="va">multilinestring_sf</span>, <span class="st">"LINESTRING"</span><span class="op">)</span></span>
<span><span class="va">linestring_sf2</span></span>
<span><span class="co">#&gt; Simple feature collection with 3 features and 0 fields</span></span>
<span><span class="co">#&gt; Geometry type: LINESTRING</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5</span></span>
<span><span class="co">#&gt; CRS:           NA</span></span>
<span><span class="co">#&gt;                    geom</span></span>
<span><span class="co">#&gt; 1 LINESTRING (1 5, 4 3)</span></span>
<span><span class="co">#&gt; 2 LINESTRING (4 4, 4 1)</span></span>
<span><span class="co">#&gt; 3 LINESTRING (2 2, 4 2)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:line-cast"></span>
<img src="05-geometry-operations_files/figure-html/line-cast-1.png" alt="Exemples de transformation de type de géométrie entre MULTILINESTRING (à gauche) et LINESTRING (à droite)." width="100%"><p class="caption">
FIGURE 5.12: Exemples de transformation de type de géométrie entre MULTILINESTRING (à gauche) et LINESTRING (à droite).
</p>
</div>
<p>Le nouvel objet permet la création d’attributs (voir la section <a href="attr.html#vec-attr-creation">3.2.5</a>) et la mesure de la longueur :</p>
<div class="sourceCode" id="cb188"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">linestring_sf2</span><span class="op">$</span><span class="va">name</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Riddle Rd"</span>, <span class="st">"Marshall Ave"</span>, <span class="st">"Foulke St"</span><span class="op">)</span></span>
<span><span class="va">linestring_sf2</span><span class="op">$</span><span class="va">length</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_length</a></span><span class="op">(</span><span class="va">linestring_sf2</span><span class="op">)</span></span>
<span><span class="va">linestring_sf2</span></span>
<span><span class="co">#&gt; Simple feature collection with 3 features and 2 fields</span></span>
<span><span class="co">#&gt; Geometry type: LINESTRING</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5</span></span>
<span><span class="co">#&gt; CRS:           NA</span></span>
<span><span class="co">#&gt;                    geom         name length</span></span>
<span><span class="co">#&gt; 1 LINESTRING (1 5, 4 3)    Riddle Rd   3.61</span></span>
<span><span class="co">#&gt; 2 LINESTRING (4 4, 4 1) Marshall Ave   3.00</span></span>
<span><span class="co">#&gt; 3 LINESTRING (2 2, 4 2)    Foulke St   2.00</span></span></code></pre></div>
</div>
</div>
<div id="geo-ras" class="section level2" number="5.3">
<h2>
<span class="header-section-number">5.3</span> Opérations géométriques sur les données raster<a class="anchor" aria-label="anchor" href="#geo-ras"><i class="fas fa-link"></i></a>
</h2>
<p>
Les opérations géométriques sur des raster comprennent le décalage, le retournement, la mise en miroir, la mise à l’échelle, la rotation ou la déformation des images.
Ces opérations sont nécessaires pour une variété d’applications, y compris le géoréférencement, utilisé pour permettre aux images d’être superposées sur une carte précise avec un CRS connu <span class="citation">(<a href="reproj-geo-data.html#ref-liu_essential_2009" role="doc-biblioref">Liu and Mason 2009</a>)</span>.
Il existe une variété de techniques de géoréférencement, notamment :</p>
<ul>
<li>Géorectification basée sur des <a href="https://www.qgistutorials.com/en/docs/3/georeferencing_basics.html">points de contrôle au sol</a> connus</li>
<li>Orthorectification, qui tient également compte de la topographie locale.</li>
<li>L’<a href="https://en.wikipedia.org/wiki/Image_registration">enregistrement</a> d’images est utilisé pour combiner des images de la même chose mais prises par différents capteurs en alignant une image sur une autre (en termes de système de coordonnées et de résolution).</li>
</ul>
<p>R est plutôt inadapté pour les deux premiers points car ceux-ci nécessitent souvent une intervention manuelle, c’est pourquoi ils sont généralement réalisés à l’aide d’un logiciel SIG dédié (voir également le chapitre : <a href="#gis"><strong>??</strong></a>).
En revanche, l’alignement de plusieurs images est possible dans R et cette section montre entre autres comment le faire.
Cela implique souvent de modifier l’étendue, la résolution et l’origine d’une image.
Une projection correspondante est bien sûr également nécessaire, mais elle est déjà traitée dans la section <a href="reproj-geo-data.html#reproj-ras">7.8</a>.</p>
<p>Dans tous les cas, il existe d’autres raisons d’effectuer une opération géométrique sur une seule image raster.
Par exemple, dans le chapitre <a href="#location"><strong>??</strong></a> nous définissons les zones métropolitaines en Allemagne comme des pixels de 20 km<sup>2</sup> avec plus de 500.000 habitants.
La trame d’habitants d’origine a cependant une résolution de 1 km<sup>2</sup>, c’est pourquoi nous allons diminuer (agréger) la résolution d’un facteur 20 (voir le chapitre <a href="#define-metropolitan-areas"><strong>??</strong></a>).
Une autre raison d’agréger une image matricielle est simplement de réduire le temps d’exécution ou d’économiser de l’espace disque.
Bien entendu, cela n’est possible que si la tâche à accomplir permet une résolution plus grossière.</p>
<div id="intersections-géométriques" class="section level3" number="5.3.1">
<h3>
<span class="header-section-number">5.3.1</span> Intersections géométriques<a class="anchor" aria-label="anchor" href="#intersections-g%C3%A9om%C3%A9triques"><i class="fas fa-link"></i></a>
</h3>
<p>
Dans la section <a href="spatial-operations.html#spatial-raster-subsetting">4.3.1</a>, nous avons montré comment extraire des valeurs d’un raster superposé à d’autres objets spatiaux.
Pour récupérer une sortie spatiale, nous pouvons utiliser pratiquement la même syntaxe de sélection.
La seule différence est que nous devons préciser que nous souhaitons conserver la structure matricielle en mettant l’argument <code>drop</code> à <code>FALSE</code>.
Ceci retournera un objet raster contenant les cellules dont les points médians se chevauchent avec <code>clip</code>.</p>
<div class="sourceCode" id="cb189"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elev</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/elev.tif"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">clip</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span>xmin <span class="op">=</span> <span class="fl">0.9</span>, xmax <span class="op">=</span> <span class="fl">1.8</span>, ymin <span class="op">=</span> <span class="op">-</span><span class="fl">0.45</span>, ymax <span class="op">=</span> <span class="fl">0.45</span>,</span>
<span>            resolution <span class="op">=</span> <span class="fl">0.3</span>, vals <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">9</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">elev</span><span class="op">[</span><span class="va">clip</span>, drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span></span>
<span><span class="co">#&gt; class       : SpatRaster </span></span>
<span><span class="co">#&gt; dimensions  : 2, 1, 1  (nrow, ncol, nlyr)</span></span>
<span><span class="co">#&gt; resolution  : 0.5, 0.5  (x, y)</span></span>
<span><span class="co">#&gt; extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)</span></span>
<span><span class="co">#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) </span></span>
<span><span class="co">#&gt; source(s)   : memory</span></span>
<span><span class="co">#&gt; name        : elev </span></span>
<span><span class="co">#&gt; min value   :   18 </span></span>
<span><span class="co">#&gt; max value   :   24</span></span></code></pre></div>
<p>Pour la même opération, nous pouvons également utiliser les commandes <code><a href="https://rdrr.io/pkg/terra/man/intersect.html">intersect()</a></code> et <code><a href="https://rdrr.io/pkg/terra/man/crop.html">crop()</a></code>.</p>
</div>
<div id="étendue-et-origine" class="section level3" number="5.3.2">
<h3>
<span class="header-section-number">5.3.2</span> Étendue et origine<a class="anchor" aria-label="anchor" href="#%C3%A9tendue-et-origine"><i class="fas fa-link"></i></a>
</h3>
<p>
Lors de la fusion ou de l’exécution de l’algèbre raster sur des rasters, leur résolution, leur projection, leur origine et/ou leur étendue doivent correspondre. Sinon, comment ajouter les valeurs d’un raster ayant une résolution de 0,2 degré décimal à un second raster ayant une résolution de 1 degré décimal ?
Le même problème se pose lorsque nous souhaitons fusionner des images satellite provenant de différents capteurs avec des projections et des résolutions différentes.
Nous pouvons traiter de telles disparités en alignant les trames.</p>
<p>Dans le cas le plus simple, deux images ne diffèrent que par leur étendue.
Le code suivant ajoute une ligne et deux colonnes de chaque côté de l’image raster tout en fixant toutes les nouvelles valeurs à une altitude de 1000 mètres (Figure <a href="geometry-operations.html#fig:extend-example">5.13</a>).</p>
<div class="sourceCode" id="cb190"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elev</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/elev.tif"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">elev_2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/extend.html">extend</a></span><span class="op">(</span><span class="va">elev</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:extend-example"></span>
<img src="05-geometry-operations_files/figure-html/extend-example-1.png" alt="Trame originale (à gauche) et la même trame (à droite) agrandie d'une ligne en haut et en bas et de deux colonnes à gauche et à droite." width="100%"><p class="caption">
FIGURE 5.13: Trame originale (à gauche) et la même trame (à droite) agrandie d’une ligne en haut et en bas et de deux colonnes à gauche et à droite.
</p>
</div>
<p>Performing an algebraic operation on two objects with differing extents in R, the <strong>terra</strong> package returns an error.</p>
<div class="sourceCode" id="cb191"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elev_3</span> <span class="op">=</span> <span class="va">elev</span> <span class="op">+</span> <span class="va">elev_2</span></span>
<span><span class="co">#&gt; Error: [+] extents do not match</span></span></code></pre></div>
<p>Cependant, nous pouvons aligner l’étendue de deux rasters avec <code><a href="https://rdrr.io/pkg/terra/man/extend.html">extend()</a></code>.
Au lieu d’indiquer à la fonction le nombre de lignes ou de colonnes à ajouter (comme nous l’avons fait précédemment), nous lui permettons de le déterminer en utilisant un autre objet raster.
Ici, nous étendons l’objet <code>elev</code> à l’étendue de <code>elev_2</code>.
Les lignes et colonnes nouvellement ajoutées prennent la valeur <code>NA</code>.</p>
<div class="sourceCode" id="cb192"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">elev_4</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/extend.html">extend</a></span><span class="op">(</span><span class="va">elev</span>, <span class="va">elev_2</span><span class="op">)</span></span></code></pre></div>
<p>L’origine d’un raster est le coin de la cellule le plus proche des coordonnées (0, 0).
La fonction <code><a href="https://rdrr.io/pkg/terra/man/origin.html">origin()</a></code> renvoie les coordonnées de l’origine.
Dans l’exemple ci-dessous, un coin de cellule existe avec les coordonnées (0, 0), mais ce n’est pas toujours le cas.</p>
<div class="sourceCode" id="cb193"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/origin.html">origin</a></span><span class="op">(</span><span class="va">elev_4</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0 0</span></span></code></pre></div>
<p>Si deux rasters ont des origines différentes, leurs cellules ne se chevauchent pas complètement, ce qui rends l’algèbre raster impossible.
Pour changer l’origine – utilisez <code><a href="https://rdrr.io/pkg/terra/man/origin.html">origin()</a></code>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Si les origines de deux données matricielles ne sont que marginalement éloignées, il suffit parfois d’augmenter l’argument &lt;code&gt;tolerance&lt;/code&gt; de &lt;code&gt;terra::terraOptions()&lt;/code&gt;.&lt;/p&gt;"><sup>23</sup></a>
La figure <a href="geometry-operations.html#fig:origin-example">5.14</a> révèle l’effet de la modification de l’origine de cette manière.</p>
<div class="sourceCode" id="cb194"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># changer l'origine</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/origin.html">origin</a></span><span class="op">(</span><span class="va">elev_4</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.25</span>, <span class="fl">0.25</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:origin-example"></span>
<img src="05-geometry-operations_files/figure-html/origin-example-1.png" alt="Rasters avec des valeurs identiques mais des origines différentes." width="100%"><p class="caption">
FIGURE 5.14: Rasters avec des valeurs identiques mais des origines différentes.
</p>
</div>
<p>Notez que le changement de résolution (section suivante) modifie souvent aussi l’origine.</p>
</div>
<div id="agrégation-et-désagrégation" class="section level3" number="5.3.3">
<h3>
<span class="header-section-number">5.3.3</span> Agrégation et désagrégation<a class="anchor" aria-label="anchor" href="#agr%C3%A9gation-et-d%C3%A9sagr%C3%A9gation"><i class="fas fa-link"></i></a>
</h3>
<p>
Les jeux de données raster peuvent également différer en ce qui concerne leur résolution.
Pour faire correspondre les résolutions, on peut soit diminuer (<code><a href="https://rdrr.io/pkg/terra/man/aggregate.html">aggregate()</a></code>) soit augmenter (<code><a href="https://rdrr.io/pkg/terra/man/disaggregate.html">disagg()</a></code>) la résolution des rasters.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Nous faisons ici référence à la résolution spatiale.
En télédétection, les résolutions spectrale (bandes spectrales), temporelle (observations dans le temps de la même zone) et radiométrique (profondeur de couleur) sont également importantes.
Consultez l’exemple &lt;code&gt;tapp()&lt;/code&gt; dans la documentation pour avoir une idée sur la façon de faire une agrégation de raster temporel.&lt;/p&gt;"><sup>24</sup></a>
À titre d’exemple, nous modifions ici la résolution spatiale de <code>dem</code> (trouvé dans le paquet <strong>spDataLarge</strong>) par un facteur 5 (Figure <a href="geometry-operations.html#fig:aggregate-example">5.15</a>).
De plus, la valeur de la cellule de sortie doit correspondre à la moyenne des cellules d’entrée (notez que l’on pourrait également utiliser d’autres fonctions, telles que <code><a href="https://rdrr.io/pkg/terra/man/summarize-generics.html">median()</a></code>, <code><a href="https://rdrr.io/r/base/sum.html">sum()</a></code>, etc ):</p>
<div class="sourceCode" id="cb195"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dem</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/dem.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">dem_agg</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/aggregate.html">aggregate</a></span><span class="op">(</span><span class="va">dem</span>, fact <span class="op">=</span> <span class="fl">5</span>, fun <span class="op">=</span> <span class="va">mean</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:aggregate-example"></span>
<img src="05-geometry-operations_files/figure-html/aggregate-example-1.png" alt="Raster original (gauche). Raster agrégé (droite)." width="100%"><p class="caption">
FIGURE 5.15: Raster original (gauche). Raster agrégé (droite).
</p>
</div>
<p>La fonction <code><a href="https://rdrr.io/pkg/terra/man/disaggregate.html">disagg()</a></code> augmente la résolution des objets matriciels, en fournissant deux méthodes pour assigner des valeurs aux cellules nouvellement créées : la méthode par défaut (<code>method = "near"</code>) donne simplement à toutes les cellules de sortie la valeur de la cellule d’entrée, et donc duplique les valeurs, ce qui conduit à une sortie “en bloc”.
La méthode <code>bilinear</code> utilise les quatre centres de pixels les plus proches de l’image d’entrée (points de couleur saumon sur la figure <a href="geometry-operations.html#fig:bilinear">5.16</a>) pour calculer une moyenne pondérée par la distance (flèches sur la figure <a href="geometry-operations.html#fig:bilinear">5.16</a>.
La valeur de la cellule de sortie est représentée par un carré dans le coin supérieur gauche de la figure <a href="geometry-operations.html#fig:bilinear">5.16</a>).</p>
<div class="sourceCode" id="cb196"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dem_disagg</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/disaggregate.html">disagg</a></span><span class="op">(</span><span class="va">dem_agg</span>, fact <span class="op">=</span> <span class="fl">5</span>, method <span class="op">=</span> <span class="st">"bilinear"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/identical.html">identical</a></span><span class="op">(</span><span class="va">dem</span>, <span class="va">dem_disagg</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:bilinear"></span>
<img src="05-geometry-operations_files/figure-html/bilinear-1.png" alt="La moyenne pondérée par la distance des quatre cellules d'entrée les plus proches détermine la sortie lors de l'utilisation de la méthode bilinéaire pour la désagrégation." width="100%"><p class="caption">
FIGURE 5.16: La moyenne pondérée par la distance des quatre cellules d’entrée les plus proches détermine la sortie lors de l’utilisation de la méthode bilinéaire pour la désagrégation.
</p>
</div>
<p>En comparant les valeurs de <code>dem</code> et <code>dem_disagg</code>, on constate qu’elles ne sont pas identiques (vous pouvez aussi utiliser <code><a href="https://rdrr.io/pkg/terra/man/compareGeom.html">compareGeom()</a></code> ou <code><a href="https://rdrr.io/pkg/terra/man/all.equal.html">all.equal()</a></code>).
Cependant, il ne fallait pas s’y attendre, puisque la désagrégation est une simple technique d’interpolation.
Il est important de garder à l’esprit que la désagrégation permet d’obtenir une résolution plus fine ; les valeurs correspondantes, cependant, ne peuvent qu’êtres aussi précises que leur source de résolution initiale.</p>
</div>
<div id="rééchantillonnage" class="section level3" number="5.3.4">
<h3>
<span class="header-section-number">5.3.4</span> Rééchantillonnage<a class="anchor" aria-label="anchor" href="#r%C3%A9%C3%A9chantillonnage"><i class="fas fa-link"></i></a>
</h3>
<p>
Les méthodes d’agrégation et de désagrégation ci-dessus ne conviennent que lorsque nous voulons modifier la résolution de notre raster par le facteur d’agrégation/désagrégation.
Cependant, que faire lorsque nous avons deux ou plusieurs raster avec des résolutions et des origines différentes ?
C’est le rôle du rééchantillonnage - un processus de calcul des valeurs pour les nouveaux emplacements des pixels.
En bref, ce processus prend les valeurs de notre raster original et recalcule de nouvelles valeurs pour un raster cible avec une résolution et une origine personnalisées.</p>
<!--toDo: jn-->
<!-- consider if adding this new figure makes sense -->
<p>Il existe plusieurs méthodes pour estimer les valeurs d’un raster avec différentes résolutions/origines, comme le montre la figure <a href="geometry-operations.html#fig:resampl">5.17</a>.
Ces méthodes comprennent :</p>
<ul>
<li>Plus proche voisin - attribue la valeur de la cellule la plus proche du raster original à la cellule du raster cible.
Cette méthode est rapide et convient généralement aux réechantillonnage de raster de catégories.</li>
<li>Interpolation bilinéaire - affecte une moyenne pondérée des quatre cellules les plus proches de l’image originale à la cellule de l’image cible (Figure <a href="geometry-operations.html#fig:bilinear">5.16</a>). Il s’agit de la méthode la plus rapide pour les rasters continus</li>
<li>Interpolation cubique - utilise les valeurs des 16 cellules les plus proches de la trame d’origine pour déterminer la valeur de la cellule de sortie, en appliquant des fonctions polynomiales du troisième ordre. Elle est aussi utilisée pour les raster continus. Elle permet d’obtenir une surface plus lissée que l’interpolation bilinéaire, mais elle est également plus exigeante en termes de calcul.</li>
<li>Interpolation par spline cubique - utilise également les valeurs des 16 cellules les plus proches de la trame d’origine pour déterminer la valeur de la cellule de sortie, mais applique des splines cubiques (fonctions polynomiales du troisième ordre par morceaux) pour obtenir les résultats. Elle est utilisée pour les trames continues</li>
<li>Rééchantillonnage par fenêtré de Lanczos - utilise les valeurs des 36 cellules les plus proches de la trame d’origine pour déterminer la valeur de la cellule de sortie. Il est utilisé pour les raster continues<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Une explication plus détaillée de cette méthode peut être trouvée sur &lt;a href="https://gis.stackexchange.com/a/14361/20955" class="uri"&gt;https://gis.stackexchange.com/a/14361/20955&lt;/a&gt;.&lt;/p&gt;'><sup>25</sup></a>
</li>
</ul>
<p>Les explications ci-dessus mettent en évidence le fait que seul le rééchantillonnage par <em>voisin le plus proche</em> est adapté aux rasters contenant des catégories, alors que toutes les méthodes peuvent être utilisées (avec des résultats différents) pour les matrices continues.
En outre, chaque méthode successive nécessite plus de temps de traitement.</p>
<p>Pour appliquer le rééchantillonnage, le package <strong>terra</strong> fournit une fonction <code><a href="https://rdrr.io/pkg/terra/man/resample.html">resample()</a></code>.
Elle accepte un raster d’entrée (<code>x</code>), un raster avec des propriétés spatiales cibles (<code>y</code>), et une méthode de rééchantillonnage (<code>method</code>).</p>
<p>Nous avons besoin d’un raster avec des propriétés spatiales cibles pour voir comment la fonction <code><a href="https://rdrr.io/pkg/terra/man/resample.html">resample()</a></code> fonctionne.
Pour cet exemple, nous créons <code>target_rast</code>, mais vous utiliserez souvent un objet raster déjà existant.</p>
<div class="sourceCode" id="cb197"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">target_rast</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span>xmin <span class="op">=</span> <span class="fl">794600</span>, xmax <span class="op">=</span> <span class="fl">798200</span>, </span>
<span>                   ymin <span class="op">=</span> <span class="fl">8931800</span>, ymax <span class="op">=</span> <span class="fl">8935400</span>,</span>
<span>                   resolution <span class="op">=</span> <span class="fl">150</span>, crs <span class="op">=</span> <span class="st">"EPSG:32717"</span><span class="op">)</span></span></code></pre></div>
<p>Ensuite, nous devons fournir nos deux objets rasters comme deux premiers arguments et l’une des méthodes de rééchantillonnage décrites ci-dessus.</p>
<div class="sourceCode" id="cb198"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dem_resampl</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/resample.html">resample</a></span><span class="op">(</span><span class="va">dem</span>, y <span class="op">=</span> <span class="va">target_rast</span>, method <span class="op">=</span> <span class="st">"bilinear"</span><span class="op">)</span></span></code></pre></div>
<p>La figure <a href="geometry-operations.html#fig:resampl">5.17</a> montre une comparaison de différentes méthodes de rééchantillonnage sur l’objet <code>dem</code>.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:resampl"></span>
<img src="05-geometry-operations_files/figure-html/resampl-1.png" alt="Comparaison visuelle du raster d'entré et de cinq méthodes de rééchantillonnage différentes." width="100%"><p class="caption">
FIGURE 5.17: Comparaison visuelle du raster d’entré et de cinq méthodes de rééchantillonnage différentes.
</p>
</div>
<p>La fonction <code><a href="https://rdrr.io/pkg/terra/man/resample.html">resample()</a></code> dispose également de quelques méthodes de rééchantillonnage supplémentaires, dont <code>sum</code>, <code>min</code>, <code>q1</code>, <code>med</code>, <code>q3</code>, <code>max</code>, <code>average</code>, <code>mode</code>, et <code>rms</code>.
Elles calculent toutes une statistique donnée en se basant sur les valeurs de toutes les cellules de la grille (hors <code>NA</code>).
Par exemple, <code>sum</code> est utile lorsque chaque cellule de raster représente une variable étendue dans l’espace (par exemple, le nombre de personnes).
En utilisant <code>sum</code>, le raster ré-échantillonné devrait avoir le même nombre total de personnes que le raster original.</p>
<p>Comme vous le verrez dans la section <a href="reproj-geo-data.html#reproj-ras">7.8</a>, la reprojection de raster est un cas particulier de rééchantillonnage lorsque notre raster cible a un CRS différent de la trame d’origine.</p>

<div class="rmdnote">
<p>La plupart des opérations géométriques dans <strong>terra</strong> sont conviviales, plutôt rapides, et fonctionnent sur de grands objets rasters.
Cependant, il peut y avoir des cas où <strong>terra</strong> n´est pas le plus performant, que ce soit pour des objets rasters étendus ou pour de nombreux fichiers rasters, et où des alternatives doivent être envisagées.</p>
<p>Les alternatives les plus établies sont fournies par la bibliothèque GDAL.
Elle contient plusieurs fonctions utilitaires, dont :</p>
<ul>
<li>
<code>gdalinfo</code> - liste diverses informations sur un fichier raster, y compris sa résolution, son CRS, sa boîte de délimitation, et plus encore.</li>
<li>
<code>gdal_translate</code> - convertit les données raster entre différents formats de fichiers.</li>
<li>
<code>gdal_rasterize</code> - Convertit les données vectorielles en fichiers raster.</li>
<li>
<code>gdalwarp</code> - permet le mosaïquage, le rééchantillonnage, le recadrage et la reprojection de données matricielles.</li>
</ul>
Toutes les fonctions ci-dessus sont écrites en C++, mais peuvent être appelées dans R en utilisant le paquet <strong>gdalUtilities</strong>.
Il est important de noter que toutes ces fonctions attendent un chemin de fichier raster en entrée et retournent souvent leur sortie sous forme de fichier raster (par exemple, <code>gdalUtilities::gdal_translate("mon_fichier.tif", "nouveau_fichier.tif", t_srs = "EPSG:4326")</code>).
Ceci est très différent de l´approche habituelle de <strong>terra</strong>, qui attend des objets <code>SpatRaster</code> en entrée.
</div>
</div>
</div>
<div id="exercises-2" class="section level2" number="5.4">
<h2>
<span class="header-section-number">5.4</span> Exercises<a class="anchor" aria-label="anchor" href="#exercises-2"><i class="fas fa-link"></i></a>
</h2>
<p>E1. Générer et représenter des versions simplifiées de l’ensemble de données <code>nz</code>.
Expérimentez avec différentes valeurs de <code>keep</code> (allant de 0,5 à 0,00005) pour <code>ms_simplify()</code> et <code>dTolerance</code> (de 100 à 100 000) pour <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code>.</p>
<ul>
<li>À partir de quelle valeur la forme du résultat commence-t-elle à se dégrader pour chaque méthode, rendant la Nouvelle-Zélande méconnaissable ?</li>
<li>Avancé : Qu’est-ce qui est différent dans le type de géométrie des résultats de <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_simplify()</a></code> par rapport au type de géométrie de <code>ms_simplify()</code> ? Quels problèmes cela crée-t-il et comment peut-on les résoudre ?</li>
</ul>
<p>E2. Dans le premier exercice du chapitre Opérations sur les données spatiales, il a été établi que la région de Canterbury comptait 70 des 101 points les plus élevés de Nouvelle-Zélande.
En utilisant <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer()</a></code>, combien de points dans <code>nz_height</code> sont à moins de 100 km de Canterbury ?</p>
<p>E3. Trouvez le centroïde géographique de la Nouvelle-Zélande.
A quelle distance se trouve-t-il du centroïde géographique de Canterbury ?</p>
<p>E4. La plupart des cartes du monde sont orientées du nord vers le haut.
Une carte du monde orientée vers le sud pourrait être créée par une réflexion (une des transformations affines non mentionnées dans ce chapitre) de la géométrie de l’objet <code>world</code>.
Comment faire ?
Astuce : vous devez utiliser un vecteur à deux éléments pour cette transformation.
Bonus : créez une carte de votre pays à l’envers.</p>
<p>E5. Sélectionnez le point dans <code>p</code> qui est contenu dans <code>x</code> <em>et</em> <code>y</code>.</p>
<ul>
<li>En utilisant les opérateurs de sélection de base.</li>
<li>En utilisant un objet intermédiaire créé avec <code><a href="https://r-spatial.github.io/sf/reference/geos_binary_ops.html">st_intersection()</a></code>.</li>
</ul>
<p>E6. Calculez la longueur des limites des États américains en mètres.
Quel État a la frontière la plus longue et quel État a la plus courte ?
Indice : La fonction <code>st_length</code> calcule la longueur d’une géométrie <code>LINESTRING</code> ou <code>MULTILINESTRING</code>.</p>
<p>E7. Lire le fichier srtm.tif dans R (<code>srtm = rast(system.file("raster/srtm.tif", package = "spDataLarge"))</code>).
Ce raster a une résolution de 0.00083 par 0.00083 degrés.
Changez sa résolution à 0,01 par 0,01 degrés en utilisant toutes les méthodes disponibles dans le paquet <strong>terra</strong>.
Visualisez les résultats.
Pouvez-vous remarquer des différences entre les résultats de ces différentes méthodes de rééchantillonnage ?</p>

</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="spatial-operations.html"><span class="header-section-number">4</span> Géotraitements</a></div>
<div class="next"><a href="raster-vector.html"><span class="header-section-number">6</span> Interactions raster-vecteur</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Note: La Seconde Edition est en construction 🏗</h2>
    <!--<p>C'est le moment idéal pour tester les paquets en cours de développement et fournir vos commentaires</p>
        <ul class="list-unstyled">
          <li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Fournir un commentaire (5 min)</a></li>>-->
          <li><a href="https://geocompr.robinlovelace.net/#reproducibility">Installer la dernière version</a></li>
          <li><a href="https://github.com/Robinlovelace/geocompr/issues">Signaler un problème <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/PMztXYgNxp">Discuter sur Discord <i class="fab fa-discord"></i></a></li>
          <li><a href="https://how-to-help-ukraine-now.super.site">Support Ukraine 🇺🇦
</a></li>
        
        <hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>Sur cette page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#geometry-operations"><span class="header-section-number">5</span> Opèrations géométriques</a></li>
<li><a class="nav-link" href="#pr%C3%A9requis-3">Prérequis</a></li>
<li><a class="nav-link" href="#introduction-2"><span class="header-section-number">5.1</span> Introduction</a></li>
<li>
<a class="nav-link" href="#geo-vec"><span class="header-section-number">5.2</span> Opérations géométriques sur les données vectorielles</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#simplification"><span class="header-section-number">5.2.1</span> Simplification</a></li>
<li><a class="nav-link" href="#centro%C3%AFdes"><span class="header-section-number">5.2.2</span> Centroïdes</a></li>
<li><a class="nav-link" href="#bufferstampons"><span class="header-section-number">5.2.3</span> Buffers/tampons</a></li>
<li><a class="nav-link" href="#application-affine"><span class="header-section-number">5.2.4</span> Application affine</a></li>
<li><a class="nav-link" href="#clipping"><span class="header-section-number">5.2.5</span> Découper</a></li>
<li><a class="nav-link" href="#s%C3%A9lection-et-d%C3%A9coupage"><span class="header-section-number">5.2.6</span> Sélection et découpage</a></li>
<li><a class="nav-link" href="#gunions-de-g%C3%A9om%C3%A9tries"><span class="header-section-number">5.2.7</span> GUnions de géométries</a></li>
<li><a class="nav-link" href="#type-trans"><span class="header-section-number">5.2.8</span> Transformations de type</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#geo-ras"><span class="header-section-number">5.3</span> Opérations géométriques sur les données raster</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#intersections-g%C3%A9om%C3%A9triques"><span class="header-section-number">5.3.1</span> Intersections géométriques</a></li>
<li><a class="nav-link" href="#%C3%A9tendue-et-origine"><span class="header-section-number">5.3.2</span> Étendue et origine</a></li>
<li><a class="nav-link" href="#agr%C3%A9gation-et-d%C3%A9sagr%C3%A9gation"><span class="header-section-number">5.3.3</span> Agrégation et désagrégation</a></li>
<li><a class="nav-link" href="#r%C3%A9%C3%A9chantillonnage"><span class="header-section-number">5.3.4</span> Rééchantillonnage</a></li>
</ul>
</li>
<li><a class="nav-link" href="#exercises-2"><span class="header-section-number">5.4</span> Exercises</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/geocompx/geocompr-fr/blob/main/05-geometry-operations.Rmd">Code source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/geocompx/geocompr-fr/edit/main/05-geometry-operations.Rmd">Editer cette page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation avec R</strong>" a été ecris par Robin Lovelace, Jakub Nowosad, Jannes Muenchow. Traduction: Olivier Leroy.  et sa dernière mise en ligne date de  2023-01-13.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>Ce livre a été ecris grâce à <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
