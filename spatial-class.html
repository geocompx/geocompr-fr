<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 2 La donnée géographique dans R | Geocomputation avec R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="Prérequis C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué. Vous devez avoir accès à un ordinateur sur lequel est installé R...">
<meta name="generator" content="bookdown 0.28 with bs4_book()">
<meta property="og:title" content="Chapter 2 La donnée géographique dans R | Geocomputation avec R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://geocompr.github.io/fr/spatial-class.html">
<meta property="og:image" content="https://geocompr.github.io/es/images/cover.png">
<meta property="og:description" content="Prérequis C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué. Vous devez avoir accès à un ordinateur sur lequel est installé R...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 2 La donnée géographique dans R | Geocomputation avec R">
<meta name="twitter:description" content="Prérequis C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué. Vous devez avoir accès à un ordinateur sur lequel est installé R...">
<meta name="twitter:image" content="https://geocompr.github.io/es/images/cover.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Lato-0.4.2/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.2/font.css" rel="stylesheet">
<link href="libs/Montserrat-0.4.2/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.4.0/transition.js"></script><script src="libs/bs3compat-0.4.0/tabs.js"></script><script src="libs/bs3compat-0.4.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.1.1/leaflet.js"></script><link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation avec R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table des matières</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Bienvenue!</a></li>
<li><a class="" href="foreword-1st-edition.html">Foreword (1st Edition)</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Introduction</a></li>
<li class="book-part">Foundations</li>
<li><a class="active" href="spatial-class.html"><span class="header-section-number">2</span> La donnée géographique dans R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> Opérations sur les tables attributaires</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> Géotraitements</a></li>
<li><a class="" href="geometric-operations.html"><span class="header-section-number">5</span> Opèrations géométriques</a></li>
<li><a class="" href="raster-vector.html"><span class="header-section-number">6</span> Interactions raster-vecteur</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/geocompr/fr">Code source du livre <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="spatial-class" class="section level1" number="2">
<h1>
<span class="header-section-number">2</span> La donnée géographique dans R<a class="anchor" aria-label="anchor" href="#spatial-class"><i class="fas fa-link"></i></a>
</h1>
<div id="prérequis" class="section level2 unnumbered">
<h2>Prérequis<a class="anchor" aria-label="anchor" href="#pr%C3%A9requis"><i class="fas fa-link"></i></a>
</h2>
<p>C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué.
Vous devez avoir accès à un ordinateur sur lequel est installé R (version <a href="https://stat.ethz.ch/pipermail/r-announce/2022/000683.html">4.2.0</a> ou supérieure).
Nous vous recommandons vivement de ne pas vous contenter de lire le texte, mais également <em>d’exécuter le code</em> afin de renforcer vos compétences en géocomputation.</p>
<p>Pour garder une trace de votre progression, il est utile de créer un nouveau dossier sur votre ordinateur pour enregistrer au fur et à mesure vos notes dans des scripts R, vos sorties graphiques ou autres.
Vous pouvez <a href="https://github.com/Robinlovelace/geocompr/archive/refs/heads/main.zip">télécharger</a> ou <a href="https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository">cloner</a> le code source du livre en anglais à partir de <a href="https://github.com/Robinlovelace/geocompr">github.com/robinlovelace/geocompr</a> pour vous aider dans votre apprentissage.
Nous vous recommandons vivement d’installer un environnement de développement intégré (IDE) tel que <a href="https://www.rstudio.com/products/rstudio/download/#download">RStudio</a> (recommandé pour la plupart des gens) ou <a href="https://github.com/REditorSupport/vscode-R">VS Code</a>)<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;.
Nous conseillons d’utiliser les &lt;a href="https://r4ds.had.co.nz/workflow-projects.html"&gt;projets d’Rstudio&lt;/a&gt;, les &lt;a href="https://code.visualstudio.com/docs/editor/workspaces"&gt;espaces de travail de VS Code&lt;/a&gt; ou un des autres systèmes similaires pour vous organiser.
Un moyen rapide de le faire avec RStudio est d’utiliser le package &lt;strong&gt;rstudioapi&lt;/strong&gt;.
Ouvrez un nouveau projet appelé ‘geocompr-learning’ dans votre répertoire personnel avec la commande suivante à partir de la console R dans RStudio, par exemple : &lt;code&gt;rstudioapi::openProject("~/geocompr-learning")&lt;/code&gt;.&lt;/p&gt;'><sup>6</sup></a></p>
<p>Si vous ne connaissez pas R, nous vous recommandons de suivre les ressources d’introduction à R telles que <a href="https://rstudio-education.github.io/hopr/starting.html">Hands on Programming with R</a> de Garrett Grolemund ou <a href="https://cengel.github.io/R-intro/">Introduction to R</a> de Claudia Engel avant de vous lancer dans ce livre.
Organisez votre travail (par exemple, avec des projets RStudio) et donnez à vos scripts des noms judicieux tels que <code>02-chapter.R</code> pour documenter le code que vous écrivez au fur et à mesure de votre apprentissage.
</p>
<p>Une fois confortable il est temps de tester un peu de code !
À moins que ces paquets ne soient déjà installés, la première chose à faire est d’installer les paquets R fondamentaux utilisés dans ce chapitre, à l’aide des commandes suivantes :<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
&lt;strong&gt;spDataLarge&lt;/strong&gt; n’est pas sur le CRAN, ce qui signifie qu’il doit être installé via &lt;em&gt;r-universe&lt;/em&gt; ou avec la commande suivante : &lt;code&gt;remotes::install_github("Nowosad/spDataLarge")&lt;/code&gt;.&lt;/p&gt;'><sup>7</sup></a></p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html">install.packages</a></span><span class="op">(</span><span class="st">"sf"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html">install.packages</a></span><span class="op">(</span><span class="st">"terra"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html">install.packages</a></span><span class="op">(</span><span class="st">"spData"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html">install.packages</a></span><span class="op">(</span><span class="st">"spDataLarge"</span>, repos <span class="op">=</span> <span class="st">"https://nowosad.r-universe.dev"</span><span class="op">)</span></span></code></pre></div>

<div class="rmdnote">
Sur Mac ou Linux, la commande précédente d´installation de <strong>sf</strong> peut ne pas fonctionner du premier coup.
Ces systèmes d´exploitation (OS) ont une “configuration requise” décrite dans la notice du paquets.<a href="https://github.com/r-spatial/sf">README</a>.
Des instructions spécifiques pour chaque système d´exploitation sont disponibles en ligne, comme l´article <em>Installation de R 4.0 sur Ubuntu 20.04</em> sur le blog <a href="https://rtask.thinkr.fr/installation-of-r-4-0-on-ubuntu-20-04-lts-and-tips-for-spatial-packages/">rtask.thinkr.fr</a>.
</div>
<p>Tous les paquets nécessaires pour reproduire la première partie du livre peuvent être installés via la commande suivante : <code>remotes::install_github("geocompr/geocompkg")</code>.
Cette commande utilise la fonction <code>install_packages()</code> du package <strong>remotes</strong> pour installer le code source hébergé sur la plate-forme d’hébergement, de version et de collaboration de code GitHub.
La commande suivante installera <strong>toutes</strong> les dépendances nécessaires pour reproduire l’intégralité du livre (attention : cela peut prendre plusieurs minutes) : <code>remotes::install_github("geocompr/geocompkg", dependencies = TRUE)</code></p>
<p>Les paquets nécessaires peuvent être “chargés” (techniquement, ils sont attachés) avec la fonction <code><a href="https://rdrr.io/r/base/library.html">library()</a></code> :</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span>          <span class="co"># classes et fonctions pour les données vectorielles</span></span>
<span><span class="co">#&gt; Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE</span></span></code></pre></div>
<p>Conformément à la section <a href="#intro-sf"><strong>??</strong></a>, la sortie de <code><a href="https://r-spatial.github.io/sf/">library(sf)</a></code> mentionne les versions des bibliothèques géographiques clés, comme GEOS, utilisées par ce paquet.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/terra/">terra</a></span><span class="op">)</span>      <span class="co"># classes et fonctions pour les données rasters</span></span></code></pre></div>
<p>Les autres paquets installés contiennent des données qui seront utilisées dans le livre:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://nowosad.github.io/spData/">spData</a></span><span class="op">)</span>        <span class="co"># chargement de données geographiques</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Nowosad/spData">spDataLarge</a></span><span class="op">)</span>   <span class="co"># chargement de données geographiques plus volumineuses</span></span></code></pre></div>
</div>
<div id="intro-spatial-class" class="section level2" number="2.1">
<h2>
<span class="header-section-number">2.1</span> Introduction<a class="anchor" aria-label="anchor" href="#intro-spatial-class"><i class="fas fa-link"></i></a>
</h2>
<p>Ce chapitre fournit de brèves explications sur les modèles fondamentaux des données géographiques : vecteur et raster.
Nous présenterons la théorie qui sous-tend chaque modèle de données et les disciplines dans lesquelles ils prédominent, avant de démontrer leur mise en œuvre dans R.</p>
<p>Le <em>modèle de données vectoriel</em> représente le monde à l’aide de points, de lignes et de polygones.
Ceux-ci ont des frontières discrètes et bien définies, ce qui signifie que les ensembles de données vectorielles ont généralement un haut niveau de précision (mais pas nécessairement d’exactitude, comme nous le verrons dans la section @ref(unités)).
Le <em>modèle de données raster</em> divise la surface en pixel de taille constante.
Les données rasters sont la base des images d’arrière-plan utilisées dans les cartes Web et constituent une source essentielle de données géographiques depuis les débuts de la photographie aérienne et des dispositifs de télédétection par satellite.
Les rasters agrègent spatialement des informations à une résolution donnée. Ils maintiennent ainsi une consistance temporelle sur de grandes superficies (de nombreux jeux de données rasters sont disponibles à l’échelle planétaire).</p>
<p>Que faut-il utiliser ?
La réponse dépend probablement de votre domaine d’application :</p>
<ul>
<li>Les données vectorielles ont tendance à dominer les sciences sociales parce que les constructions humaines ont tendance à avoir des frontières discrètes.</li>
<li>Les données rasters dominent de nombreuses sciences de l’environnement en raison de la dépendance aux données de télédétection.</li>
</ul>
<p>Il y a beaucoup de chevauchements dans certains domaines et les ensembles de données rasters et vectorielles peuvent être utilisés conjointement :
les écologistes et les démographes, par exemple, utilisent couramment les deux.
En outre, il est possible de les convertir (voir la section <a href="raster-vector.html#raster-vector">6</a>).
Que votre travail mobilise plus un type de jeux de données, vectorielles ou rasters, il reste utile de comprendre leurs modèles de données sous-jacents pour bien les utiliser, comme nous le verrons dans les chapitres suivants.
Ce livre utilise les paquets <strong>sf</strong> et <strong>terra</strong> pour travailler, respectivement, avec des données vectorielles et des jeux de données raster.</p>
</div>
<div id="données-vectorielles" class="section level2" number="2.2">
<h2>
<span class="header-section-number">2.2</span> Données vectorielles<a class="anchor" aria-label="anchor" href="#donn%C3%A9es-vectorielles"><i class="fas fa-link"></i></a>
</h2>

<div class="rmdnote">
Attention lorsque vous utilisez le mot ‘vecteur’ car il peut avoir deux significations dans ce livre :
les données vectorielles géographiques et la classe <code>vector</code> (notez la police <code>monospace</code>) dans R.
Le premier est un modèle de données, le second est une classe informatique de R tout comme le sont <code>data.frame</code> et <code>matrix</code>.
Il existe néanmoins un lien entre les deux : les coordonnées spatiales qui sont au cœur du modèle de données vectorielles géographiques peuvent être représentées en R à l´aide d´objets <code>vector</code>.
</div>
<p>Le modèle de données géographiques vectorielles est basé sur des points situés dans un système de coordonnées de référence (CRS).
Les points peuvent représenter des caractéristiques propres (par exemple, l’emplacement d’un arrêt de bus) ou être reliés entre eux pour former des géométries plus complexes telles que des lignes et des polygones.
La plupart des géométries construites avec des points ne sont qu’en deux dimensions (les CRS tridimensionnels contiennent une valeur supplémentaire <span class="math inline">\(z\)</span>, représentant généralement la hauteur au-dessus du niveau de la mer).</p>
<p>Dans ce système, Londres, par exemple, peut être représentée par les coordonnées <code>c(-0,1, 51,5)</code>.
Cela signifie que sa position est -0,1 degré est et 51,5 degrés nord par rapport au point d’origine.
Ce dernier se situe à 0 degré de longitude (le méridien d’origine) et à 0 degré de latitude (l’équateur) dans un CRS géographique (‘long/lat’) (Figure <a href="spatial-class.html#fig:vectorplots">2.1</a>, panneau de gauche).
Cette même localisation pourrait également être approximée dans un SCR projeté avec des valeurs “Est/Nord” de <code>c(530000, 180000)</code> dans le <a href="https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid"><em>British National Grid</em></a>, ce qui signifie que Londres est située à 530 km <em>Est</em> et 180 km <em>Nord</em> de l’origine du SCR.
Ceci peut être vérifié visuellement : un peu plus de 5 “boîtes” — des zones carrées délimitées par les lignes de grille grises de 100 km de large — séparent le point représentant Londres de l’origine (Figure <a href="spatial-class.html#fig:vectorplots">2.1</a>, panneau de droite).</p>
<p>L’emplacement de l’origine de la grille nationale, dans la mer au-delà de la péninsule du sud-ouest de l’Angleterre, garantit que la plupart des lieux du Royaume-Uni auront des valeurs positives en abscisse et ordonnée.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
L’origine à laquelle nous faisons référence, représentée en bleu sur la figure &lt;a href="spatial-class.html#fig:vectorplots"&gt;2.1&lt;/a&gt;, est en fait la “fausse” origine.
L’origine ” réelle “, c’est-à-dire l’endroit où les distorsions sont minimales, est située à 2° W et 49° N.
Cette origine a été choisie par l’&lt;em&gt;Ordnance Survey of the United States&lt;/em&gt; afin de se situer approximativement au centre de la masse continentale britannique dans le sens longitudinal.&lt;/p&gt;'><sup>8</sup></a>
Les CRS sont plus complexes, et seront abordées plus en détail dans les sections <a href="spatial-class.html#crs-intro">2.4</a> et <a href="#reproj-geo-data"><strong>??</strong></a>. Cependant pour les besoins de cette section, il suffit de savoir que les coordonnées consistent en deux nombres représentant la distance par rapport à un point d’origine, généralement dans les dimensions <span class="math inline">\(x\)</span> puis <span class="math inline">\(y\)</span>.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vectorplots"></span>
<img src="figures/vector_lonlat.png" alt="Représentation de données vectorielles (ponctuelles) dans laquelle l'emplacement de Londres (X rouge) est représenté par rapport à une origine (le cercle bleu). La carte de gauche représente un SCR géographique dont l'origine se situe à 0° de longitude et de latitude. Le graphique de droite représente un SCR projeté dont l'origine est située dans la mer à l'ouest de la péninsule du sud-ouest anglaise." width="49%"><img src="figures/vector_projected.png" alt="Représentation de données vectorielles (ponctuelles) dans laquelle l'emplacement de Londres (X rouge) est représenté par rapport à une origine (le cercle bleu). La carte de gauche représente un SCR géographique dont l'origine se situe à 0° de longitude et de latitude. Le graphique de droite représente un SCR projeté dont l'origine est située dans la mer à l'ouest de la péninsule du sud-ouest anglaise." width="49%"><p class="caption">
FIGURE 2.1: Représentation de données vectorielles (ponctuelles) dans laquelle l’emplacement de Londres (X rouge) est représenté par rapport à une origine (le cercle bleu). La carte de gauche représente un SCR géographique dont l’origine se situe à 0° de longitude et de latitude. Le graphique de droite représente un SCR projeté dont l’origine est située dans la mer à l’ouest de la péninsule du sud-ouest anglaise.
</p>
</div>
<p><strong>sf</strong> fournit des classes informatiques pour les données géographiques vectorielles ainsi qu’une interface en ligne de commande pour des bibliothèques de géocomputation de bas niveau :</p>
<ul>
<li>
<a href="https://gdal.org/">GDAL</a>, pour la lecture, l’écriture et la manipulation d’une large gamme de formats de données géographiques, couverte dans le chapitre <a href="#read-write"><strong>??</strong></a>
</li>
<li>
<a href="https://proj.org/">PROJ</a>, une puissante bibliothèque pour les transformations de systèmes de coordonnées, qui sous-tend le chapitre <a href="#reproj-geo-data"><strong>??</strong></a>
</li>
<li>
<a href="https://libgeos.org/">GEOS</a>, un moteur de géométrie euclidienne pour les opérations telles que le calcul des tampons et des centroïdes sur les données avec un SCR projeté, couvert dans le chapitre <a href="geometric-operations.html#geometric-operations">5</a>
</li>
<li>
<a href="https://s2geometry.io/">S2</a>, un moteur de géométrie sphérique écrit en C++ développé par Google, via le paquet <a href="https://r-spatial.github.io/s2/"><strong>s2</strong></a>, couvert dans la section <a href="spatial-class.html#s2">2.2.9</a> ci-dessous et dans le chapitre <a href="#reproj-geo-data"><strong>??</strong></a>.
<!-- - [liblwgeom](https://github.com/postgis/postgis/tree/master/liblwgeom), a geometry engine used by PostGIS, via the [**lwgeom**](https://r-spatial.github.io/lwgeom/) package -->
</li>
</ul>
<p>Les informations concernant ces interfaces sont indiquées par <em>sf</em> lorsque que celui ci est chargé pour la première fois: via le message <code>Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE</code> apparue en dessous de la commande <code><a href="https://r-spatial.github.io/sf/">library(sf)</a></code> au tout début de ce chapitre. Ce message indique les versions des bibliothèques liées GEOS, GDAL et PROJ (chiffre pouvant varier au cours du temps et entre les ordinateurs) et si oui ou non l’interface avec S2 est activée.
Aujourd’hui, nous considérons que c’est un acquis, cependant, c’est grâce à l’intégration étroite entre les différentes bibliothèques géographiques qu’un travail de géocomputation reproductible est possible.</p>
<p>Une fonctionnalité intéressante de <strong>sf</strong> est que vous pouvez changer le moteur de géométrie par défaut utilisé sur les données non projetées : “Désactiver” S2 peut être fait avec la commande <code>sf::sf_use_s2(FALSE)</code>, ce qui signifie que le moteur de géométrie euclidienne GEOS sera utilisé par défaut pour toutes les opérations de géométrie, y compris celles sur les données non projetées.
Comme nous le verrons dans la Section <a href="spatial-class.html#s2">2.2.9</a>, la géométrie euclidienne, ou plane, est basée sur un espace à 2 dimensions.
Les moteurs de géométrie euclidienne tels que GEOS supposent des coordonnées “plates” (projetées), tandis que les moteurs de géométrie sphérique tels que S2 supposent des coordonnées non projetées (lon/lat).</p>
<p>Cette section présente les classes <strong>sf</strong> en préparation des chapitres suivants (les chapitres <a href="geometric-operations.html#geometric-operations">5</a> et <a href="#read-write"><strong>??</strong></a> couvrent respectivement l’interface GEOS et GDAL)</p>
<div id="une-introduction-aux-simple-features" class="section level3" number="2.2.1">
<h3>
<span class="header-section-number">2.2.1</span> Une introduction aux <em>Simple Features</em><a class="anchor" aria-label="anchor" href="#une-introduction-aux-simple-features"><i class="fas fa-link"></i></a>
</h3>
<p><em>Simple features</em> ou “entités simples” est un <a href="http://portal.opengeospatial.org/files/?artifact_id=25355">Format ouvert</a> développé et approuvé par l’Open Geospatial Consortium (OGC), une organisation à but non lucratif dont nous reviendrons sur les activités dans un chapitre ultérieur (section <a href="#file-formats"><strong>??</strong></a>).
<em>Simple Features</em> est un modèle de données hiérarchique qui représente un large éventail de types géométriques.
Sur les 18 types géométriques pris en charge par la spécification, seuls 7 sont utilisés dans la grande majorité des recherches géographiques (voir Figure <a href="spatial-class.html#fig:sf-ogc">2.2</a>) ;
ces types géométriques de base sont entièrement pris en charge par le paquet R <strong>sf</strong> <span class="citation">(<a href="raster-vector.html#ref-pebesma_simple_2018" role="doc-biblioref">Pebesma 2018</a>)</span>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Le format OGC complet comprend des types de géométrie plutôt exotiques, notamment les types de géométrie “surface” et “courbe”, qui ont actuellement une application limitée dans le monde réel.
Les 18 types peuvent être manipulés avec le package &lt;strong&gt;sf&lt;/strong&gt;, bien qu’actuellement (2022) leur représentation ne fonctionne plus que pour les “7 principaux”.&lt;/p&gt;"><sup>9</sup></a></p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:sf-ogc"></span>
<img src="figures/sf-classes.png" alt="Les types de *Simple features* pleinement disponibles dans sf." width="60%"><p class="caption">
FIGURE 2.2: Les types de <em>Simple features</em> pleinement disponibles dans sf.
</p>
</div>
<p><strong>sf</strong> peut représenter tous les types de géométrie vectorielle courants (les classes de données raster ne sont pas prises en charge par <strong>sf</strong>) : points, lignes, polygones et leurs versions “multi” respectives (qui regroupent les caractéristiques du même type en une seule caractéristique).
<strong>sf</strong> prend également en charge les collections de géométrie, qui peuvent contenir plusieurs types de géométrie dans un seul objet.
<strong>sf</strong> fournit la même fonctionnalité (et plus) que celle fournie précédemment dans trois packages — <strong>sp</strong> pour les classes de données <span class="citation">(<a href="raster-vector.html#ref-R-sp" role="doc-biblioref">Pebesma and Bivand 2018</a>)</span>, <strong>rgdal</strong> pour la lecture/écriture de données via une interface avec GDAL et PROJ <span class="citation">(<a href="raster-vector.html#ref-R-rgdal" role="doc-biblioref">Bivand, Keitt, and Rowlingson 2018</a>)</span> et <strong>rgeos</strong> pour les opérations spatiales via une interface avec GEOS <span class="citation">(<a href="raster-vector.html#ref-R-rgeos" role="doc-biblioref">Bivand and Rundel 2018</a>)</span>.</p>
<p>Comme expliqué au chapitre 1, les paquets géographiques de R ont une longue histoire d’interfaçage avec des bibliothèques de niveau inférieur, et <strong>sf</strong> poursuit cette tradition avec une interface unifiée vers les versions récentes de GEOS pour les opérations de géométrie, la bibliothèque GDAL pour la lecture et l’écriture de fichiers de données géographiques, et la bibliothèque PROJ pour la représentation et la transformation des systèmes de référence de coordonnées projetées.
Grâce à <strong>s2</strong>,
<!-- **s2** functions have replaced **lwgeom** ones (Bivand 2021). -->
<!-- and **lwgeom**, **sf** also has an inter to PostGIS's [`liblwgeom`](https://github.com/postgis/postgis/tree/master/liblwgeom) library  -->
“une interface avec la bibliothèque de géométrie sphérique de Google [<code>s2</code>] (<a href="https://s2geometry.io/" class="uri">https://s2geometry.io/</a>), <strong>sf</strong> a également accès à des”mesures et opérations sur des géométries non planes” rapides et précises” <span class="citation">(<a href="raster-vector.html#ref-bivand_progress_2021" role="doc-biblioref">Bivand 2021</a>)</span>.
Depuis la version 1.0.0 de <strong>sf</strong>, lancée en <a href="https://cran.r-project.org/src/contrib/Archive/sf/">juin 2021</a>, la fonctionnalité <strong>s2</strong> est maintenant utilisée par <a href="https://r-spatial.org/r/2020/06/17/s2.html">défaut</a> sur les géométries avec des systèmes de coordonnées géographiques (longitude/latitude), une caractéristique unique de <strong>sf</strong> qui diffère des bibliothèques spatiales ne prenant en charge que GEOS pour les opérations de géométrie, comme le paquet Python <a href="geopandas/geopandas/issues/2098">GeoPandas</a>.
Nous aborderons <strong>s2</strong> dans les chapitres suivants.
<!-- Todo: link to them, e.g. (RL 2021-11) -->
<!-- See sections \@ref(s2) and \@ref(buffers) for further details. --></p>
<p>La capacité de <strong>sf</strong> à intégrer plusieurs bibliothèques puissantes pour la géoinformatique dans un seul cadre est une réalisation remarquable qui réduit le “coût d’entrée” dans le monde de l’analyse reproductible des données géographiques avec des bibliothèques performantes.
La fonctionnalité de <strong>sf</strong> est bien documentée sur son site web à l’adresse [r-spatial.github.io/sf/] (<a href="https://r-spatial.github.io/sf/index.html" class="uri">https://r-spatial.github.io/sf/index.html</a>) contient 7 vignettes.
Celles-ci peuvent être visualisées hors ligne comme suit :</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/vignette.html">vignette</a></span><span class="op">(</span>package <span class="op">=</span> <span class="st">"sf"</span><span class="op">)</span> <span class="co"># Qu'elles sont les vignettes disponibles</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/vignette.html">vignette</a></span><span class="op">(</span><span class="st">"sf1"</span><span class="op">)</span>          <span class="co"># Une introduction à la bibliothèque </span></span></code></pre></div>
<p>Comme l’explique la première vignette, les objets de type <em>simples features</em> dans R sont stockés dans un tableau de données, les données géographiques occupant une colonne spéciale, généralement nommée “geom” ou “geometry”.
Nous allons utiliser le jeu de données <code>world</code> fourni par la bibliothèque <strong>spData</strong>, chargé au début de ce chapitre, pour montrer ce que sont les objets <code>sf</code> et comment ils fonctionnent.
<code>world</code> est un “tableau de données <code>sf</code>” contenant des colonnes spatiales et attributaires, dont les noms sont retournés par la fonction <code><a href="https://rdrr.io/r/base/names.html">names()</a></code> (la dernière colonne dans cet exemple contient les informations géographiques) :</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">world</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "sf"         "tbl_df"     "tbl"        "data.frame"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">world</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "iso_a2"    "name_long" "continent" "region_un" "subregion" "type"     </span></span>
<span><span class="co">#&gt;  [7] "area_km2"  "pop"       "lifeExp"   "gdpPercap" "geom"</span></span></code></pre></div>
<p>Le contenu de cette colonne <code>geom</code> donne aux objets <code>sf</code> leurs propriétés spatiales : <code>world$geom</code> est une ‘<a href="https://adv-r.hadley.nz/vectors-chap.html#list-columns">colonne de type liste</a>’ qui contient toutes les coordonnées des polygones du pays.
Les objets <code>sf</code> peuvent être tracés rapidement avec la fonction de base de R, <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> ;
la commande suivante crée la figure <a href="spatial-class.html#fig:world-all">2.3</a>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">world</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:world-all"></span>
<img src="02-spatial-data_files/figure-html/world-all-1.png" alt="Cartes du monde utilisant le paquet sf, avec une dimension pour chaque attribut." width="100%"><p class="caption">
FIGURE 2.3: Cartes du monde utilisant le paquet sf, avec une dimension pour chaque attribut.
</p>
</div>
<p>Notez qu’au lieu de créer une seule carte par défaut pour les objets géographiques, comme le font la plupart des programmes SIG, la fonction <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> sur des objets <code>sf</code> retourne une carte pour chaque variable du jeux de données.
Ce comportement peut être utile pour explorer la distribution spatiale de différentes variables et est abordé plus en détail dans la section <a href="spatial-class.html#basic-map">2.2.3</a>.</p>
<p>Plus largement, traiter les objets géographiques comme des tableaux de données classiques avec des propriétés spatiales présente de nombreux avantages, surtout si vous avez déjà l’habitude de travailler avec des tableaux de données.
Par exemple, la fonction très pratique <code><a href="https://rdrr.io/pkg/terra/man/summary.html">summary()</a></code>, fournit un aperçu utile des variables de l’objet <code>world</code>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/summary.html">summary</a></span><span class="op">(</span><span class="va">world</span><span class="op">[</span><span class="st">"lifeExp"</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;     lifeExp                geom    </span></span>
<span><span class="co">#&gt;  Min.   :50.6   MULTIPOLYGON :177  </span></span>
<span><span class="co">#&gt;  1st Qu.:65.0   epsg:4326    :  0  </span></span>
<span><span class="co">#&gt;  Median :72.9   +proj=long...:  0  </span></span>
<span><span class="co">#&gt;  Mean   :70.9                      </span></span>
<span><span class="co">#&gt;  3rd Qu.:76.8                      </span></span>
<span><span class="co">#&gt;  Max.   :83.6                      </span></span>
<span><span class="co">#&gt;  NA's   :10</span></span></code></pre></div>
<p>Bien que nous n’ayons sélectionné qu’une seule variable pour la commande <code><a href="https://rdrr.io/pkg/terra/man/summary.html">summary()</a></code>, elle produit également un rapport sur la géométrie.
Cela démontre le comportement “permanent” des colonnes de type géométrie des objets <strong>sf</strong>, cela signifie que la géométrie est conservée à moins que l’utilisateur ne la supprime délibérément, comme nous le verrons dans la Section <a href="#vector-attribute-manipulation"><strong>??</strong></a>.
Le résultat fournit un résumé rapide des données spatiales et non spatiales contenues dans <code>world</code> : l’espérance de vie moyenne est de 71 ans (allant de moins de 51 ans à plus de 83 ans avec une médiane de 73 ans) pour tous les pays.</p>

<div class="rmdnote">
Le mot <code>MULTIPOLYGON</code> dans le résumé ci-dessus fait référence au type de géométrie des éléments (pays) dans l´objet <code>world</code>.
Cette représentation est nécessaire pour les pays comportant des îles comme l´Indonésie et la Grèce.
Les autres types de géométrie sont décrits dans la section <a href="spatial-class.html#geometry">2.2.4</a>.
</div>
<p>Il est important d’examiner de plus près le comportement de base et le contenu de cet objet <em>simple feature</em>, que l’on peut utilement considérer comme un “<strong>s</strong>patial data <strong>f</strong>rames”.</p>
<p>Les objets <code>sf</code> sont faciles à extraire: le code ci-dessous extrait ses deux premières lignes et trois premières colonnes de <code>world</code>.
La sortie montre deux différences majeures par rapport à un <code>data.frame</code> standard : l’inclusion de données géographiques supplémentaires (<code>geometry type</code>, <code>dimension</code>, <code>bbox</code> et les informatio<code>ns SCR -</code>epsg (SRID)<code>,</code>proj4string<code>) ainsi que la présence d'une colonne</code>geometry<code>, ici nommée</code>geom` :</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">world_mini</span> <span class="op">=</span> <span class="va">world</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span></span>
<span><span class="va">world_mini</span></span>
<span><span class="co">#&gt; Simple feature collection with 2 features and 3 fields</span></span>
<span><span class="co">#&gt; Geometry type: MULTIPOLYGON</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95</span></span>
<span><span class="co">#&gt; Geodetic CRS:  WGS 84</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 4</span></span>
<span><span class="co">#&gt;   iso_a2 name_long continent                                                geom</span></span>
<span><span class="co">#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;                                      &lt;MULTIPOLYGON [°]&gt;</span></span>
<span><span class="co">#&gt; 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…</span></span>
<span><span class="co">#&gt; 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…</span></span></code></pre></div>
<p>Tout cela peut sembler assez complexe, surtout pour un système de classes qui est censé être simple.
Cependant, il y a de bonnes raisons d’organiser les choses de cette façon et d’utiliser <strong>sf</strong>.</p>
<p>Avant de décrire chaque type de géométrie géré par le paquet <strong>sf</strong>, il est utile de prendre un peu de recul pour comprendre les éléments constitutifs des objets de type <code>sf</code>.
La section <a href="spatial-class.html#sf">2.2.5</a> montre comment les objets <em>simples features</em> sont des tableau de données, avec des colonnes géométriques spéciales.
Ces colonnes spatiales sont souvent appelées <code>geom</code> ou <code>geometry</code> : ainsi <code>world$geom</code> fait référence à l’élément spatial de l’objet <code>world</code> décrit plus haut.
Ces colonnes géométriques sont des “colonnes de type liste” de la classe <code>sfc</code> (voir la section <a href="spatial-class.html#sfc">2.2.7</a>).
Puis, à leur tour, les objets <code>sfc</code> sont composés d’un ou plusieurs objets de la classe <code>sfg</code> : des géométries d’entités simples que nous décriverons dans la section <a href="spatial-class.html#sfg">2.2.6</a>.
</p>
<p>Pour comprendre comment fonctionnent les composantes spatiales des entités simples, il est essentiel de comprendre comment leurs géométries sont prises en comptes.
C’est pourquoi nous couvrirons chacun des types de géométrie d’entités simples actuellement pris en charge dans la section <a href="spatial-class.html#geometry">2.2.4</a> puis nous continuerons en montrant comment ils peuvent être représentés dans R avec des objets <code>sf</code>, formés à la base d’objets <code>sfg</code> et <code>sfc</code>.</p>
<pre class="bloc2"><code>Le morceau de code précédent utilise `=` pour créer un nouvel objet appelé `world_mini` dans la commande `world_mini = world[1:2, 1:3]`.
C´est ce qu´on appelle une affectation.
Une commande équivalente pour obtenir le même résultat est `world_mini &lt;- world[1:2, 1:3]`.
Bien que l´affectation par flèche soit plus couramment utilisée, nous utilisons l´affectation par égalité parce qu´elle est légèrement plus rapide à taper et plus facile à enseigner en raison de sa compatibilité avec les langages couramment utilisés tels que Python et JavaScript.
L´utilisation de l´un ou l´autre est une question de préférence, tant que vous êtes cohérent (des paquets tels que **styler** peuvent être utilisés pour changer de style).</code></pre>
</div>
<div id="pourquoi-simple-features" class="section level3" number="2.2.2">
<h3>
<span class="header-section-number">2.2.2</span> Pourquoi <em>simple features</em>?<a class="anchor" aria-label="anchor" href="#pourquoi-simple-features"><i class="fas fa-link"></i></a>
</h3>
<p>Les <em>simple features</em> ou entités simples sont un modèle de données largement utilisé qui sous-tend les structures de données de nombreuses applications SIG, notamment QGIS et PostGIS.
L’un des principaux avantages de cette approche est que l’utilisation du modèle de données garantit que votre travail est transférable à d’autres configurations, par exemple l’importation et l’exportation vers des bases de données spatiales.
</p>
<p>Une question plus spécifique du point de vue de R est “pourquoi utiliser le paquet <strong>sf</strong> alors que <strong>sp</strong> est déjà éprouvé” ?
Il existe de nombreuses raisons (liées notamment aux avantages du modèle des entités simples) :</p>
<ul>
<li>lecture et écriture rapides des données ;</li>
<li>amélioration des performances de représentation graphique ;</li>
<li>les objets <strong>sf</strong> peuvent être traités comme des tableaux de données dans la plupart des opérations ;</li>
<li>les noms des fonctions <strong>sf</strong> sont relativement cohérents et intuitifs (tous commencent par <code>st_</code>) ;</li>
<li>les fonctions <strong>sf</strong> peuvent être combinées à l’aide de l’opérateur <code>|&gt;</code> et fonctionnent bien avec la collection <a href="http://tidyverse.org/">tidyverse</a> des paquets R.</li>
</ul>
<p>L’intégration de <strong>sf</strong> pour les paquets <strong>tidyverse</strong> est illustrée avec la fonction de lecture des données géographiques vectorisées: <code><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf()</a></code>.
Au contraire de la fonction <code><a href="https://r-spatial.github.io/sf/reference/st_read.html">st_read()</a></code> qui va retourner les attributs dans les classes de base R <code>data.frame</code> (et affiche un message de compte rendu plus complet qui dans l’extrait de code ci dessous a été omis) la fonction <code><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf()</a></code> va retourner un <strong>tidyverse</strong> <code>tibble</code>.
Vous en trouvez la démonstration ci-dessous (voir la section <a href="#iovec"><strong>??</strong></a> sur la lecture et l’écriture des données géographiques vectorielles avec R) :</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">world_dfr</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">st_read</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"shapes/world.shp"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Reading layer `world' from data source </span></span>
<span><span class="co">#&gt;   `/usr/local/lib/R/site-library/spData/shapes/world.shp' using driver `ESRI Shapefile'</span></span>
<span><span class="co">#&gt; Simple feature collection with 177 features and 10 fields</span></span>
<span><span class="co">#&gt; Geometry type: MULTIPOLYGON</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.6</span></span>
<span><span class="co">#&gt; Geodetic CRS:  WGS 84</span></span>
<span><span class="va">world_tbl</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"shapes/world.shp"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">world_dfr</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "sf"         "data.frame"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">world_tbl</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "sf"         "tbl_df"     "tbl"        "data.frame"</span></span></code></pre></div>
<p>Comme illusté dans le Chapitre <a href="attr.html#attr">3</a>, montrant la manipulation d’objets `sf avec le <strong>tidyverse</strong>, <strong>sf</strong> est désormais la bibliothèquee de référence pour l’analyse des données vectorielles spatiales dans R (sans oublier l’écosystème des paquets <strong>spatstat</strong> qui fournit de nombreuses fonctions pour les statistiques spatiales).
De nombreux paquets populaires reposent sur <strong>sf</strong>, comme le montre l’augmentation de sa popularité en termes de nombre de téléchargements par jour, comme indiqué dans la section <a href="intro.html#r-ecosystem">1.4</a> du chapitre précédent.
La transition de paquets et de chaînes de processus reposant sur les anciens paquets <strong>rgeos</strong> et <strong>rgdal</strong> prends du temps <span class="citation">(<a href="raster-vector.html#ref-bivand_progress_2021" role="doc-biblioref">Bivand 2021</a>)</span>, mais le processus a été acceleré par le sentiments d’urgence par les messages indiquant qu’ils “seraient indisponibles à partir de fin 2023”.
Cela signifie que quiconque utilisant encore ces paquets se doit de “<strong>passer aux fonctions de sf/stars/terra pour utiliser GDAL et PROJ le plus rapidement possible.</strong>”.</p>
<p>En d’autres termes, <strong>sf</strong> est à l’épreuve du futur mais <strong>sp</strong> ne l’est pas.
Pour les <em>workflow</em> qui dépendent de l’ancienne classe <code>Spatial</code>, les objets <code>sf</code> peuvent être convertis depuis et vers la classe <code>Spatial</code> du paquet <strong>sp</strong> comme suit :</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/edzer/sp/">sp</a></span><span class="op">)</span></span>
<span><span class="va">world_sp</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/methods/as.html">as</a></span><span class="op">(</span><span class="va">world</span>, <span class="st">"Spatial"</span><span class="op">)</span> <span class="co"># de sf à sp</span></span>
<span><span class="co"># sp functions ...</span></span>
<span><span class="va">world_sf</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span><span class="va">world_sp</span><span class="op">)</span>           <span class="co"># de sp à sf</span></span></code></pre></div>
</div>
<div id="basic-map" class="section level3" number="2.2.3">
<h3>
<span class="header-section-number">2.2.3</span> Réalisation rapide de cartes<a class="anchor" aria-label="anchor" href="#basic-map"><i class="fas fa-link"></i></a>
</h3>
<p>Des premiers jets de cartes peuvent être crées dans <strong>sf</strong> avec <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code>.
Par défaut, cela crée un graphique avec de multiple encarts, un encart pour chaque variable de l’objet, comme illustré dans le panneau de gauche de la Figure <a href="spatial-class.html#fig:sfplot">2.4</a>.
Une légende ou “clé” avec une couleur continue est produite si l’objet à tracer a une seule variable (voir l’encart de droite).
Les couleurs peuvent également être définies avec l’argument <code>col =</code>, bien que cela ne permette pas de créer une palette continue ou une légende.
</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">world</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">world</span><span class="op">[</span><span class="st">"pop"</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:sfplot"></span>
<img src="02-spatial-data_files/figure-html/sfplot-1.png" alt="Cartographie avec sf, avec plusieurs variables (gauche) ou une seule (droite)." width="49%"><img src="02-spatial-data_files/figure-html/sfplot-2.png" alt="Cartographie avec sf, avec plusieurs variables (gauche) ou une seule (droite)." width="49%"><p class="caption">
FIGURE 2.4: Cartographie avec sf, avec plusieurs variables (gauche) ou une seule (droite).
</p>
</div>
<p>Les graphiques sont ajoutés en tant que couches aux images existantes en ajoutant dans la fonction l’argument <code>add = TRUE</code>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
L’appel de la fonction &lt;code&gt;plot()&lt;/code&gt; sur un objet &lt;strong&gt;sf&lt;/strong&gt; va en réalité appeler &lt;code&gt;sf::::plot.sf()&lt;/code&gt;.
La fonction &lt;code&gt;plot()&lt;/code&gt; est une méthode générique qui se comporte différemment selon la classe de l’objet en entrée.&lt;/p&gt;"><sup>10</sup></a>
Pour illustrer cela et donner un avant-goût du contenu des chapitres <a href="attr.html#attr">3</a> et <a href="spatial-operations.html#spatial-operations">4</a> sur les attributs et les opérations sur les données spatiales, l’extrait de code suivant filtre et combine des pays d’Asie en un seul élément :</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">world_asia</span> <span class="op">=</span> <span class="va">world</span><span class="op">[</span><span class="va">world</span><span class="op">$</span><span class="va">continent</span> <span class="op">==</span> <span class="st">"Asia"</span>, <span class="op">]</span></span>
<span><span class="va">asia</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_combine.html">st_union</a></span><span class="op">(</span><span class="va">world_asia</span><span class="op">)</span></span></code></pre></div>
<p>Ainsi, nous pouvons maintenant dessiner le continent asiatique sur une carte du monde.
Notez que le premier graphique ne doit avoir qu’un seul encart pour que <code>add = TRUE</code> fonctionne.
Si le premier graphique a une légende, <code>reset = FALSE</code> doit être utilisé (résultat non montré) :</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">world</span><span class="op">[</span><span class="st">"pop"</span><span class="op">]</span>, reset <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">asia</span>, add <span class="op">=</span> <span class="cn">TRUE</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span></code></pre></div>
<p>L’ajout de couches de cette manière peut être utilisé pour vérifier la correspondance géographique entre les couches :
la fonction <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> est rapide à exécuter et nécessite peu de lignes de code, mais ne permet pas de créer des cartes interactives avec une large gamme d’options.
Pour la réalisation de cartes plus poussées, nous recommandons l’utilisation de paquets de visualisation spécifiques tels que <strong>tmap</strong> (voir le chapitre <a href="#adv-map"><strong>??</strong></a>).</p>
<p>Il y a plusieurs façons de modifier les cartes avec la méthode <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> de <strong>sf</strong>.
Comme <strong>sf</strong> étend les méthodes de base de R, les arguments de <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> tels que <code>main =</code> (qui spécifie le titre de la carte) fonctionnent avec les objets <code>sf</code> (voir <code><a href="https://rdrr.io/r/graphics/plot.default.html">?graphics::plot</a></code> et <code><a href="https://rdrr.io/r/graphics/par.html">?par</a></code>).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Remarque : de nombreux arguments de &lt;code&gt;plot()&lt;/code&gt; sont ignorés dans les cartes à facettes, lorsque plus d’une colonne &lt;code&gt;sf&lt;/code&gt; est utilisée.&lt;/p&gt;"><sup>11</sup></a>
</p>
<p>La figure <a href="spatial-class.html#fig:contpop">2.5</a> illustre cette flexibilité en superposant sur une carte du monde des cercles dont les diamètres (définis avec l’argument <code>cex =</code>) représentent les populations des pays.
Une version non projetée de cette figure peut être créée avec les commandes suivantes (voir les exercices à la fin de ce chapitre et le script <a href="https://github.com/Robinlovelace/geocompr/blob/main/code/02-contpop.R"><code>02-contplot.R</code></a> <a href="spatial-class.html#fig:contpop">2.5</a>):</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">world</span><span class="op">[</span><span class="st">"continent"</span><span class="op">]</span>, reset <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">cex</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">world</span><span class="op">$</span><span class="va">pop</span><span class="op">)</span> <span class="op">/</span> <span class="fl">10000</span></span>
<span><span class="va">world_cents</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">world</span>, of_largest <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_geometry</a></span><span class="op">(</span><span class="va">world_cents</span><span class="op">)</span>, add <span class="op">=</span> <span class="cn">TRUE</span>, cex <span class="op">=</span> <span class="va">cex</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:contpop"></span>
<img src="02-spatial-data_files/figure-html/contpop-1.png" alt="Pays coloriés par continent et leur population en 2015 (cercles proportionnels à la population)." width="100%"><p class="caption">
FIGURE 2.5: Pays coloriés par continent et leur population en 2015 (cercles proportionnels à la population).
</p>
</div>
<p>Le code ci-dessus utilise la fonction <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code> pour convertir un type de géométrie (polygones) en un autre (points) (voir chapitre <a href="geometric-operations.html#geometric-operations">5</a>), dont la représentation varie en fonction de l’argument <code>cex</code>.</p>
<p>
La méthode plot de <strong>sf</strong> possède également des arguments spécifiques aux données géographiques. <code>expandBB</code>, par exemple, peut être utilisé pour dessiner un objet <code>sf</code> dans son contexte :
elle prend un vecteur de quatre nombres qui étend la boîte de délimitation de la carte par rapport à zéro en suivant l’ordre : bas, gauche, haut, droite.
Dans le programme suivant, ce paramètre est utilisé pour représenter l’Inde et ses gigantesques voisins asiatiques, en mettant l’accent sur la Chine à l’est <a href="spatial-class.html#fig:china">2.6</a> (voir les ci-dessous sur l’ajout de texte aux graphiques):<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Remarquez l’utilisation de &lt;code&gt;st_geometry(india)&lt;/code&gt; pour renvoyer uniquement la géométrie associée à l’objet et empêcher tous ses attributs d’être tracés comme éléments simple de colonne (&lt;em&gt;simple feature column&lt;/em&gt;, &lt;code&gt;sfc&lt;/code&gt;).
Une alternative consiste à utiliser &lt;code&gt;india[0]&lt;/code&gt;, qui renvoie un objet &lt;code&gt;sf&lt;/code&gt; qui ne contient aucune donnée attributaire.&lt;/p&gt;"><sup>12</sup></a></p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">india</span> <span class="op">=</span> <span class="va">world</span><span class="op">[</span><span class="va">world</span><span class="op">$</span><span class="va">name_long</span> <span class="op">==</span> <span class="st">"India"</span>, <span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_geometry</a></span><span class="op">(</span><span class="va">india</span><span class="op">)</span>, expandBB <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0.2</span>, <span class="fl">0.1</span>, <span class="fl">1</span><span class="op">)</span>, col <span class="op">=</span> <span class="st">"gray"</span>, lwd <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">world_asia</span><span class="op">[</span><span class="fl">0</span><span class="op">]</span>, add <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:china"></span>
<img src="02-spatial-data_files/figure-html/china-1.png" alt="L'Inde et ses pays voisins, exemple d'utilisation du paramètre expandBB." width="50%"><p class="caption">
FIGURE 2.6: L’Inde et ses pays voisins, exemple d’utilisation du paramètre expandBB.
</p>
</div>
<p>Notez l’utilisation de <code>lwd</code>dans le code afin de renforcer l’Inde.
La section <a href="#other-mapping-packages"><strong>??</strong></a> vous équipera d’autres techniques de visualisation pour représenter une gamme de types de géométrie.</p>
</div>
<div id="geometry" class="section level3" number="2.2.4">
<h3>
<span class="header-section-number">2.2.4</span> Les types de géométries<a class="anchor" aria-label="anchor" href="#geometry"><i class="fas fa-link"></i></a>
</h3>
<p>Les géométries sont les éléments de base des éntités simples.
Ces derniers peuvent prendre dans R l’un des 18 types de géométrie pris en charge par le paquet <strong>sf</strong>.
Dans ce chapitre, nous nous concentrerons sur les sept types les plus couramment utilisés : <code>POINT</code>, <code>LINESTRING</code>, <code>POLYGON</code>, <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code> et <code>GEOMETRYCOLLECTION</code>.
La liste complète des types d’éléments possibles est disponible dans <a href="http://postgis.net/docs/using_postgis_dbmanagement.html">le manuel de PostGIS</a>.</p>
<p>En général, le <em>well-known binary</em> (WKB) ou le <em>well-known text</em> (WKT) sont les codages standard pour les géométries simples.
Les WKB sont généralement représentés par des chaînes hexadécimales facilement lisibles par les ordinateurs.
C’est pourquoi les SIG et les bases de données spatiales l’utilisent pour transférer et stocker des objets géométriques.
Le WKT, quant à lui, est une description de balisage textuel lisible par l’homme pour des éntités simples.
Les deux formats sont échangeables, et si nous en présentons un, nous choisirons naturellement la représentation WKT.</p>
<p>La base de chaque type de géométrie est le point.
Un point est simplement une coordonnée dans un espace 2D, 3D ou 4D (cf. <code><a href="https://r-spatial.github.io/sf/articles/sf1.html">vignette("sf1")</a></code> pour plus d’informations). Un exemple est disponible sur le second panneau de la figure <a href="spatial-class.html#fig:sfcs">2.7</a>:
</p>
<ul>
<li><code>POINT (5 2)</code></li>
</ul>
<p>
Une <em>linestring</em>, ligne, est une séquence de points avec une ligne droite reliant ces points, par exemple (cf. le panneau central de la figure <a href="spatial-class.html#fig:sfcs">2.7</a>) :</p>
<ul>
<li><code>LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</code></li>
</ul>
<p>Un polygone est une séquence de points qui forment un anneau fermé, sans intersection.
Fermé signifie que le premier et le dernier point d’un polygone ont les mêmes coordonnées (cf. le panneau de droite de la figure <a href="spatial-class.html#fig:sfcs">2.7</a>).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Par définition, un polygone a une limite extérieure (anneau extérieur) et peut avoir zéro ou plusieurs limites intérieures (anneaux intérieurs), également appelées “trous”.
Un polygone avec un trou serait, par exemple, &lt;code&gt;POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))&lt;/code&gt;.&lt;/p&gt;"><sup>13</sup></a>
</p>
<ul>
<li>Polygone sans anneau intérieur: <code>POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</code>
</li>
</ul>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:sfcs"></span>
<img src="02-spatial-data_files/figure-html/sfcs-1.png" alt="Exemple de géometries de point, ligne et polygone." width="100%"><p class="caption">
FIGURE 2.7: Exemple de géometries de point, ligne et polygone.
</p>
</div>
<p>Jusqu’à présent, nous avons créé des géométries avec une seule entité géométrique par élément.
Toutefois, <strong>sf</strong> permet également l’existence de plusieurs géométries au sein d’une même entité (d’où le terme “collection de géométries”) en utilisant la version “multi” de chaque type de géométrie :
</p>
<ul>
<li>Multipoint: <code>MULTIPOINT (5 2, 1 3, 3 4, 3 2)</code>
</li>
<li>Multilinestring: <code>MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</code>
</li>
<li>Multipolygon: <code>MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))</code>
</li>
</ul>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:multis"></span>
<img src="02-spatial-data_files/figure-html/multis-1.png" alt="Examples de multi* geometries." width="100%"><p class="caption">
FIGURE 2.8: Examples de multi* geometries.
</p>
</div>
<p>Enfin, une collection de géométries peut contenir n’importe quelle combinaison de géométries, y compris des (multi)points et des lignes (voir figure <a href="spatial-class.html#fig:geomcollection">2.9</a>) :
</p>
<ul>
<li>Geometry collection: <code>GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))</code>
</li>
</ul>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:geomcollection"></span>
<img src="02-spatial-data_files/figure-html/geomcollection-1.png" alt="Exemple de collection de géometrie." width="33%"><p class="caption">
FIGURE 2.9: Exemple de collection de géometrie.
</p>
</div>
</div>
<div id="sf" class="section level3" number="2.2.5">
<h3>
<span class="header-section-number">2.2.5</span> La classe sf<a class="anchor" aria-label="anchor" href="#sf"><i class="fas fa-link"></i></a>
</h3>
<p>Les <em>Simple features</em> ou entités simples sont composés de deux parties principales : les géométries et les attributs non géographiques.
La figure <a href="spatial-class.html#fig:02-sfdiagram">2.10</a> montre comment un objet sf est créé – les géométries proviennent d’un objet <code>sfc</code>, tandis que les attributs sont pris dans un <code>data.frame</code> ou un <code>tibble</code>.
Les sections <a href="spatial-class.html#sfg">2.2.6</a> et <a href="spatial-class.html#sfc">2.2.7</a> reprennent la création de géometries sf à partir de rien.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:02-sfdiagram"></span>
<img src="figures/02-sfdiagram.png" alt="Différentes étapes de construction des objets sf." width="100%"><p class="caption">
FIGURE 2.10: Différentes étapes de construction des objets sf.
</p>
</div>
<p>Les attributs non géographiques permettent la représentation du nom de l’entité ou d’autres attributs, mesures, appartenance à des groupes et autres.
Pour l’illustrer nous allons représenter une température de 25°C à Londres le 21 juin 2017.
Cet exemple à une géométrie (les coordonnées) et trois attributs de trois classes différentes (le nom, la température et la date).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
D’autres attributs pourraient être des types de villes (grandes, moyennes), ou une remarque indiquant si la mesure est produite par une station automatique.&lt;/p&gt;"><sup>14</sup></a>
Les objets de la classe <code>sf</code> représentent de telles données en combinant les attributs (<code>data.frame</code>) avec la colonne de géométrie <em>simple feature</em> (<code>sfc</code>).
Ils sont créés avec <code><a href="https://r-spatial.github.io/sf/reference/sf.html">st_sf()</a></code>, comme l’illustre le code ci-dessous, créant l’exemple londonien :</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lnd_point</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">51.5</span><span class="op">)</span><span class="op">)</span>                 <span class="co"># objet sfg</span></span>
<span><span class="va">lnd_geom</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">lnd_point</span>, crs <span class="op">=</span> <span class="fl">4326</span><span class="op">)</span>           <span class="co"># objet sfc</span></span>
<span><span class="va">lnd_attrib</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>                           <span class="co"># objet data.frame</span></span>
<span>  name <span class="op">=</span> <span class="st">"London"</span>,</span>
<span>  temperature <span class="op">=</span> <span class="fl">25</span>,</span>
<span>  date <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.Date.html">as.Date</a></span><span class="op">(</span><span class="st">"2017-06-21"</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span><span class="va">lnd_sf</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sf.html">st_sf</a></span><span class="op">(</span><span class="va">lnd_attrib</span>, geometry <span class="op">=</span> <span class="va">lnd_geom</span><span class="op">)</span>    <span class="co"># objet sf</span></span></code></pre></div>
<p>Que s’est-il passé ? Premièrement, les coordonnés ont été utilisées pour créer la <em>simple feature geometry</em> (<code>sfg</code>).
Deuxièmement, la géométrie a été convertie en une colonne de type <em>simple feature</em> (<code>sfc</code>), avec un SCR.
Troisièmement, les attributs ont été stockés dans un <code>data.frame</code>, qui a été combiné avec l’objet <code>sfc</code> avec <code><a href="https://r-spatial.github.io/sf/reference/sf.html">st_sf()</a></code>.
Le résultat est un objet <code>sf</code>, comme montré ci-dessous (une partie de la sortie de code est omise) :</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lnd_sf</span></span>
<span><span class="co">#&gt; Simple feature collection with 1 features and 3 fields</span></span>
<span><span class="co">#&gt; ...</span></span>
<span><span class="co">#&gt;     name temperature       date         geometry</span></span>
<span><span class="co">#&gt; 1 London          25 2017-06-21 POINT (0.1 51.5)</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">lnd_sf</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "sf"         "data.frame"</span></span></code></pre></div>
<p>Le résultat montre que les objets <code>sf</code> ont en fait deux classes informatiques, <code>sf</code> et <code>data.frame</code>.
Les entités simples sont simplement des tableaux de données mais avec un attribut spatial stocké dans une colonne de type liste, souvent nommée <code>geometry</code>, comme décrit dans la section <a href="#intro-sf"><strong>??</strong></a>.
Cette dualité est au coeur du concept d’éntités simple:
la plupart du temps un objet <code>sf</code> peut être traité comme un <code>data.frame</code> et se comporté comme tel.
Les entités simples sont, par essence, des tableaux de données avec une extension spatiale.</p>
</div>
<div id="sfg" class="section level3" number="2.2.6">
<h3>
<span class="header-section-number">2.2.6</span> Simple feature geometries (sfg)<a class="anchor" aria-label="anchor" href="#sfg"><i class="fas fa-link"></i></a>
</h3>
<p>La classe <code>sfg</code> représente les différents types de géométrie des éntités simples dans R : point, ligne, polygone (et leurs équivalents “multi”, comme les multipoints) ou collection de géométries.
</p>
<p>En général, la tâche fastidieuse de création de géométries vous est épargnée car vous pouvez simplement importer un fichier spatial déjà existant.
Cependant, il existe un ensemble de fonctions permettant de créer des objets géométriques <em>simple feature</em> (<code>sfg</code>) à partir de zéro si nécessaire.
Les noms de ces fonctions sont simples et cohérents, ils commencent tous par le préfixe <code>st_</code> et se terminent par le nom du type de géométrie en lettres minuscules :</p>
<ul>
<li>Un point : <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_point()</a></code>
</li>
<li>Une ligne : <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_linestring()</a></code>
</li>
<li>Un polygone: <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon()</a></code>
</li>
<li>Un multipoint: <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipoint()</a></code>
</li>
<li>Une multiligne : <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_multilinestring()</a></code>
</li>
<li>Un multipolygone : <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipolygon()</a></code>
</li>
<li>Une collection de géométries : <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_geometrycollection()</a></code>
</li>
</ul>
<p>Les objets <code>sfg</code> peuvent être créés à partir de trois de types de données de R:</p>
<ol style="list-style-type: decimal">
<li>Un vecteur numérique: un point unique<br>
</li>
<li>Un matrice: un ensemble de points, où chaque ligne représente un point, un multipoint ou une ligne</li>
<li>Une liste: une collection d’objets comme des matrices, des multilignes ou des collections de géométries.</li>
</ol>
<p>La fonction <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_point()</a></code> crée un point à partir de vecteurs numériques :</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span>                 <span class="co"># point en XY</span></span>
<span><span class="co">#&gt; POINT (5 2)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>              <span class="co"># point en XYZ</span></span>
<span><span class="co">#&gt; POINT Z (5 2 3)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span>, dim <span class="op">=</span> <span class="st">"XYM"</span><span class="op">)</span> <span class="co"># point en XYM</span></span>
<span><span class="co">#&gt; POINT M (5 2 1)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span>           <span class="co"># point en XYZM</span></span>
<span><span class="co">#&gt; POINT ZM (5 2 3 1)</span></span></code></pre></div>
<p>Les sorties montrent que les types de points XY (coordonnées 2D), XYZ (coordonnées 3D) et XYZM (3D avec une variable supplémentaire, généralement la précision de mesure) sont créés à partir de vecteurs de longueur 2, 3 et 4, respectivement.
Le type XYM doit être spécifié en utilisant l’argument <code>dim</code> (qui est l’abréviation de dimension).</p>
<p>En revanche, vous devez utiliser des matrices dans le cas des objets multipoints (<code><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipoint()</a></code>) et ligne (<code><a href="https://r-spatial.github.io/sf/reference/st.html">st_linestring()</a></code>) :</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># la fonction rbind simplifie la création de matrices</span></span>
<span><span class="co">## MULTIPOINT</span></span>
<span><span class="va">multipoint_matrix</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipoint</a></span><span class="op">(</span><span class="va">multipoint_matrix</span><span class="op">)</span></span>
<span><span class="co">#&gt; MULTIPOINT ((5 2), (1 3), (3 4), (3 2))</span></span>
<span><span class="co">## LIGNE</span></span>
<span><span class="va">linestring_matrix</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_linestring</a></span><span class="op">(</span><span class="va">linestring_matrix</span><span class="op">)</span></span>
<span><span class="co">#&gt; LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</span></span></code></pre></div>
<p>Enfin, vous devez utiliser les listes pour la création de multilignes, de (multi-)polygones et de collections de géométries :</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## POLYGONE</span></span>
<span><span class="va">polygon_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon</a></span><span class="op">(</span><span class="va">polygon_list</span><span class="op">)</span></span>
<span><span class="co">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## POLYGONE avec un trou</span></span>
<span><span class="va">polygon_border</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">polygon_hole</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">polygon_with_hole_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">polygon_border</span>, <span class="va">polygon_hole</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon</a></span><span class="op">(</span><span class="va">polygon_with_hole_list</span><span class="op">)</span></span>
<span><span class="co">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))</span></span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## MULTILIGNE</span></span>
<span><span class="va">multilinestring_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span>, </span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multilinestring</a></span><span class="op">(</span><span class="op">(</span><span class="va">multilinestring_list</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## MULTIPOLYGONE</span></span>
<span><span class="va">multipolygon_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                         <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipolygon</a></span><span class="op">(</span><span class="va">multipolygon_list</span><span class="op">)</span></span>
<span><span class="co">#&gt; MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))</span></span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## COLLECTIONS DE GEOMETRIES</span></span>
<span><span class="va">geometrycollection_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multipoint</a></span><span class="op">(</span><span class="va">multipoint_matrix</span><span class="op">)</span>,</span>
<span>                              <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_linestring</a></span><span class="op">(</span><span class="va">linestring_matrix</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_geometrycollection</a></span><span class="op">(</span><span class="va">geometrycollection_list</span><span class="op">)</span></span>
<span><span class="co">#&gt; GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),</span></span>
<span><span class="co">#&gt;   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))</span></span></code></pre></div>
</div>
<div id="sfc" class="section level3" number="2.2.7">
<h3>
<span class="header-section-number">2.2.7</span> Simple feature columns (sfc)<a class="anchor" aria-label="anchor" href="#sfc"><i class="fas fa-link"></i></a>
</h3>
<p>Un objet <code>sfg</code> ne contient qu’un seul élément géométrique <em>simple feature</em>.
Une colonne de géométrie <em>simple feature</em> (<code>sfc</code>) est une liste d’objets <code>sfg</code>, qui peut en outre contenir des informations sur le système de référence des coordonnées utilisé.
Par exemple, pour combiner deux entités simples en un seul objet avec deux entités, nous pouvons utiliser la fonction <code><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc()</a></code>.
C’est important car <code>sfc</code> va correspondre à la colonne de géométrie dans les tableaux de données <strong>sf</strong> :</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># POINT sfc</span></span>
<span><span class="va">point1</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">point2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">points_sfc</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">point1</span>, <span class="va">point2</span><span class="op">)</span></span>
<span><span class="va">points_sfc</span></span>
<span><span class="co">#&gt; Geometry set for 2 features </span></span>
<span><span class="co">#&gt; Geometry type: POINT</span></span>
<span><span class="co">#&gt; Dimension:     XY</span></span>
<span><span class="co">#&gt; Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3</span></span>
<span><span class="co">#&gt; CRS:           NA</span></span>
<span><span class="co">#&gt; POINT (5 2)</span></span>
<span><span class="co">#&gt; POINT (1 3)</span></span></code></pre></div>
<p>Dans la plupart des cas, un objet <code>sfc</code> contient des objets du même type géométrique.
Par conséquent, lorsque nous convertissons des objets <code>sfg</code> de type polygone en une colonne géométrique <em>simple feature</em>, nous obtenons également un objet <code>sfc</code> de type polygone, ce qui peut être vérifié avec <code><a href="https://r-spatial.github.io/sf/reference/st_geometry_type.html">st_geometry_type()</a></code>.
De même, une colonne géométrique de multilignes donnera un objet <code>sfc</code> de type multiligne :</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># sfc POLYGON</span></span>
<span><span class="va">polygon_list1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">polygon1</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon</a></span><span class="op">(</span><span class="va">polygon_list1</span><span class="op">)</span></span>
<span><span class="va">polygon_list2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">polygon2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon</a></span><span class="op">(</span><span class="va">polygon_list2</span><span class="op">)</span></span>
<span><span class="va">polygon_sfc</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">polygon1</span>, <span class="va">polygon2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry_type.html">st_geometry_type</a></span><span class="op">(</span><span class="va">polygon_sfc</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] POLYGON POLYGON</span></span>
<span><span class="co">#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># sfc MULTILINESTRING</span></span>
<span><span class="va">multilinestring_list1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span>, </span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">multilinestring1</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multilinestring</a></span><span class="op">(</span><span class="op">(</span><span class="va">multilinestring_list1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">multilinestring_list2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">9</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">7</span>, <span class="fl">9</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>, <span class="fl">6</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">7</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">7</span><span class="op">)</span><span class="op">)</span>, </span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">7</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">8</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">multilinestring2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_multilinestring</a></span><span class="op">(</span><span class="op">(</span><span class="va">multilinestring_list2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">multilinestring_sfc</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">multilinestring1</span>, <span class="va">multilinestring2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry_type.html">st_geometry_type</a></span><span class="op">(</span><span class="va">multilinestring_sfc</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] MULTILINESTRING MULTILINESTRING</span></span>
<span><span class="co">#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE</span></span></code></pre></div>
<p>C’est aussi possible de créer un objet <code>sfc</code> à partir d’objets <code>sfg</code> de géométries différentes.</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># GEOMETRIE sfc </span></span>
<span><span class="va">point_multilinestring_sfc</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">point1</span>, <span class="va">multilinestring1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry_type.html">st_geometry_type</a></span><span class="op">(</span><span class="va">point_multilinestring_sfc</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] POINT           MULTILINESTRING</span></span>
<span><span class="co">#&gt; 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE</span></span></code></pre></div>
<p>Comme indiqué précédemment, les objets <code>sfc</code> peuvent également stocker de l’information sur le système de coordonnées et de référence (CRS).
La valeur par défaut est <code>NA</code> (<em>Not Available</em>) et elle peut être vérifiée avec <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code> :</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">points_sfc</span><span class="op">)</span></span>
<span><span class="co">#&gt; Coordinate Reference System: NA</span></span></code></pre></div>
<p>Toutes les géométries des objets <code>sfc</code> doivent avoir le même SCR.
Un SCR peut être spécifié avec l’argument <code>crs</code> de <code><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc()</a></code> (ou <code><a href="https://r-spatial.github.io/sf/reference/sf.html">st_sf()</a></code>), il prend un <strong>identifiant CRS</strong> fourni sous forme de chaîne de texte, comme <code>crs = "EPSG:4326"</code> (voir la section <a href="#crs-in-r"><strong>??</strong></a> pour détails et mieux comprendre ce que cela signifie)</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Paramètrer le SCR avec un identifiant 'EPSG':</span></span>
<span><span class="va">points_sfc_wgs</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/sfc.html">st_sfc</a></span><span class="op">(</span><span class="va">point1</span>, <span class="va">point2</span>, crs <span class="op">=</span> <span class="st">"EPSG:4326"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">points_sfc_wgs</span><span class="op">)</span> <span class="co"># indique le SCR (seulement les 4 premières lignes sont montrées)</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: EPSG:4326 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt; GEOGCRS["WGS 84",</span></span>
<span><span class="co">#&gt; ...</span></span></code></pre></div>
</div>
<div id="le-paquet-sfheaders" class="section level3" number="2.2.8">
<h3>
<span class="header-section-number">2.2.8</span> le paquet sfheaders<a class="anchor" aria-label="anchor" href="#le-paquet-sfheaders"><i class="fas fa-link"></i></a>
</h3>
<p><strong>sfheaders</strong> est un paquet pour R qui accélère la construction, la conversion et la manipulation d’objets <code>sf</code> <span class="citation">(<a href="raster-vector.html#ref-cooley_sfheaders_2020" role="doc-biblioref">Cooley 2020</a>)</span>.
Il se focalise sur la construction rapide d’objets <code>sf</code> à partir de vecteurs, matrices et tableaux de données, sans dépendre de la bibliothèque <strong>sf</strong> ; en exposant son code C++ sous-jacent à travers des fichiers d’en-tête (d’où le nom, <strong>sfheaders</strong>).
Cette approche permet à d’autres de l’étendre en utilisant un code compilé et rapide.
Chaque fonction de base de <strong>sfheaders</strong> a une implémentation C++ correspondante, comme décrit dans <a href="https://dcooley.github.io/sfheaders/articles/Cpp.html">la vignette <code>Cpp</code></a>.
Pour la plupart des gens, les fonctions R seront plus que suffisantes pour bénéficier de la vitesse de calcul du paquet.
<strong>sfheaders</strong> a été développé séparément de <strong>sf</strong>, mais vise à être totalement compatible, en créant des objets <code>sf</code> valides du type décrit dans les sections précédentes.</p>
<p>Les cas le plus simple d’utilisation de <strong>sfheaders</strong> sont présentés dans les morceaux de code ci-dessous avec des exemples de construction d’objets <code>sfg</code>, <code>sfc</code>, et <code>sf</code> :</p>
<ul>
<li>un vecteur converti en <code>sfg_POINT</code>;</li>
<li>une matrice convertie en <code>sfg_LINESTRING</code>;</li>
<li>un tableau de données converti en <code>sfg_POLYGON</code>.</li>
</ul>
<p>Nous allons commencer par créer l’objet <code>sfg</code> le plus simple possible, une seule paire de coordonnées, assignée à un vecteur nommé <code>v</code> :</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">v</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">v_sfg_sfh</span> <span class="op">=</span> <span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sfg_point.html">sfg_point</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">v</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">v_sfg_sfh</span> <span class="co"># affichage sans sf chargé</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    1    1</span></span>
<span><span class="co">#&gt; attr(,"class")</span></span>
<span><span class="co">#&gt; [1] "XY"    "POINT" "sfg" </span></span></code></pre></div>
<p>L’exemple ci-dessus montre comment l’objet <code>sfg</code> <code>v_sfg_sfh</code> est affiché lorsque <strong>sf</strong> n’est pas chargé, démontrant ainsi sa structure sous-jacente.
Lorsque <strong>sf</strong> est chargé (comme c’est le cas ici), le résultat de la commande ci-dessus est indiscernable des objets <code>sf</code> :</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">v_sfg_sf</span> <span class="op">=</span> <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="va">v</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">v_sfg_sf</span><span class="op">)</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">v_sfg_sfh</span><span class="op">)</span></span>
<span><span class="co">#&gt; POINT (1 1)</span></span>
<span><span class="co">#&gt; POINT (1 1)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Les exemples suivants montrent comment <strong>sfheaders</strong> crée des objets <code>sfg</code> à partir de matrices et de tableaux de données :</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># matrices</span></span>
<span><span class="va">m</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">8</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sfg_linestring.html">sfg_linestring</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">m</span><span class="op">)</span></span>
<span><span class="co">#&gt; LINESTRING (1 5, 2 6, 3 7, 4 8)</span></span>
<span><span class="co"># data.frames</span></span>
<span><span class="va">df</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, y <span class="op">=</span> <span class="fl">4</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sfg_polygon.html">sfg_polygon</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">df</span><span class="op">)</span></span>
<span><span class="co">#&gt; POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))</span></span></code></pre></div>
<p>En réutilisant les objets <code>v</code>, <code>m</code>, et <code>df</code>, nous pouvons également construire des colonnes de géométrie <em>simple feature</em> (<code>sfc</code>) comme suit (sorties non montrées) :</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sfc_point.html">sfc_point</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">v</span><span class="op">)</span></span>
<span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sfc_linestring.html">sfc_linestring</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">m</span><span class="op">)</span></span>
<span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sfc_polygon.html">sfc_polygon</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">df</span><span class="op">)</span></span></code></pre></div>
<p>De même, les objets <code>sf</code> sont crées comme suis:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sf_point.html">sf_point</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">v</span><span class="op">)</span></span>
<span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sf_linestring.html">sf_linestring</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">m</span><span class="op">)</span></span>
<span><span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sf_polygon.html">sf_polygon</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">df</span><span class="op">)</span></span></code></pre></div>
<p>Dans chacun de ces exemples, le SCR (système de coordonnées et de référence) n’est pas défini.
Si vous prévoyez d’effectuer des calculs ou des opérations géométriques à l’aide des fonctions <strong>sf</strong>, nous vous recommandons de définir le CRS (voir le chapitre <a href="#reproj-geo-data"><strong>??</strong></a> pour plus de détails) :</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_sf</span> <span class="op">=</span> <span class="fu">sfheaders</span><span class="fu">::</span><span class="fu"><a href="https://dcooley.github.io/sfheaders/reference/sf_polygon.html">sf_polygon</a></span><span class="op">(</span>obj <span class="op">=</span> <span class="va">df</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">df_sf</span><span class="op">)</span> <span class="op">=</span> <span class="st">"EPSG:4326"</span></span></code></pre></div>
<p><strong>sfheaders</strong> est aussi une bonne option pour “déconstruire” et “reconstruire” les objets <code>sf</code>, c’est-à-dire convertir les colonnes géométriques en tableaux de données contenant les coordonnées de chaque sommet (vertex) et les identifiants de chaque éléments géométriques (et d’éventuels géométrie multiples).
Il est rapide et fiable pour “passer” des colonnes géométriques vers différents types, un sujet traité dans le chapitre <a href="geometric-operations.html#geometric-operations">5</a>.
Des tests, dans la <a href="https://dcooley.github.io/sfheaders/articles/examples.html#performance">documentation</a> du paquet et dans le code de test développé pour ce livre, montrent qu’il est beaucoup plus rapide que le paquet <code>sf</code> pour de telles opérations.</p>
</div>
<div id="s2" class="section level3" number="2.2.9">
<h3>
<span class="header-section-number">2.2.9</span> géométrie sphérique avec S2<a class="anchor" aria-label="anchor" href="#s2"><i class="fas fa-link"></i></a>
</h3>
<p>Les moteurs de géométrie sphérique sont basés sur le fait que la terre est ronde alors que les procédures mathématiques simples de géocomputation, telles que le calcul d’une ligne droite entre deux points ou de l’aire délimitée par un polygone, supposent des géométries planes (projetées).
Depuis la version 1.0.0 de <strong>sf</strong>, R prend en charge les opérations de géométrie sphérique “d’emblée”, grâce à son interface avec le moteur de géométrie sphérique S2 de Google, via le paquet l’interfaçant <strong>s2</strong>.
S2 est peut-être mieux connu comme un exemple de système de grille globale discrète (DGGS).
Un autre exemple est l’indice spatial hiérarchique hexagonal global <a href="https://eng.uber.com/h3/">H3</a> <span class="citation">(<a href="raster-vector.html#ref-bondaruk_assessing_2020" role="doc-biblioref">Bondaruk, Roberts, and Robertson 2020</a>)</span>.</p>
<p>Bien que potentiellement utile pour décrire des lieux n’importe où sur la Terre en utilisant des chaînes de caractères telles que <a href="https://developers.google.com/maps/documentation/gaming/concepts_playable_locations">e66ef376f790adf8a5af7fca9e6e422c03c9143f</a>, le principal avantage de l’interface de <strong>sf</strong> avec S2 est l’intégration de fonctions de calculs tels que les calculs de distance, de tampon (buffer) et de surface. Ils sont décrit dans la documentation intégrée de <strong>sf</strong> qui peut être ouverte avec la commande <a href="https://r-spatial.github.io/sf/articles/sf7.html"><code>vignette("sf7")</code></a>.</p>
<p><strong>sf</strong> peut fonctionner sur deux modes par rapport à S2 : activé et désactivé.
Par défaut, le moteur de géométrie S2 est activé, comme on peut le vérifier avec la commande suivante :</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Un exemple des conséquences de la désactivation du moteur de géométrie est montré ci-dessous, en créant des tampons autour de l’objet <code>india</code> créé plus tôt dans le chapitre (notez les avertissements émis lorsque S2 est désactivé)</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">india_buffer_with_s2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">india</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Spherical geometry (s2) switched off</span></span>
<span><span class="va">india_buffer_without_s2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">india</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =</span></span>
<span><span class="co">#&gt; endCapStyle, : st_buffer does not correctly buffer longitude/latitude data</span></span>
<span><span class="co">#&gt; dist is assumed to be in decimal degrees (arc_degrees).</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:s2example"></span>
<img src="02-spatial-data_files/figure-html/s2example-1.png" alt="Exemple des conséquences de la désactivation du moteur géométrique S2. Les deux représentations d'un tampon autour de l'Inde ont été créées avec la même commande, mais l'objet polygone violet a été créé avec S2 activé, ce qui a donné un tampon de 1 m. Le polygone vert clair, plus grand, a été créé avec S2 désactivé, ce qui a donné un tampon inexacte avec des degrés en longitude/latitude." width="100%"><p class="caption">
FIGURE 2.11: Exemple des conséquences de la désactivation du moteur géométrique S2. Les deux représentations d’un tampon autour de l’Inde ont été créées avec la même commande, mais l’objet polygone violet a été créé avec S2 activé, ce qui a donné un tampon de 1 m. Le polygone vert clair, plus grand, a été créé avec S2 désactivé, ce qui a donné un tampon inexacte avec des degrés en longitude/latitude.
</p>
</div>
<p>Dans ce livre, nous supposerons que S2 est activé, sauf indication contraire.
Activez-le à nouveau avec la commande suivante.</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2</a></span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Spherical geometry (s2) switched on</span></span></code></pre></div>

<div class="rmdnote">
Bien que l´utilisation de S2 par <strong>sf</strong> ait du sens dans de nombreux cas, dans certains cas, il y a de bonnes raisons de désactiver S2 pour la durée d´une session R ou même pour un projet entier.
Comme documenté dans la question <a href="https://github.com/r-spatial/sf/issues/1771">1771</a> dans le repo GitHub de <strong>sf</strong>, le comportement par défaut peut faire échouer du code qui fonctionnerait avec S2 désactivé (et avec des versions plus anciennes de <strong>sf</strong>).
Ces cas limites incluent des opérations sur des polygones qui ne sont pas valides selon la définition plus stricte de S2.
Si vous voyez un message d´erreur tel que <code>#&gt; Error in s2_geography_from_wkb ...</code>, il peut être utile de réessayer la commande qui a généré le message d´erreur, après avoir désactivé S2.
Pour désactiver S2 pour la totalité d´un projet, vous pouvez créer un fichier appelé .Rprofile dans le répertoire racine (le dossier principal) de votre projet contenant la commande <code>sf::sf_use_s2(FALSE)</code>.
</div>
</div>
</div>
<div id="les-données-raster" class="section level2" number="2.3">
<h2>
<span class="header-section-number">2.3</span> Les données raster<a class="anchor" aria-label="anchor" href="#les-donn%C3%A9es-raster"><i class="fas fa-link"></i></a>
</h2>
<p>Le modèle de données raster représente le monde à l’aide d’une grille continue de cellules (souvent aussi appelées pixels ; Figure <a href="spatial-class.html#fig:raster-intro-plot">2.12</a>:A).
Ce modèle de données fait souvent référence à des grilles dites régulières, dans lesquelles chaque cellule a une taille identique et constante - et nous nous concentrerons uniquement sur les grilles régulières dans cet ouvrage.
Cependant, plusieurs autres types de grilles existent, notamment les grilles tournées, cisaillées, rectilignes et curvilignes (voir le chapitre 1 de <span class="citation">Pebesma and Bivand (<a href="raster-vector.html#ref-pebesma_spatial_2022" role="doc-biblioref">2022</a>)</span> ou le chapitre 2 de <span class="citation">Tennekes and Nowosad (<a href="raster-vector.html#ref-tennekes_elegant_2022" role="doc-biblioref">2022</a>)</span>).</p>
<p>Un raster se compose généralement d’un en-tête
et d’une matrice (avec des lignes et des colonnes) représentant des cellules équidistantes (souvent aussi nommées pixels; Figure <a href="spatial-class.html#fig:raster-intro-plot">2.12</a>:A).)<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Selon le format de fichier, l’en-tête fait partie du fichier de données d’image proprement dit, par exemple GeoTIFF, ou peut être stocké dans un fichier d’en-tête supplémentaire un &lt;em&gt;world file&lt;/em&gt;, par exemple dans les formats de grille ASCII.
Il existe également le format raster binaire sans en-tête (plat) qui devrait faciliter l’importation dans divers logiciels.&lt;/p&gt;"><sup>15</sup></a>
L’en-tête du raster définit le système de coordonnées de référence, l’étendue et l’origine.
L’origine (ou point de départ) est souvent la coordonnée du coin inférieur gauche de la matrice (le paquet <strong>terra</strong> utilise toutefois le coin supérieur gauche, par défaut (Figure <a href="spatial-class.html#fig:raster-intro-plot">2.12</a>:B)).
L’en-tête définit l’étendue via le nombre de colonnes, le nombre de lignes et la résolution de la taille des cellules.
Ainsi, en partant de l’origine, nous pouvons facilement accéder à chaque cellule et la modifier, soit en utilisant l’ID d’une cellule (Figure <a href="spatial-class.html#fig:raster-intro-plot">2.12</a>:B), soit en spécifiant explicitement les lignes et les colonnes.
Cette représentation matricielle évite de stocker explicitement les coordonnées des quatre points d’angle (en fait, elle ne stocke qu’une seule coordonnée, à savoir l’origine) de chaque coin de cellule, comme ce serait le cas pour les polygones vectoriels rectangulaires.
Grâce à cela et à l’algèbre raster (section <a href="#map-algebra"><strong>??</strong></a>), le traitement raster est beaucoup plus efficace et rapide que le traitement des données vectorielles.
Cependant, contrairement aux données vectorielles, la cellule d’une couche raster ne peut contenir qu’une seule valeur.
Cette valeur peut être numérique ou catégorique (Figure <a href="spatial-class.html#fig:raster-intro-plot">2.12</a>:C).</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:raster-intro-plot"></span>
<img src="02-spatial-data_files/figure-html/raster-intro-plot-1.png" alt="Le modèle des données raster: (A) identifiant des pixels, (B) valeur des pixels, (C) une carte raster colorisée." width="100%"><p class="caption">
FIGURE 2.12: Le modèle des données raster: (A) identifiant des pixels, (B) valeur des pixels, (C) une carte raster colorisée.
</p>
</div>
<p>Les rasters représentent généralement des phénomènes continus tels que l’altitude, la température, la densité de population ou des données spectrales.
Les variables discrètes telles que la classification des sols ou les typologies d’occupation des sols peuvent également être représentées dans le modèle de données raster.
Ces deux utilisations sont illustrées dans la figure <a href="spatial-class.html#fig:raster-intro-plot2">2.13</a> qui montre que les limites des caractéristiques discrètes peuvent devenir floues dans les ensembles de données matricielles.
Selon la nature de l’application, les représentations vectorielles des caractéristiques discrètes peuvent être plus adaptées.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:raster-intro-plot2"></span>
<img src="02-spatial-data_files/figure-html/raster-intro-plot2-1.png" alt="Exemples de rasters pour des variables continues et catégorielles." width="100%"><p class="caption">
FIGURE 2.13: Exemples de rasters pour des variables continues et catégorielles.
</p>
</div>
<div id="les-paquets-de-r-pour-travailler-avec-des-rasters" class="section level3" number="2.3.1">
<h3>
<span class="header-section-number">2.3.1</span> Les paquets de R pour travailler avec des rasters<a class="anchor" aria-label="anchor" href="#les-paquets-de-r-pour-travailler-avec-des-rasters"><i class="fas fa-link"></i></a>
</h3>
<p>Au cours des deux dernières décennies, plusieurs paquets permettant de lire et de traiter des ensembles de données matricielles ont été développés.
Comme indiqué dans la section <a href="intro.html#the-history-of-r-spatial">1.5</a>, le principal d’entre eux était <strong>raster</strong>. Il a conduit à un changement radical dans les capacités de traitement des rasters avec R lorsqu’il a été lancé en 2010 et il a dominé ce segment jusqu’au développement de <strong>terra</strong> et <strong>stars</strong>.
Développés plus récemment, ces deux paquets offrent des fonctions puissantes et performantes pour travailler avec des jeux de données raster et ils offrent de nombreuses fonctionnalités communes.
Dans ce livre, nous nous concentrons sur <strong>terra</strong>, qui remplace <strong>raster</strong>, plus ancien et (dans la plupart des cas) plus lent.
Avant de découvrir le fonctionnement du système de classes de <strong>terra</strong>, cette section décrit les similitudes et les différences entre <strong>terra</strong> et <strong>stars</strong> ; ces connaissances aideront à décider lequel est le plus approprié dans différentes situations.</p>
<p>Tout d’abord, <strong>terra</strong> se concentre sur le modèle de données raster le plus courant (grilles régulières), tandis que <strong>stars</strong> permet également de stocker des modèles moins populaires (notamment des grilles régulières, tournées, cisaillées, rectilignes et curvilignes).
Alors que <strong>terra</strong> gère généralement des rasters à une ou plusieurs couches<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Il possède également une classe supplémentaire &lt;code&gt;SpatRasterDataset&lt;/code&gt; pour stocker de nombreuses collections de jeux de données&lt;/p&gt;"><sup>16</sup></a>, le paquet <strong>stars</strong> fournit des moyens de stocker des cubes de données raster – un objet raster avec de nombreuses couches (par exemple, des bandes), pour plusieurs points dans le temps (par exemple, chaque mois), et de nombreux attributs (par exemple, le type de capteur A et le type de capteur B).
Premièrement, il est important de noter que dans les deux paquets, toutes les couches ou éléments d’un cube de données doivent avoir les mêmes dimensions spatiales et la même étendue.
Deuxièmement, les deux paquets permettent soit de lire toutes les données raster en mémoire, soit de lire uniquement leurs métadonnées, ce qui est généralement effectué automatiquement en fonction de la taille du fichier d’entrée.
Cependant, ils stockent différement les valeurs associées aux cellules.
<strong>terra</strong> est basé sur du code C++ et utilise principalement des pointeurs C++.
<strong>stars</strong> stocke les valeurs sous forme de listes de tableaux pour les plus petits rasters ou juste un chemin de fichier pour les plus grands.
Troisièmement, les fonctions de <strong>stars</strong> sont étroitement liées aux objets et fonctions vectorielles de <strong>sf</strong>, alors que <strong>terra</strong> utilise sa propre classe d’objets pour les données vectorielles, à savoir <code>SpatVector</code>.
Quatrièmement, les deux paquets approchent différemment la façon dont leurs fonctions agissent sur leurs objets.
Le paquet <strong>terra</strong> s’appuie principalement sur un grand nombre de fonctions intégrées, où chaque fonction a un but spécifique (par exemple, le rééchantillonnage ou le recadrage).
De son coté <strong>stars</strong> propose quelques fonctions intégrées (généralement avec des noms commençant par <code>st_</code>) mais a aussi ses propres méthodes pour les fonctions de R (par exemple, <code><a href="https://rdrr.io/pkg/terra/man/split.html">split()</a></code> ou <code><a href="https://rdrr.io/pkg/terra/man/aggregate.html">aggregate()</a></code>) et celles de <strong>dplyr</strong> (par exemple, <code><a href="https://rdrr.io/r/stats/filter.html">filter()</a></code> ou <code>slice()</code>).</p>
<p>Il est important de noter qu’il est facile de convertir des objets de <strong>terra</strong> en <strong>stars</strong> (en utilisant <code>st_as_stars()</code>) et inversement (en utilisant <code><a href="https://rdrr.io/pkg/terra/man/rast.html">rast()</a></code>).
Nous vous encourageons également à lire <span class="citation">Pebesma and Bivand (<a href="raster-vector.html#ref-pebesma_spatial_2022" role="doc-biblioref">2022</a>)</span> pour l’introduction la plus complète au paquet <strong>stars</strong>.</p>
</div>
<div id="une-introduction-à-terra" class="section level3" number="2.3.2">
<h3>
<span class="header-section-number">2.3.2</span> Une introduction à terra<a class="anchor" aria-label="anchor" href="#une-introduction-%C3%A0-terra"><i class="fas fa-link"></i></a>
</h3>
<p>Le paquet <strong>terra</strong> prend en charge les objets raster dans R.
Comme son prédécesseur <strong>raster</strong> (créé par le même développeur, Robert Hijmans), il fournit un ensemble complet de fonctions pour créer, lire, exporter, manipuler et traiter des jeux de données rasters.
Les fonctionnalités de <strong>terra</strong> sont en grande partie les mêmes que celles de <strong>raster</strong>, plus mature, mais il existe quelques différences : les fonctions <strong>terra</strong> sont généralement plus efficientes en calcul que leurs équivalents <strong>raster</strong>.
<!-- todo : ajouter des preuves (RL 2021-11) -->
D’autre part, le système de classes de <strong>raster</strong> est populaire et utilisé par de nombreux autres paquets.
Vous pouvez passer sans problème d’un type d’objet à l’autre pour assurer la compatibilité avec les anciens scripts et paquets, par exemple avec les fonctions <a href="https://rspatial.github.io/raster/reference/raster.html"><code>raster()</code></a>, <a href="https://rspatial.github.io/raster/reference/stack.html"><code>stack()</code></a> et <code>brick()</code> du paquet <strong>raster</strong> (cf. le chapitre précédent pour en savoir plus sur l’évolution des paquets R pour travailler avec des données géographiques).</p>
<p>En plus des fonctions de manipulation des données matricielles, <strong>terra</strong> fournit de nombreuses fonctions de bas niveau pouvant servir de base au développement de nouveaux outils pour travailler avec des jeux de données raster.
<strong>terra</strong> vous permet également de travailler sur de grands jeux de données raster qui sont trop volumineux pour tenir dans la RAM.
Dans ce cas, <strong>terra</strong> offre la possibilité de diviser l’image raster en petits morceaux et de les traiter de manière itérative au lieu de charger un fichier entier dans la RAM.</p>
<p>Pour l’illustration des concepts <strong>terra</strong>, nous utiliserons des jeux de données de <strong>spDataLarge</strong>.
Il s’agit de quelques objets raster et d’un objet vectoriel couvrant une zone du parc national de Zion (Utah, USA).
Par exemple, <code>srtm.tif</code> est un modèle numérique de terrain de cette zone (pour plus de détails, voir sa documentation <code>?srtm</code>).
Tout d’abord, créons un objet <code>SpatRaster</code> nommé <code>my_rast</code> :</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raster_filepath</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/srtm.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">my_rast</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span><span class="va">raster_filepath</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">my_rast</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "SpatRaster"</span></span>
<span><span class="co">#&gt; attr(,"package")</span></span>
<span><span class="co">#&gt; [1] "terra"</span></span></code></pre></div>
<p>En tapant le nom du raster dans la console, on obtient l’en-tête du raster (dimensions, résolution, étendue, CRS) et quelques informations supplémentaires (classe, source de données, résumé des valeurs du raster) :</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">my_rast</span></span>
<span><span class="co">#&gt; class       : SpatRaster </span></span>
<span><span class="co">#&gt; dimensions  : 457, 465, 1  (nrow, ncol, nlyr)</span></span>
<span><span class="co">#&gt; resolution  : 0.000833, 0.000833  (x, y)</span></span>
<span><span class="co">#&gt; extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)</span></span>
<span><span class="co">#&gt; coord. ref. : lon/lat WGS 84 (EPSG:4326) </span></span>
<span><span class="co">#&gt; source      : srtm.tif </span></span>
<span><span class="co">#&gt; name        : srtm </span></span>
<span><span class="co">#&gt; min value   : 1024 </span></span>
<span><span class="co">#&gt; max value   : 2892</span></span></code></pre></div>
<p>Des fonctions dédiées renseignent sur chaque composant : <code><a href="https://rdrr.io/r/base/dim.html">dim()</a></code> renvoie le nombre de lignes, de colonnes et de couches ; <code><a href="https://rdrr.io/pkg/terra/man/dimensions.html">ncell()</a></code> le nombre de cellules (pixels) ; <code><a href="https://rdrr.io/pkg/terra/man/dimensions.html">res()</a></code> la résolution spatiale ; <code><a href="https://rdrr.io/pkg/terra/man/ext.html">ext()</a></code> son étendue spatiale ; et <code><a href="https://rdrr.io/pkg/terra/man/crs.html">crs()</a></code> son système de coordonnées de référence (la reprojection de raster est traitée dans la section <a href="#reproj-ras"><strong>??</strong></a>).
<code><a href="https://rdrr.io/pkg/terra/man/sources.html">inMemory()</a></code> indique si le raster est stocké en mémoire vive ou sur disque.</p>
<p><code><a href="https://rdrr.io/pkg/terra/man/terra-package.html">help("terra-package")</a></code> renvoie une liste complète de toutes les fonctions <strong>terra</strong> disponibles.</p>
</div>
<div id="basic-map-raster" class="section level3" number="2.3.3">
<h3>
<span class="header-section-number">2.3.3</span> Réalisation de cartes de base<a class="anchor" aria-label="anchor" href="#basic-map-raster"><i class="fas fa-link"></i></a>
</h3>
<p>Comme le paquet <strong>sf</strong>, <strong>terra</strong> fournit également des méthodes <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> pour ses propres classes.
</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/plot.html">plot</a></span><span class="op">(</span><span class="va">my_rast</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:basic-new-raster-plot"></span>
<img src="02-spatial-data_files/figure-html/basic-new-raster-plot-1.png" alt="Une représentation raster basique." width="100%"><p class="caption">
FIGURE 2.14: Une représentation raster basique.
</p>
</div>
<p>Il existe plusieurs autres approches pour représenter des données raster dans R qui sortent du cadre de cette section, notamment :</p>
<ul>
<li>la fonction <code><a href="https://rdrr.io/pkg/terra/man/plotRGB.html">plotRGB()</a></code> du paquet <strong>terra</strong> pour créer <em>une composition colorée rouge-vert-bleu (RGB)</em> basée sur trois couches dans un objet <code>SpatRaster</code>;</li>
<li>des paquets tels que <strong>tmap</strong> pour créer des cartes statiques et interactives d’objets rasters et vectoriels (voir le chapitre <a href="#adv-map"><strong>??</strong></a>) ;</li>
<li>d’autres fonctions, par exemple <code>levelplot()</code> du paquet <strong>rasterVis</strong>, pour créer des vignettes, une technique courante pour visualiser les changements dans le temps.</li>
</ul>
</div>
<div id="raster-classes" class="section level3" number="2.3.4">
<h3>
<span class="header-section-number">2.3.4</span> Les classes raster<a class="anchor" aria-label="anchor" href="#raster-classes"><i class="fas fa-link"></i></a>
</h3>
<p>La classe <code>SpatRaster</code> représente les rasters dans <strong>terra</strong>.
La façon la plus simple de créer un objet raster dans R est de lire un fichier raster à partir du disque ou d’un serveur (Section <a href="#raster-data-read"><strong>??</strong></a>.
</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">single_raster_file</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/srtm.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">single_rast</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span><span class="va">raster_filepath</span><span class="op">)</span></span></code></pre></div>
<p>Le paquet <strong>terra</strong> supporte de nombreux pilotes grâce à la bibliothèque GDAL.
Les rasters provenant de fichiers ne sont généralement pas lus entièrement en RAM, à l’exception de leur en-tête et d’un pointeur vers le fichier lui-même.</p>
<p>Les rasters peuvent aussi être créés à partir de zéro en utilisant la même fonction <code><a href="https://rdrr.io/pkg/terra/man/rast.html">rast()</a></code>.
Ceci est illustré dans l’extrait de code suivant créant un nouvel objet <code>SpatRaster</code>.
Ce raster consiste en 36 cellules (6 colonnes et 6 lignes spécifiées par <code>nrows</code> et <code>ncols</code>) centrées autour du Méridien d’origine et de l’Équateur (voir les paramètres <code>xmin</code>, <code>xmax</code>, <code>ymin</code> et <code>ymax</code>).
Le SCR par défaut des objets rasters est WGS84, mais peut être changé avec l’argument <code>crs</code>.
Cela signifie que l’unité de résolution est en degrés, que nous fixons à 0.5 (<code>resolution</code>).
Des valeurs (<code>vals</code>) sont assignées à chaque cellule : 1 à la cellule 1, 2 à la cellule 2, et ainsi de suite.
Rappelez-vous : <code><a href="https://rdrr.io/pkg/terra/man/rast.html">rast()</a></code> remplit les cellules par ligne (contrairement à <code><a href="https://rdrr.io/r/base/matrix.html">matrix()</a></code>) en commençant par le coin supérieur gauche, ce qui signifie que la première ligne contient les valeurs 1 à 6, la seconde 7 à 12, etc.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">new_raster</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span>nrows <span class="op">=</span> <span class="fl">6</span>, ncols <span class="op">=</span> <span class="fl">6</span>, resolution <span class="op">=</span> <span class="fl">0.5</span>, </span>
<span>                  xmin <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, xmax <span class="op">=</span> <span class="fl">1.5</span>, ymin <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, ymax <span class="op">=</span> <span class="fl">1.5</span>,</span>
<span>                  vals <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">36</span><span class="op">)</span></span></code></pre></div>
<p><code><a href="https://rdrr.io/pkg/terra/man/rast.html">?rast</a></code> permet de découvrir d’autre façons de créer des objets rasters.</p>
<p>La classe <code>SpatRaster</code> gère également les couches multiples, qui correspondent généralement à un seul fichier satellite multispectral ou à une série temporelle de rasters.</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multi_raster_file</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/landsat.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">multi_rast</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/rast.html">rast</a></span><span class="op">(</span><span class="va">multi_raster_file</span><span class="op">)</span></span>
<span><span class="va">multi_rast</span></span>
<span><span class="co">#&gt; class       : SpatRaster </span></span>
<span><span class="co">#&gt; dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)</span></span>
<span><span class="co">#&gt; resolution  : 30, 30  (x, y)</span></span>
<span><span class="co">#&gt; extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)</span></span>
<span><span class="co">#&gt; coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) </span></span>
<span><span class="co">#&gt; source      : landsat.tif </span></span>
<span><span class="co">#&gt; names       : landsat_1, landsat_2, landsat_3, landsat_4 </span></span>
<span><span class="co">#&gt; min values  :      7550,      6404,      5678,      5252 </span></span>
<span><span class="co">#&gt; max values  :     19071,     22051,     25780,     31961</span></span></code></pre></div>
<p><code><a href="https://rdrr.io/pkg/terra/man/dimensions.html">nlyr()</a></code> fournit le nombre de couches stockées dans un objet <code>SpatRaster</code> :</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/dimensions.html">nlyr</a></span><span class="op">(</span><span class="va">multi_rast</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 4</span></span></code></pre></div>
<p>Pour les objets raster multi-couches, les couches peuvent être sélectionnées avec <code><a href="https://rdrr.io/pkg/terra/man/subset.html">terra::subset()</a></code><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Les opérateurs &lt;code&gt;[[&lt;/code&gt; et &lt;code&gt;$&lt;/code&gt; peuvent également être utilisés pour la sélection des couches, par exemple avec les commandes &lt;code&gt;multi_rast$landsat_1&lt;/code&gt; et &lt;code&gt;multi_rast[["landsat_1"]]&lt;/code&gt;.&lt;/p&gt;'><sup>17</sup></a>
qui accepte un numéro ou un nom de couche comme second argument :</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multi_rast3</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/subset.html">subset</a></span><span class="op">(</span><span class="va">multi_rast</span>, <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">multi_rast4</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/subset.html">subset</a></span><span class="op">(</span><span class="va">multi_rast</span>, <span class="st">"landsat_4"</span><span class="op">)</span></span></code></pre></div>
<p>L’opération inverse, qui consiste à combiner plusieurs objets <code>SpatRaster</code> en un seul, peut être réalisée à l’aide de la fonction <code>c</code> :</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">multi_rast34</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">multi_rast3</span>, <span class="va">multi_rast4</span><span class="op">)</span></span></code></pre></div>

<div class="rmdnote">
La plupart des objets <code>SpatRaster</code> ne stockent pas des rasters, mais plutôt un pointeur vers le fichier lui-même.
Cela a un effet secondaire important : ils ne peuvent pas être directement sauvegardés dans des fichiers <code>".rds"</code> ou <code>".rda"</code> ou utilisés dans le calcul en grappe.
Dans ces cas, il y a deux solutions possibles : (1) l´utilisation de la fonction <code><a href="https://rdrr.io/pkg/terra/man/wrap.html">wrap()</a></code> qui crée un type spécial d´objet temporaire qui peut être sauvegardé comme un objet R ou utilisé dans des grappe de serveurs, ou (2) sauvegarder l´objet comme un raster régulier avec <code><a href="https://rdrr.io/pkg/terra/man/writeRaster.html">writeRaster()</a></code>.
</div>
<!--jn:toDo-->
<!--consider new section with other data models-->
<!-- e.g. point clouds, data cubes, meshes, etc. -->
</div>
</div>
<div id="crs-intro" class="section level2" number="2.4">
<h2>
<span class="header-section-number">2.4</span> Les systèmes de référence des coordonnées<a class="anchor" aria-label="anchor" href="#crs-intro"><i class="fas fa-link"></i></a>
</h2>
<p>
Les types de données spatiales vectorielles et rasters partagent des concepts intrinsèques aux données spatiales.
Le plus fondamental d’entre eux est peut-être le système de référence des coordonnées (CRS), qui définit la manière dont les éléments spatiaux des données se rapportent à la surface de la Terre (ou d’autres corps).
Les CRS sont soit géographiques, soit projetés, comme nous l’avons présenté au début de ce chapitre (voir Figure <a href="spatial-class.html#fig:vectorplots">2.1</a>).
Cette section reprend chaque type, posant ainsi les bases du chapitre <a href="#reproj-geo-data"><strong>??</strong></a>, qui offre une plongée en profondeur dans la configuration, la transformation et l’interrogation des SCR.</p>
<div id="les-systèmes-de-coordonnées-géographiques" class="section level3" number="2.4.1">
<h3>
<span class="header-section-number">2.4.1</span> Les systèmes de coordonnées géographiques<a class="anchor" aria-label="anchor" href="#les-syst%C3%A8mes-de-coordonn%C3%A9es-g%C3%A9ographiques"><i class="fas fa-link"></i></a>
</h3>
<p>
Les systèmes de coordonnées géographiques identifient tout emplacement sur la surface de la Terre à l’aide de deux valeurs — la longitude et la latitude (voir le panneau gauche de la figure <a href="spatial-class.html#fig:vector-crs">2.16</a>).
<em>La longitude</em> est la position dans la direction est-ouest en distance angulaire par rapport au plan du méridien d’origine.
<em>La latitude</em> est la distance angulaire au nord ou au sud du plan équatorial.
Les distances dans les SCR géographiques ne sont donc pas mesurées en mètres.
Cela a des conséquences importantes, comme le montre la section <a href="#reproj-geo-data"><strong>??</strong></a>.</p>
<p>La surface de la Terre dans les systèmes de coordonnées géographiques est représentée par une surface sphérique ou ellipsoïdale.
Les modèles sphériques supposent que la Terre est une sphère parfaite d’un rayon donné. Ils ont l’avantage de la simplicité mais, en même temps, ils sont inexacts : la Terre n’est pas une sphère !
Les modèles ellipsoïdaux sont définis par deux paramètres : le rayon équatorial et le rayon polaire.
Ils sont adaptés car la Terre est comprimée : le rayon équatorial est environ 11,5 km plus long que le rayon polaire <span class="citation">(<a href="raster-vector.html#ref-maling_coordinate_1992" role="doc-biblioref">Maling 1992</a>)</span>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Le degré de compression est souvent appelé &lt;em&gt;aplatissement&lt;/em&gt;, défini en fonction du rayon équatorial (&lt;span class="math inline"&gt;\(a\)&lt;/span&gt;) et du rayon polaire (&lt;span class="math inline"&gt;\(b\)&lt;/span&gt;) comme suit : &lt;span class="math inline"&gt;\(f = (a - b) / a\)&lt;/span&gt;. Les termes &lt;em&gt;ellipticité&lt;/em&gt; et &lt;em&gt;compression&lt;/em&gt; peuvent également être utilisés.
Comme &lt;span class="math inline"&gt;\(f\)&lt;/span&gt; est une valeur plutôt faible, les modèles numériques d’ellipsoïdes utilisent l’“aplatissement inverse” (&lt;span class="math inline"&gt;\(rf = 1/f\)&lt;/span&gt;) pour définir la compression de la Terre.
Les valeurs de &lt;span class="math inline"&gt;\(a\)&lt;/span&gt; et &lt;span class="math inline"&gt;\(rf\)&lt;/span&gt; dans divers modèles ellipsoïdaux peuvent être vues en exécutant &lt;code&gt;sf_proj_info(type = "ellps")&lt;/code&gt;.&lt;/p&gt;'><sup>18</sup></a></p>
<p>Les ellipsoïdes font partie d’un composant plus large des CRS : le <em>datum</em>.
Il contient des informations sur l’ellipsoïde à utiliser et la relation précise entre les coordonnées cartésiennes et l’emplacement sur la surface de la Terre.
Il existe deux types de datum — géocentrique (tel que <code>WGS84</code>) et local (tel que <code>NAD83</code>).
Vous pouvez voir des exemples de ces deux types de référentiels dans la figure <a href="spatial-class.html#fig:datum-fig">2.15</a>.
Les lignes noires représentent un * datum géocentrique<em>, dont le centre est situé au centre de gravité de la Terre et n’est pas optimisé pour un emplacement spécifique.
Dans un </em>datum référentiel*, représenté par une ligne pointillée violette, la surface ellipsoïdale est décalée pour s’aligner sur la surface à un endroit particulier.
Cela permet de prendre en compte les variations locales de la surface de la Terre, dues par exemple à de grandes chaînes de montagnes, dans un SCR local.
On peut le voir sur la figure <a href="spatial-class.html#fig:datum-fig">2.15</a>, où le système de référence local est adapté à la région des Philippines, mais n’est pas aligné avec la majeure partie du reste de la surface de la planète.
Les deux référentiels de la figure <a href="spatial-class.html#fig:datum-fig">2.15</a> sont placés au-dessus d’un géoïde - un modèle du niveau moyen des mers à l’échelle mondiale <a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Veuillez noter que le géoïde de la figure exagère la surface bosselée du géoïde par un facteur de 10 000 afin de souligner la forme irrégulière de la planète&lt;/p&gt;"><sup>19</sup></a>.</p>

<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:datum-fig"></span>
<img src="figures/02_datum_fig.png" alt="Données géocentriques et géodésiques locales représentées sur un géoïde (en fausses couleurs et avec un facteur d’échelle de 10 000 pour l’exagération verticale). L’image du géoïde est adaptée du travail de Ince et al. (2019)." width="100%"><p class="caption">
FIGURE 2.15: Données géocentriques et géodésiques locales représentées sur un géoïde (en fausses couleurs et avec un facteur d’échelle de 10 000 pour l’exagération verticale). L’image du géoïde est adaptée du travail de <span class="citation">Ince et al. (<a href="raster-vector.html#ref-essd-11-647-2019" role="doc-biblioref">2019</a>)</span>.
</p>
</div>
</div>
<div id="les-systèmes-de-coordonnées-projetés" class="section level3" number="2.4.2">
<h3>
<span class="header-section-number">2.4.2</span> Les systèmes de coordonnées projetés<a class="anchor" aria-label="anchor" href="#les-syst%C3%A8mes-de-coordonn%C3%A9es-projet%C3%A9s"><i class="fas fa-link"></i></a>
</h3>
<p>
Tous les CRS projetés sont basés sur un CRS géographique, décrit dans la section précédente, et s’appuient sur des projections cartographiques pour convertir la surface tridimensionnelle de la Terre en valeurs d’abscisses et d’ordonnées (x et y) dans un CRS projeté.
Les CRS projetés reposent sur des coordonnées cartésiennes sur une surface implicitement plane (panneau de droite de la figure <a href="spatial-class.html#fig:vector-crs">2.16</a>).
Ils ont une origine, des axes x et y, et une unité de mesure linéaire telle que le mètre.</p>
<p>Cette transition ne peut se faire sans ajouter certaines déformations.
Par conséquent, certaines propriétés de la surface de la Terre sont déformées au cours de ce processus, telles que la superficie, la direction, la distance et la forme.
Un système de coordonnées projeté ne peut préserver qu’une ou deux de ces propriétés.
Les projections sont souvent nommées en fonction de la propriété qu’elles préservent : la projection de surface égale préserve l’aire, la projection azimutale préserve la direction, la projection équidistante préserve la distance et la projection conforme préserve la forme locale.</p>
<p>Il existe trois groupes principaux de types de projection : conique, cylindrique et plane (azimutale).
Dans une projection conique, la surface de la Terre est projetée sur un cône le long d’une seule ligne de tangence ou de deux lignes de tangence.
Les distorsions sont minimisées le long des lignes de tangence et augmentent avec la distance à ces lignes dans cette projection.
Elle est donc mieux adaptée aux cartes des zones de latitude moyenne.
Une projection cylindrique représente la surface sur un cylindre.
Cette projection peut également être créée en plaçant la surface de la Terre le long d’une seule ligne de tangence ou de deux lignes de tangence.
Les projections cylindriques sont le plus souvent utilisées pour cartographier le monde entier.
Une projection plane projette les données sur une surface plate en touchant le globe en un point ou le long d’une ligne de tangence.
Elle est généralement utilisée pour cartographier les régions polaires.
<code>sf_proj_info(type = "proj")</code> donne une liste des projections disponibles supportées par la bibliothèque PROJ.</p>
<p>Un résumé rapide des différentes projections, de leurs types, de leurs propriétés et de leur adéquation peut être trouvé dans <span class="citation"><span>“Map Projections”</span> (<a href="raster-vector.html#ref-_map_1993" role="doc-biblioref">1993</a>)</span> et sur <a href="https://www.geo-projections.com/" class="uri">https://www.geo-projections.com/</a>.
Nous nous étendrons sur les CRS et expliquerons comment projeter d’un SCR à un autre dans le chapitre <a href="#reproj-geo-data"><strong>??</strong></a>.
Pour l’instant, il suffit de savoir :</p>
<ul>
<li>Les systèmes de coordonnées sont un élément clé des objets géographiques.</li>
<li>Il est important de savoir dans quel CRS se trouvent vos données, et s’il s’agit d’un système géographique (lon/lat) ou d’un système projeté (généralement en mètres), car cela a des conséquences sur la façon dont R gère les opérations spatiales et géométriques.</li>
<li>Les CRS des objets <code>sf</code> peuvent être interrogés avec la fonction <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code>, les CRS des objets <code>terra</code> peuvent être interrogés avec la fonction <code><a href="https://rdrr.io/pkg/terra/man/crs.html">crs()</a></code>.</li>
</ul>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:vector-crs"></span>
<img src="figures/02_vector_crs.png" alt="Exemples de systèmes de coordonnées géographiques (WGS 84 ; à gauche) et projetées (NAD83 / UTM zone 12N ; à droite) pour un type de données vectorielles." width="100%"><p class="caption">
FIGURE 2.16: Exemples de systèmes de coordonnées géographiques (WGS 84 ; à gauche) et projetées (NAD83 / UTM zone 12N ; à droite) pour un type de données vectorielles.
</p>
</div>
</div>
</div>
<div id="unités" class="section level2" number="2.5">
<h2>
<span class="header-section-number">2.5</span> Unités<a class="anchor" aria-label="anchor" href="#unit%C3%A9s"><i class="fas fa-link"></i></a>
</h2>
<!--rl-->
<!-- https://cran.r-project.org/web/packages/units/vignettes/measurement_units_in_R.html -->
<p>Une caractéristique importante des SCR est qu’ils contiennent des informations sur les unités spatiales.
De toute évidence, il est essentiel de savoir si les mesures d’une maison sont en pieds ou en mètres, et il en va de même pour les cartes.
Il est de bonne pratique cartographique d’ajouter une <em>barre d’échelle</em> ou un autre indicateur de distance sur les cartes afin de démontrer la relation entre les distances sur la page ou l’écran et les distances sur le terrain.
De même, il est important de spécifier formellement les unités dans lesquelles les données géométriques ou les cellules sont mesurées afin de fournir un contexte et de garantir que les calculs ultérieurs sont effectués dans ce contexte.</p>
<p>Une nouvelle caractéristique des données géométriques dans les objets <code>sf</code> est qu’elles ont un <em>support natif</em> pour les unités.
Cela signifie que les calculs de distance, de surface et autres calculs géométriques dans <strong>sf</strong> renvoient des valeurs accompagnées d’un attribut <code>units</code>, défini par le paquet <strong>units</strong> <span class="citation">(<a href="raster-vector.html#ref-pebesma_measurement_2016" role="doc-biblioref">Pebesma, Mailund, and Hiebert 2016</a>)</span>.
Ceci est avantageux, car cela évite la confusion causée par les différentes unités (la plupart des SCR utilisent les mètres, certains les pieds) et fournit des informations sur la dimensionnalité.
Ceci est démontré dans le morceau de code ci-dessous, qui calcule la superficie du Luxembourg :
</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">luxembourg</span> <span class="op">=</span> <span class="va">world</span><span class="op">[</span><span class="va">world</span><span class="op">$</span><span class="va">name_long</span> <span class="op">==</span> <span class="st">"Luxembourg"</span>, <span class="op">]</span></span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_area</a></span><span class="op">(</span><span class="va">luxembourg</span><span class="op">)</span> <span class="co"># nécessite le paquet s2 des récentes version de sf</span></span>
<span><span class="co">#&gt; 2.41e+09 [m^2]</span></span></code></pre></div>
<p>La sortie est en unités de mètres carrés (m<sup>2</sup>), montrant que le résultat représente un espace bidimensionnel.
Cette information, stockée sous forme d’attribut (que les lecteurs intéressés peuvent découvrir avec <code>attributs(st_area(luxembourg))</code>), peut alimenter des calculs ultérieurs qui utilisent des unités, comme la densité de population (nombre de personnes par unité de surface, typiquement par km<sup>2</sup>).
Le fait de déclarer les unités permet d’éviter toute confusion.
Pour reprendre l’exemple du Luxembourg, si les unités n’étaient pas précisées, on pourrait supposer à tort que les unités sont en hectares.
Pour traduire ce chiffre énorme en une taille plus digeste, il est tentant de diviser les résultats par un million (le nombre de mètres carrés dans un kilomètre carré)</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_area</a></span><span class="op">(</span><span class="va">luxembourg</span><span class="op">)</span> <span class="op">/</span> <span class="fl">1000000</span></span>
<span><span class="co">#&gt; 2409 [m^2]</span></span></code></pre></div>
<p>Cependant, le résultat est alors donné de manière incorrecte en mètres carrés.
La solution consiste à définir les unités correctes avec le paquet <strong>units</strong> :</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">units</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/units/man/units.html">set_units</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_area</a></span><span class="op">(</span><span class="va">luxembourg</span><span class="op">)</span>, <span class="va">km</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt; 2409 [km^2]</span></span></code></pre></div>
<p>Les unités sont tout aussi importantes dans le cas des jeux de données raster.
Cependant, jusqu’à présent, <strong>sf</strong> est le seul paquet spatial qui supporte les unités, ce qui signifie que les personnes travaillant sur des données raster doivent aborder les changements d’unités d’analyse (par exemple, la conversion de la largeur des pixels des unités impériales aux unités décimales) avec précaution.
L’objet <code>my_rast</code> (voir ci-dessus) utilise une projection WGS84 avec des degrés décimaux comme unités.
Par conséquent, sa résolution est également donnée en degrés décimaux, mais il faut le savoir, puisque la fonction <code><a href="https://rdrr.io/pkg/terra/man/dimensions.html">res()</a></code> renvoie simplement un vecteur numérique.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/dimensions.html">res</a></span><span class="op">(</span><span class="va">my_rast</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.000833 0.000833</span></span></code></pre></div>
<p>Si nous utilisions la projection UTM, les unités changeraient.</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">repr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/project.html">project</a></span><span class="op">(</span><span class="va">my_rast</span>, <span class="st">"EPSG:26912"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/terra/man/dimensions.html">res</a></span><span class="op">(</span><span class="va">repr</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 83.5 83.5</span></span></code></pre></div>
<p>Encore une fois, la commande <code><a href="https://rdrr.io/pkg/terra/man/dimensions.html">res()</a></code> renvoie un tableau numérique sans unité, ce qui nous oblige à savoir que l’unité de la projection UTM est le mètre.</p>
</div>
<div id="ex2" class="section level2" number="2.6">
<h2>
<span class="header-section-number">2.6</span> Exercises<a class="anchor" aria-label="anchor" href="#ex2"><i class="fas fa-link"></i></a>
</h2>
<p>E1. Utilisez <code><a href="https://rdrr.io/pkg/terra/man/summary.html">summary()</a></code> sur la colonne géométrie de l’objet de données <code>world</code> qui est inclus dans le paquet <strong>spData</strong>. Qu’en déduisez vous sur :</p>
<ul>
<li>Son type de géométrie ?</li>
<li>Le nombre de pays ?</li>
<li>Son système de coordonnées et de référence (SCR) ?</li>
</ul>
<p>E2. Exécutez le code qui a “généré” la carte du monde dans la section 2.2.3 (Création de cartes de base).
Trouvez deux similitudes et deux différences entre l’image sur votre ordinateur et celle du livre.</p>
<ul>
<li>Que fait l’argument <code>cex</code> (voir <code><a href="https://rdrr.io/pkg/terra/man/plot.html">?plot</a></code>) ?</li>
<li>Pourquoi le paramètre <code>cex</code> a-t-il été fixé à <code>sqrt(world$pop) / 10000</code> ?</li>
<li>Bonus : expérimentez différentes façons de visualiser la population mondiale.</li>
</ul>
<p>E3. Utilisez <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code> pour créer des cartes du Nigeria et les pays avoisinants (voir section 2.2.3).</p>
<ul>
<li>Ajustez les arguments <code>lwd</code>, <code>col</code> et <code>expandBB</code> de <code><a href="https://rdrr.io/pkg/terra/man/plot.html">plot()</a></code>.</li>
<li>Défi! : lisez la documentation de <code><a href="https://rdrr.io/pkg/terra/man/text.html">text()</a></code> et annotez la carte.</li>
</ul>
<p>E4. Créez un objet <code>SpatRaster</code> vide appelé <code>mon_raster</code> avec 10 colonnes et 10 lignes.
Attribuez des valeurs aléatoires entre 0 et 10 au nouveau raster et représentez-le.</p>
<p>E5. Lisez le fichier <code>raster/nlcd.tif</code> du paquet <strong>spDataLarge</strong>.
Quel type d’information pouvez-vous obtenir sur les propriétés de ce fichier ?</p>
<p>E6. Regardez le SCR du fichier <code>raster/nlcd.tif</code> du paquet <strong>spDataLarge</strong>.
Quel type d’information pouvez-vous en tirer ?</p>

</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="intro.html"><span class="header-section-number">1</span> Introduction</a></div>
<div class="next"><a href="attr.html"><span class="header-section-number">3</span> Opérations sur les tables attributaires</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Note: La Seconde Edition est en construction 🏗</h2>
    <!--<p>C'est le moment idéal pour tester les paquets en cours de développement et fournir vos commentaires</p>
        <ul class="list-unstyled">
          <li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Fournir un commentaire (5 min)</a></li>>-->
          <li><a href="https://geocompr.robinlovelace.net/#reproducibility">Installer la dernière version</a></li>
          <li><a href="https://github.com/Robinlovelace/geocompr/issues">Signaler un problème <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/PMztXYgNxp">Discuter sur Discord <i class="fab fa-discord"></i></a></li>
          <li><a href="https://how-to-help-ukraine-now.super.site">Support Ukraine 🇺🇦
</a></li>
        
        <hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>Sur cette page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#spatial-class"><span class="header-section-number">2</span> La donnée géographique dans R</a></li>
<li><a class="nav-link" href="#pr%C3%A9requis">Prérequis</a></li>
<li><a class="nav-link" href="#intro-spatial-class"><span class="header-section-number">2.1</span> Introduction</a></li>
<li>
<a class="nav-link" href="#donn%C3%A9es-vectorielles"><span class="header-section-number">2.2</span> Données vectorielles</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#une-introduction-aux-simple-features"><span class="header-section-number">2.2.1</span> Une introduction aux Simple Features</a></li>
<li><a class="nav-link" href="#pourquoi-simple-features"><span class="header-section-number">2.2.2</span> Pourquoi simple features?</a></li>
<li><a class="nav-link" href="#basic-map"><span class="header-section-number">2.2.3</span> Réalisation rapide de cartes</a></li>
<li><a class="nav-link" href="#geometry"><span class="header-section-number">2.2.4</span> Les types de géométries</a></li>
<li><a class="nav-link" href="#sf"><span class="header-section-number">2.2.5</span> La classe sf</a></li>
<li><a class="nav-link" href="#sfg"><span class="header-section-number">2.2.6</span> Simple feature geometries (sfg)</a></li>
<li><a class="nav-link" href="#sfc"><span class="header-section-number">2.2.7</span> Simple feature columns (sfc)</a></li>
<li><a class="nav-link" href="#le-paquet-sfheaders"><span class="header-section-number">2.2.8</span> le paquet sfheaders</a></li>
<li><a class="nav-link" href="#s2"><span class="header-section-number">2.2.9</span> géométrie sphérique avec S2</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#les-donn%C3%A9es-raster"><span class="header-section-number">2.3</span> Les données raster</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#les-paquets-de-r-pour-travailler-avec-des-rasters"><span class="header-section-number">2.3.1</span> Les paquets de R pour travailler avec des rasters</a></li>
<li><a class="nav-link" href="#une-introduction-%C3%A0-terra"><span class="header-section-number">2.3.2</span> Une introduction à terra</a></li>
<li><a class="nav-link" href="#basic-map-raster"><span class="header-section-number">2.3.3</span> Réalisation de cartes de base</a></li>
<li><a class="nav-link" href="#raster-classes"><span class="header-section-number">2.3.4</span> Les classes raster</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#crs-intro"><span class="header-section-number">2.4</span> Les systèmes de référence des coordonnées</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#les-syst%C3%A8mes-de-coordonn%C3%A9es-g%C3%A9ographiques"><span class="header-section-number">2.4.1</span> Les systèmes de coordonnées géographiques</a></li>
<li><a class="nav-link" href="#les-syst%C3%A8mes-de-coordonn%C3%A9es-projet%C3%A9s"><span class="header-section-number">2.4.2</span> Les systèmes de coordonnées projetés</a></li>
</ul>
</li>
<li><a class="nav-link" href="#unit%C3%A9s"><span class="header-section-number">2.5</span> Unités</a></li>
<li><a class="nav-link" href="#ex2"><span class="header-section-number">2.6</span> Exercises</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/geocompr/fr/blob/main/02-spatial-data.Rmd">Code source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/geocompr/fr/edit/main/02-spatial-data.Rmd">Editer cette page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation avec R</strong>" a été ecris par Robin Lovelace, Jakub Nowosad, Jannes Muenchow. Traduction: Olivier Leroy.  et sa dernière mise en ligne date de  2022-08-30.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>Ce livre a été ecris grâce à <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
