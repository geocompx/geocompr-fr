[{"path":"index.html","id":"bienvenue","chapter":"Bienvenue!","heading":"Bienvenue!","text":"Il s’agit du site en français de Geocomputation R, un livre sur l’analyse, la visualisation et la modélisation des données géographiques. Le site en anglais est ici.Note: La première édition été imprimée par CRC Press dans la collection R Series.\nIl est possible de l’acheter chez CRC Press, ou sur Amazon, la première version est aussi hebergée sur bookdown.org.Inspiré par le mouvement libriste et l’Open Source Software Geospatial (FOSS4G), le code et le texte qui sous-tendent ce livre sont ouverts, ce qui garantit que le contenu est reproductible, transparent et accessible.\nL’hébergement du code source sur GitHub permet à quiconque d’interagir avec le projet en ouvrant des questions ou en contribuant au nouveau contenu et à la correction des fautes de frappe pour le bénéfice de tous.\nLa version en ligne du livre est hébergée sur geocompr.github.io et mise à jour par GitHub Actions.\nL’état actuel de sa construction est le suivant :version book built GH Actions 2022-02-26.work licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"index.html","id":"comment-contribuer","chapter":"Bienvenue!","heading":"Comment contribuer ?","text":"bookdown rend l’édition d’un livre aussi facile que l’édition d’un wiki, à condition d’avoir un compte GitHub (inscription sur github.com).\nUne fois connecté à GitHub, cliquez sur l’icône “Edit page” dans le panneau de droite du site Web du livre.\nVous accéderez ainsi à une version modifiable du fichier source R Markdown qui généré la page sur laquelle vous vous trouvez.Pour signaler un problème concernant le contenu du livre (par exemple, un code qui ne fonctionne pas) ou pour demander une fonctionnalité, consultez la [liste des issues] (https://github.com/Robinlovelace/geocompr/issues).Les mainteneurs et les contributeurs doivent suivre les règles de conduite de ce dépôt : CODE CONDUCT.","code":""},{"path":"index.html","id":"reproducibilité","chapter":"Bienvenue!","heading":"Reproducibilité","text":"Le moyen le plus rapide de reproduire le contenu du livre si vous êtes novice en matière de données géographiques avec R peut être via le navigateur web, grâce à Binder.\nEn cliquant sur le lien ci-dessous, vous ouvrirez une nouvelle fenêtre contenant RStudio Server dans votre navigateur Web, ce qui vous permettra d’ouvrir les fichiers du chapitre et d’exécuter des morceaux de code pour vérifier que le code est reproductible.Si vous voyez quelque chose comme l’image ci-dessous, félicitations, cela fonctionné et vous pouvez commencer à explorer la géocomputation avec R dans un environnement cloud.(tout en étant conscient des consignes d’utilisation de mybinder.org):\nFIGURE 0.1: Capture d’écran du code reproductible contenu dans Geocomputation avec R s’exécutant dans RStudio Server sur un navigateur servi par Binder.\nPour reproduire le code du livre sur votre propre ordinateur, vous avez besoin d’une version récente de R et des paquets à jour.\nIls peuvent être installés en utilisant le paquet remotes.Après avoir installé les dépendances du livre, vous pouvez reconstruire le livre à des fins de test et d’enseignement.\nPour ce faire, vous devez télécharger et déziper ou cloner le code source du libre.\nAprès avoir ouvert le projet geocompr.Rproj dans RStudio (ou ouvert le dossier dans un autre IDE tel que VS Code), vous devriez être en mesure de reproduire le contenu avec la commande suivante :La page GitHub repo contient plus de détail pour reproduire ce livre.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"geocompr/geocompkg\")\nbookdown::serve_book(\".\")"},{"path":"index.html","id":"soutenir-le-projet","chapter":"Bienvenue!","heading":"Soutenir le projet","text":"Si vous trouvez ce livre utile (sa traduction ou sa version originale), vous pouvez le soutenir :En en parlant à d’autres personnesEn communiquant sur le livre dans les réseaux sociaux, par exemple, via #geocompr hashtag sur Twitter (cf. notre Guestbook sur geocompr.github.io) ou en référençant les cours courses mobilisant le livreLe citant ou le metre en lien‘Starring’ le dépôt GitHub geocomprEcrivant un recension, sur Amazon ou GoodreadsPosant des questions ou faire des suggestions de contenus sur GitHub ou Twitter.Achetant une copiePlus de détails sur le github.com/Robinlovelace/geocompr.L’icône du globe utilisé en couverture de ce livre été créé par Jean-Marc Viglino et est sous licence CC-4.0 International.","code":""},{"path":"foreword-1st-edition.html","id":"foreword-1st-edition","chapter":"Foreword (1st Edition)","heading":"Foreword (1st Edition)","text":"‘spatial’ R always broad, seeking provide integrate tools geography, geoinformatics, geocomputation spatial statistics anyone interested joining : joining asking interesting questions, contributing fruitful research questions, writing improving code.\n, ‘spatial’ R always included open source code, open data reproducibility.‘spatial’ R also sought open interaction many branches applied spatial data analysis, also implement new advances data representation methods analysis expose cross-disciplinary scrutiny.\nbook demonstrates, often alternative workflows similar data similar results, may learn comparisons others create understand workflows.\nincludes learning similar communities around Open Source GIS complementary languages Python, Java .R’s wide range spatial capabilities never evolved without people willing share creating adapting.\nmight include teaching materials, software, research practices (reproducible research, open data), combinations .\nR users also benefitted greatly ‘upstream’ open source geo libraries GDAL, GEOS PROJ.book clear example , curious willing join , can find things need match aptitudes.\nadvances data representation workflow alternatives, ever increasing numbers new users often without applied quantitative command-line exposure, book kind really needed.\nDespite effort involved, authors supported pressing forward publication., fresh book ready go; authors tried many tutorials workshops, readers instructors able benefit knowing contents continue tried people like .\nEngage authors wider R-spatial community, see value choice building workflows important, enjoy applying learn things care .Roger BivandBergen, September 2018","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"who-this-book-is-for","chapter":"Preface","heading":"Who this book is for","text":"book people want analyze, visualize model geographic data open source software.\nbased R, statistical programming language powerful data processing, visualization geospatial capabilities.\nbook covers wide range topics interest wide range people many different backgrounds, especially:People learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):\n\nadvent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.\nPeople learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):advent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.Graduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceGraduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningThe book designed intermediate--advanced R users interested geocomputation R beginners prior experience geographic data.\nnew R geographic data, discouraged: provide links materials describe nature spatial data beginner’s perspective Chapter 2 links provided .","code":""},{"path":"preface.html","id":"how-to-read-this-book","chapter":"Preface","heading":"How to read this book","text":"book divided three parts:Part : Foundations, aimed getting --speed geographic data R.Part II: Extensions, covers advanced techniques.Part III: Applications, real-world problems.chapters get progressively harder recommend reading book order.\nmajor barrier geographical analysis R steep learning curve.\nchapters Part aim address providing reproducible code simple datasets ease process getting started.important aspect book teaching/learning perspective exercises end chapter.\nCompleting develop skills equip confidence needed tackle range geospatial problems.\nSolutions exercises, number extended examples, provided book’s supporting website, geocompr.github.io.Impatient readers welcome dive straight practical examples, starting Chapter 2.\nHowever, recommend reading wider context Geocomputation R Chapter 1 first.\nnew R, also recommend learning language attempting run code chunks provided chapter (unless ’re reading book understanding concepts).\nFortunately R beginners R supportive community developed wealth resources can help.\nparticularly recommend three tutorials: R Data Science (Grolemund Wickham 2016) Efficient R Programming (Gillespie Lovelace 2016), especially Chapter 2 (installing setting-R/RStudio) Chapter 10 (learning learn), introduction R (R Core Team, Smith, Team 2021).","code":""},{"path":"preface.html","id":"why-r","chapter":"Preface","heading":"Why R?","text":"Although R steep learning curve, command-line approach advocated book can quickly pay .\n’ll learn subsequent chapters, R effective tool tackling wide range geographic data challenges.\nexpect , practice, R become program choice geospatial toolbox many applications.\nTyping executing commands command-line , many cases, faster pointing--clicking around graphical user interface (GUI) desktop GIS.\napplications Spatial Statistics modeling R may realistic way get work done.outlined Section 1.2, many reasons using R geocomputation:\nR well-suited interactive use required many geographic data analysis workflows compared languages.\nR excels rapidly growing fields Data Science (includes data carpentry, statistical learning techniques data visualization) Big Data (via efficient interfaces databases distributed computing systems).\nFurthermore R enables reproducible workflow: sharing scripts underlying analysis allow others build-work.\nensure reproducibility book made source code available github.com/Robinlovelace/geocompr.\nfind script files code/ folder generate figures:\ncode generating figure provided main text book, name script file generated provided caption (see example caption Figure ??).languages Python, Java C++ can used geocomputation excellent resources learning geocomputation without R, discussed Section 1.3.\nNone provide unique combination package ecosystem, statistical capabilities, visualization options, powerful IDEs offered R community.\nFurthermore, teaching use one language (R) depth, book equip concepts confidence needed geocomputation languages.","code":""},{"path":"preface.html","id":"real-world-impact","chapter":"Preface","heading":"Real-world impact","text":"Geocomputation R equip knowledge skills tackle wide range issues, including scientific, societal environmental implications, manifested geographic data.\ndescribed Section 1.1, geocomputation using computers process geographic data:\nalso real-world impact.\ninterested wider context motivations behind book, read ; covered Chapter 1..","code":""},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"Acknowledgements","text":"","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introduction","heading":"1 Introduction","text":"book using power computers things geographic data.\nteaches range spatial skills, including: reading, writing manipulating geographic data; making static interactive maps; applying geocomputation solve real-world problems; modeling geographic phenomena.\ndemonstrating various geographic operations can linked, reproducible ‘code chunks’ intersperse prose, book also teaches transparent thus scientific workflow.\nLearning use wealth geospatial tools available R command line can exciting, creating new ones can truly liberating.\nUsing command-line driven approach taught throughout, programming techniques covered Chapter ??, can help remove constraints creativity imposed software.\nreading book completing exercises, therefore feel empowered strong understanding possibilities opened R’s impressive geographic capabilities, new skills solve real-world problems geographic data, ability communicate work maps reproducible code.last decades free open source software geospatial (FOSS4G) progressed astonishing rate.\nThanks organizations OSGeo, geographic data analysis longer preserve expensive hardware software: anyone can now download run high-performance spatial libraries.\nOpen source Geographic Information Systems (GIS), QGIS, made geographic analysis accessible worldwide.\nGIS programs tend emphasize graphical user interfaces (GUIs), unintended consequence discouraging reproducibility (although many can used command line ’ll see Chapter ??).\nR, contrast, emphasizes command line interface (CLI).\nsimplistic comparison different approaches illustrated Table 1.1.TABLE 1.1: Differences emphasis software packages (Graphical User Interface (GUI) Geographic Information Systems (GIS) R).book motivated importance reproducibility scientific research (see note ).\naims make reproducible geographic data analysis workflows accessible, demonstrate power open geospatial software available command-line.\n“Interfaces software part R” (Eddelbuettel Balamuta 2018).\nmeans addition outstanding ‘house’ capabilities, R allows access many spatial software libraries, explained Section 1.2 demonstrated Chapter ??.\ngoing details software, however, worth taking step back thinking mean geocomputation.Reproducibility major advantage command-line interfaces, mean practice?\ndefine follows: “process results can generated others using publicly accessible code.”","code":""},{"path":"intro.html","id":"what-is-geocomputation","chapter":"1 Introduction","heading":"1.1 What is geocomputation?","text":"Geocomputation young term, dating back first conference subject 1996.1\ndistinguished geocomputation (time) commonly used term ‘quantitative geography’, early advocates proposed, emphasis “creative experimental” applications (Longley et al. 1998) development new tools methods (Openshaw Abrahart 2000):\n“GeoComputation using various different types geodata developing relevant geo-tools within overall context ‘scientific’ approach.”\nbook aims go beyond teaching methods code; end able use geocomputational skills, “practical work beneficial useful” (Openshaw Abrahart 2000).approach differs early adopters Stan Openshaw, however, emphasis reproducibility collaboration.\nturn 21st Century, unrealistic expect readers able reproduce code examples, due barriers preventing access necessary hardware, software data.\nFast-forward two decades things progressed rapidly.\nAnyone access laptop ~4GB RAM can realistically expect able install run software geocomputation publicly accessible datasets, widely available ever (see Chapter ??).2\nUnlike early works field, work presented book reproducible using code example data supplied alongside book, R packages spData, installation covered Chapter 2.Geocomputation closely related terms including: Geographic Information Science (GIScience); Geomatics; Geoinformatics; Spatial Information Science; Geoinformation Engineering (Longley 2015); Geographic Data Science (GDS).\nterm shares emphasis ‘scientific’ (implying reproducible falsifiable) approach influenced GIS, although origins main fields application differ.\nGDS, example, emphasizes ‘data science’ skills large datasets, Geoinformatics tends focus data structures.\noverlaps terms larger differences use geocomputation rough synonym encapsulating :\nseek use geographic data applied scientific work.\nUnlike early users term, however, seek imply cohesive academic field called ‘Geocomputation’ (‘GeoComputation’ Stan Openshaw called ).\nInstead, define term follows: working geographic data computational way, focusing code, reproducibility modularity.Geocomputation recent term influenced old ideas.\ncan seen part Geography, 2000+ year history (Talbert 2014);\nextension Geographic Information Systems (GIS) (Neteler Mitasova 2008), emerged 1960s (Coppock Rhind 1991).Geography played important role explaining influencing humanity’s relationship natural world long invention computer, however.\nAlexander von Humboldt’s travels South America early 1800s illustrates role:\nresulting observations lay foundations traditions physical plant geography, also paved way towards policies protect natural world (Wulf 2015).\nbook aims contribute ‘Geographic Tradition’ (Livingstone 1992) harnessing power modern computers open source software.book’s links older disciplines reflected suggested titles book: Geography R R GIS.\nadvantages.\nformer conveys message comprises much just spatial data:\nnon-spatial attribute data inevitably interwoven geometry data, Geography something map.\nlatter communicates book using R GIS, perform spatial operations geographic data (Bivand, Pebesma, Gómez-Rubio 2013).\nHowever, term GIS conveys connotations (see Table 1.1) simply fail communicate one R’s greatest strengths:\nconsole-based ability seamlessly switch geographic non-geographic data processing, modeling visualization tasks.\ncontrast, term geocomputation implies reproducible creative programming.\ncourse, (geocomputational) algorithms powerful tools can become highly complex.\nHowever, algorithms composed smaller parts.\nteaching foundations underlying structure, aim empower create innovative solutions geographic data problems.","code":""},{"path":"intro.html","id":"why-use-r-for-geocomputation","chapter":"1 Introduction","heading":"1.2 Why use R for geocomputation?","text":"Early geographers used variety tools including barometers, compasses sextants advance knowledge world (Wulf 2015).\ninvention marine chronometer 1761 became possible calculate longitude sea, enabling ships take direct routes.Nowadays lack geographic data hard imagine.\nEvery smartphone global positioning (GPS) receiver multitude sensors devices ranging satellites semi-autonomous vehicles citizen scientists incessantly measure every part world.\nrate data produced overwhelming.\nautonomous vehicle, example, can generate 100 GB data per day (Economist 2016).\nRemote sensing data satellites become large analyze corresponding data single computer, leading initiatives OpenEO.‘geodata revolution’ drives demand high performance computer hardware efficient, scalable software handle extract signal noise, understand perhaps change world.\nSpatial databases enable storage generation manageable subsets vast geographic data stores, making interfaces gaining knowledge vital tools future.\nR one tool, advanced analysis, modeling visualization capabilities.\ncontext focus book language (see Wickham 2019).\nInstead use R ‘tool trade’ understanding world, similar Humboldt’s use tools gain deep understanding nature complexity interconnections (see Wulf 2015).\nAlthough programming can seem like reductionist activity, aim teach geocomputation R fun, understanding world.R multi-platform, open source language environment statistical computing graphics (r-project.org/).\nwide range packages, R also supports advanced geospatial statistics, modeling visualization.\n\nNew integrated development environments (IDEs) RStudio made R user-friendly many, easing map making panel dedicated interactive visualization.core, R object-oriented, functional programming language (Wickham 2019), specifically designed interactive interface software (Chambers 2016).\nlatter also includes many ‘bridges’ treasure trove GIS software, ‘geolibraries’ functions (see Chapter ??).\nthus ideal quickly creating ‘geo-tools’, without needing master lower level languages (compared R) C, FORTRAN Java (see Section 1.3).\n\ncan feel like breaking free metaphorical ‘glass ceiling’ imposed GUI-based proprietary geographic information systems (see Table 1.1 definition GUI).\nFurthermore, R facilitates access languages:\npackages Rcpp reticulate enable access C++ Python code, example.\nmeans R can used ‘bridge’ wide range geospatial programs (see Section 1.3).Another example showing R’s flexibility evolving geographic capabilities interactive map making.\n’ll see Chapter ??, statement R “limited interactive [plotting] facilities” (Bivand, Pebesma, Gómez-Rubio 2013) longer true.\ndemonstrated following code chunk, creates Figure 1.1 (functions generate plot covered Section ??).\nFIGURE 1.1: blue markers indicate authors . basemap tiled image Earth night provided NASA. Interact online version geocompr.robinlovelace.net, example zooming clicking popups.\ndifficult produce Figure 1.1 using R years ago, let alone interactive map.\nillustrates R’s flexibility , thanks developments knitr leaflet, can used interface software, theme recur throughout book.\nuse R code, therefore, enables teaching geocomputation reference reproducible examples representing real world phenomena, rather just abstract concepts.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(lng = c(-3, 23, 11),\n             lat = c(52, 53, 49), \n             popup = popup)"},{"path":"intro.html","id":"software-for-geocomputation","chapter":"1 Introduction","heading":"1.3 Software for geocomputation","text":"R powerful language geocomputation many options geographic data analysis providing thousands geographic functions.\nAwareness languages geocomputation help decide different tool may appropriate specific task, place R wider geospatial ecosystem.\nsection briefly introduces languages C++, Java Python geocomputation, preparation Chapter ??.important feature R (Python) interpreted language.\nadvantageous enables interactive programming Read–Eval–Print Loop (REPL):\ncode entered console immediately executed result printed, rather waiting intermediate stage compilation.\nhand, compiled languages C++ Java tend run faster (compiled).C++ provides basis many GIS packages QGIS, GRASS SAGA sensible starting point.\nWell-written C++ fast, making good choice performance-critical applications processing large geographic datasets, harder learn Python R.\nC++ become accessible Rcpp package, provides good ‘way ’ C programming R users.\nProficiency low-level languages opens possibility creating new, high-performance ‘geoalgorithms’ better understanding GIS software works (see Chapter ??).Java another important versatile language geocomputation.\nGIS packages gvSig, OpenJump uDig written Java.\nmany GIS libraries written Java, including GeoTools JTS, Java Topology Suite (GEOS C++ port JTS).\nFurthermore, many map server applications use Java including Geoserver/Geonode, deegree 52°North WPS.Java’s object-oriented syntax similar C++.\nmajor advantage Java platform-independent (unusual compiled language) highly scalable, making suitable language IDEs RStudio, book written.\nJava fewer tools statistical modeling visualization Python R, although can used data science (Brzustowicz 2017).Python important language geocomputation especially many Desktop GIS GRASS, SAGA QGIS provide Python API (see Chapter ??).\nLike R, popular tool data science.\nlanguages object-oriented, many areas overlap, leading initiatives reticulate package facilitates access Python R Ursa Labs initiative support portable libraries benefit entire open source data science ecosystem.practice R Python strengths extent use less important domain application communication results.\nLearning either provide head-start learning .\nHowever, major advantages R Python geocomputation.\nincludes much better support geographic data models vector raster language (see Chapter 2) corresponding visualization possibilities (see Chapters 2 ??).\nEqually important, R unparalleled support statistics, including spatial statistics, hundreds packages (unmatched Python) supporting thousands statistical methods.major advantage Python general-purpose programming language.\nused many domains, including desktop software, computer games, websites data science.\nPython often shared language different (geocomputation) communities can seen ‘glue’ holds many GIS programs together.\nMany geoalgorithms, including QGIS ArcMap, can accessed Python command line, making well-suited starter language command-line GIS.3For spatial statistics predictive modeling, however, R second--none.\nmean must choose either R Python: Python supports common statistical techniques (though R tends support new developments spatial statistics earlier) many concepts learned Python can applied R world.\n\n\nLike R, Python also supports geographic data analysis manipulation packages osgeo, Shapely, NumPy PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"r-ecosystem","chapter":"1 Introduction","heading":"1.4 R’s spatial ecosystem","text":"many ways handle geographic data R, dozens packages area.4\nbook endeavor teach state---art field whilst ensuring methods future-proof.\nLike many areas software development, R’s spatial ecosystem rapidly evolving (Figure 1.2).\nR open source, developments can easily build previous work, ‘standing shoulders giants’, Isaac Newton put 1675.\napproach advantageous encourages collaboration avoids ‘reinventing wheel’.\npackage sf (covered Chapter 2), example, builds predecessor sp.surge development time (interest) ‘R-spatial’ followed award grant R Consortium development support Simple Features, open-source standard model store access vector geometries.\nresulted sf package (covered Section ??).\nMultiple places reflect immense interest sf.\nespecially true R-sig-Geo Archives, long-standing open access email list containing much R-spatial wisdom accumulated years.\nFIGURE 1.2: Downloads selected R packages working geographic data. y-axis shows average number downloads per day, within 91-day rolling window.\nnoteworthy shifts wider R community, exemplified data processing package dplyr (released 2014) influenced shifts R’s spatial ecosystem.\nAlongside packages shared style emphasis ‘tidy data’ (including, e.g., ggplot2), dplyr placed tidyverse ‘metapackage’ late 2016.\n\n\ntidyverse approach, focus long-form data fast intuitively named functions, become immensely popular.\nled demand ‘tidy geographic data’ partly met sf.\nobvious feature tidyverse tendency packages work harmony.\n\n\nequivalent geoverse, attempts harmonization packages hosted r-spatial organization growing number packages use sf (Table 1.2).TABLE 1.2: top 5 downloaded packages depend sf, terms average number downloads per day previous month. 2021-11-19 289 packages import sf.Parallel group developments relates rspatial set packages.5\nmain member terra package spatial raster handling (see Section ??).","code":""},{"path":"intro.html","id":"the-history-of-r-spatial","chapter":"1 Introduction","heading":"1.5 The history of R-spatial","text":"many benefits using recent spatial packages sf, also important aware history R’s spatial capabilities: many functions, use-cases teaching material contained older packages.\ncan still useful today, provided know look.\n\nR’s spatial capabilities originated early spatial packages S language (Bivand Gebhardt 2000).\n\n1990s saw development numerous S scripts handful packages spatial statistics.\nR packages arose 2000 R packages various spatial methods “point pattern analysis, geostatistics, exploratory spatial data analysis spatial econometrics”, according article presented GeoComputation 2000 (Bivand Neteler 2000).\n, notably spatial, sgeostat splancs still available CRAN (B. S. Rowlingson Diggle 1993; B. Rowlingson Diggle 2017; Venables Ripley 2002; Majure Gebhardt 2016).subsequent article R News (predecessor R Journal) contained overview spatial statistical software R time, much based previous code written S/S-PLUS (Ripley 2001).\noverview described packages spatial smoothing interpolation, including akima geoR (Akima Gebhardt 2016; Jr Diggle 2016), point pattern analysis, including splancs (B. Rowlingson Diggle 2017) spatstat (Baddeley, Rubak, Turner 2015).following R News issue (Volume 1/3) put spatial packages spotlight , detailed introduction splancs commentary future prospects regarding spatial statistics (Bivand 2001).\nAdditionally, issue introduced two packages testing spatial autocorrelation eventually became part spdep (Bivand 2017).\nNotably, commentary mentions need standardization spatial interfaces, efficient mechanisms exchanging data GIS, handling spatial metadata coordinate reference systems (CRS).maptools (written Nicholas Lewin-Koh; Bivand Lewin-Koh (2017)) another important package time.\nInitially maptools just contained wrapper around shapelib permitted reading ESRI Shapefiles geometry nested lists.\ncorresponding nowadays obsolete S3 class called “Map” stored list alongside attribute data frame.\nwork “Map” class representation nevertheless important since directly fed sp prior publication CRAN.2003 Roger Bivand published extended review spatial packages.\nproposed class system support “data objects offered GDAL”, including ‘fundamental’ point, line, polygon, raster types.\nFurthermore, suggested interfaces external libraries form basis modular R packages (Bivand 2003).\nlarge extent ideas realized packages rgdal sp.\nprovided foundation spatial data analysis R, described Applied Spatial Data Analysis R (ASDAR) (Bivand, Pebesma, Gómez-Rubio 2013), first published 2008.\nTen years later, R’s spatial capabilities evolved substantially still build ideas set-Bivand (2003):\ninterfaces GDAL PROJ, example, still power R’s high-performance geographic data /O CRS transformation capabilities (see Chapters ?? ??, respectively).rgdal, released 2003, provided GDAL bindings R greatly enhanced ability import data previously unavailable geographic data formats.\ninitial release supported raster drivers subsequent enhancements provided support coordinate reference systems (via PROJ library), reprojections import vector file formats (see Chapter ?? file formats).\nMany additional capabilities developed Barry Rowlingson released rgdal codebase 2006 (see B. Rowlingson et al. 2003 R-help email list context).sp, released 2005, overcame R’s inability distinguish spatial non-spatial objects (Pebesma Bivand 2005).\nsp grew workshop Vienna 2003 hosted sourceforge migrating R-Forge.\nPrior 2005, geographic coordinates generally treated like number.\nsp changed classes generic methods supporting points, lines, polygons grids, attribute data.sp stores information bounding box, coordinate reference system attributes slots Spatial objects using S4 class system,\nenabling data operations work geographic data (see Section ??).\n, sp provides generic methods summary() plot() geographic data.\nfollowing decade, sp classes rapidly became popular geographic data R number packages depended increased around 20 2008 100 2013 (Bivand, Pebesma, Gómez-Rubio 2013).\n2018 almost 500 packages rely sp, making important part R ecosystem.\nProminent R packages using sp include: gstat, spatial spatio-temporal geostatistics; geosphere, spherical trigonometry; adehabitat used analysis habitat selection animals (Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).rgdal sp solved many spatial issues, R still lacked ability geometric operations (see Chapter ??).\nColin Rundel addressed issue developing rgeos, R interface open-source geometry library (GEOS) Google Summer Code project 2010 (Bivand Rundel 2018).\nrgeos enabled GEOS manipulate sp objects, functions gIntersection().Another limitation sp — restricted support raster data — overcome raster, first released 2010 (Hijmans 2017).\nclass system functions support range raster operations outlined Section ??.\nkey feature raster ability work datasets large fit RAM (R’s interface PostGIS supports -disk operations vector geographic data).\nraster also supports map algebra (see Section ??).parallel developments class systems methods came support R interface dedicated GIS software.\nGRASS (Bivand 2000) follow-packages spgrass6 rgrass7 (GRASS GIS 6 7, respectively) prominent examples direction (Bivand 2016a, 2016b).\nexamples bridges R GIS include RSAGA (Brenning, Bangs, Becker 2018, first published 2008), RPyGeo (Brenning 2012, first published 2008), RQGIS (Muenchow, Schratz, Brenning 2017, first published 2016), rqgisprocess (see Chapter ??).\n\nVisualization focus initially, bulk R-spatial development focused analysis geographic operations.\nsp provided methods map making using base lattice plotting system demand growing advanced map making capabilities.\nRgoogleMaps first released 2009, allowed overlay R spatial data top ‘basemap’ tiles online services Google Maps OpenStreetMap (Loecher Ropkins 2015).\n\nfollowed ggmap package added similar ‘basemap’ tiles capabilities ggplot2 (Kahle Wickham 2013).\nThough ggmap facilitated map-making ggplot2, utility limited need fortify spatial objects, means converting long data frames.\nworks well points computationally inefficient lines polygons, since coordinate (vertex) converted row, leading huge data frames represent complex geometries.\nAlthough geographic visualization tended focus vector data, raster visualization supported raster received boost release rasterVis, described book subject spatial temporal data visualization (Lamigueiro 2018).\n2018 map making R hot topic dedicated packages tmap, leaflet mapview supporting class system provided sf, focus next chapter (see Chapter ?? visualization).Since 2018, movement modernizing basic R packages related handling spatial data continued.\n\nterra – successor raster package aimed better performance straightforward user interface firstly released (see Chapter ??) 2020 (Hijmans 2021).\nmid-2021, significant change made sf package incorporating spherical geometry calculations.\nSince change, default, many spatial operations data geographic CRSs apply C++ s2geometry library’s spherical geometry algorithms, types operations data projected CRSs still using GEOS.\n\n\nNew ideas spatial data representations also developed period.\n\n\nincludes stars package, closely connected sf, handling raster vector data cubes (Pebesma 2021) lidR processing airborne LiDAR (Light Detection Ranging) point clouds (Roussel et al. 2020).modernization several reasons, including emergence new technologies standard, impacts spatial software development outside R environment (Bivand 2021).\nimportant external factor affecting spatial software, including R spatial packages, major updates, including many breaking changes PROJ library begun 2018.\nimportantly, changes forced replacement proj4string WKT representation storage coordinate reference systems coordinates operations (learn Section 2.4 Chapter ??).\nSince 2018, progress spatial visualization tools R related factors.\nFirstly, new types spatial plots developed, including rayshader package offering combination raytracing multiple hill-shading methods produce 2D 3D data visualizations (Morgan-Wall 2021).\n\nSecondly, ggplot2 gained new spatial capabilities, mostly thanks ggspatial package adds spatial visualization elements, including scale bars north arrows (Dunnington 2021) gganimate enables smooth customizable spatial animations (Pedersen Robinson 2020).\nThirdly, performance visualizing large spatial dataset improved.\nespecially relates automatic plotting downscaled rasters tmap possibility using high-performance interactive rendering platforms mapview package, \"leafgl\" \"mapdeck\".\nLastly, existing mapping tools rewritten minimize dependencies, improve user interface, allow easier creation extensions.\nincludes mapsf package (successor cartography) (Giraud 2021) version 4 tmap package, internal code revised.late 2021, planned retirement rgdal, rgeos maptools end 2023 announced R-sig-Geo mailing list Roger Bivand.\nlarge impact existing workflows applying packages, also influence packages depend rgdal, rgeos maptools.\nTherefore, Bivand’s suggestion plan transition modern tools, including sf terra, explained book’s next chapters.","code":""},{"path":"intro.html","id":"exercises","chapter":"1 Introduction","heading":"1.6 Exercises","text":"E1. Think terms ‘GIS’, ‘GDS’ ‘geocomputation’ described . () best describes work like using geo* methods software ?E2. Provide three reasons using scriptable language R geocomputation instead using graphical user interface (GUI) based GIS QGIS.E3. Think real world problem like solve geographic data help people living local area sketch map geographic processes involved.E4. Consider datasets needed represent problem computationally sketch workflow processing , resulting outputs help inform decision making related problem thought previous exercise. Use pen paper digital sketching tool Excalidraw.","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 La donnée géographique dans R","heading":"2 La donnée géographique dans R","text":"","code":""},{"path":"spatial-class.html","id":"prérequis","chapter":"2 La donnée géographique dans R","heading":"Prérequis","text":"C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué.\nNous supposons que vous avez installé une version à jour de R et que vous êtes à l’aise avec les logiciels dotés d’une interface de ligne de commande, comme l’environnement de développement intégré (IDE) RStudio.\nSi vous débutez avec R, nous vous recommandons de lire le chapitre 2 du livre en ligne Efficient R Programming de Gillespie Lovelace (2016) et d’apprendre les bases du langage en vous référant à des ressources telles que Grolemund Wickham (2016).\nOrganisez votre travail (par exemple, avec des projets RStudio) et donnez aux scripts des noms judicieux tels que 02-chapter.R pour documenter le code que vous écrivez au fur et à mesure de votre apprentissage.\nLes paquets utilisés dans ce chapitre peuvent être installés à l’aide des commandes suivantes :6Tous les paquets nécessaires pour reproduire le contenu du livre peuvent être installés via la commande suivante : remotes::install_github(\"geocompr/geocompkg\").\nLes paquets nécessaires peuvent être “chargés” (techniquement, ils sont attachés) avec la fonction library() :Conformemant à la section ??, la sortie de library(sf) mentionne les versions des bibliothèques géographiques clés, comme GEOS, utilisées par ce paquet.Les autres paquets installés contiennent des données qui seront utilisées dans le livre:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # classes et fonctions pour les données vectorielles\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE\nlibrary(terra)      # classes et fonctions pour les données rasters\nlibrary(spData)        # chargement de données geographiques\nlibrary(spDataLarge)   # chargement de données geographiques plus volumineuses"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 La donnée géographique dans R","heading":"2.1 Introduction","text":"Ce chapitre fournit de brèves explications sur les modèles fondamentaux des données géographiques : vecteur et raster.\nNous présenterons la théorie qui sous-tend chaque modèle de données et les disciplines dans lesquelles ils prédominent, avant de démontrer leur mise en œuvre dans R.Le modèle de données vectoriel représente le monde à l’aide de points, de lignes et de polygones.\nCeux-ci ont des frontières discrètes et bien définies, ce qui signifie que les ensembles de données vectorielles ont généralement un haut niveau de précision (mais pas nécessairement d’exactitude, comme nous le verrons dans la section @ref(unités)).\nLe modèle de données raster divise la surface en pixel de taille constante.\nLes données rasters sont la base des images d’arrière-plan utilisées dans les cartes Web et constituent une source essentielle de données géographiques depuis les débuts de la photographie aérienne et des dispositifs de télédétection par satellite.\nLes rasters agrègent spatialement des informations à une résolution donnée. Ils maintiennent aisni une consistance temporelle sur de grandes superficies (de nombreux jeux de données rasters sont disponibles à l’echelle planetaire).Que faut-il utiliser ?\nLa réponse dépend probablement de votre domaine d’application :Les données vectorielles ont tendance à dominer les sciences sociales parce que les constructions humains ont tendance à avoir des frontières discrètes.Les données rasters dominent de nombreuses sciences de l’environnement en raison de la dépendance aux données de télédétection.Il y beaucoup de chevauchement dans certains domaines et les ensembles de données rasters et vectorielles peuvent être utilisés conjointement :\nles écologistes et les démographes, par exemple, utilisent couramment les deux.\nEn outre, il est possible de le convertir (voir la section ??).\nQue votre travail mobilise plus un type de jeux de données, vectorielles ou rasters, il reste utile de comprendre leurs modèles de données sous-jacents pour bien les utiliser, comme nous le verrons dans les chapitres suivants.\nCe livre utilise les paquets sf et terra pour travailler, respectivement, avec des données vectorielles et des jeux de données raster.","code":""},{"path":"spatial-class.html","id":"données-vectorielles","chapter":"2 La donnée géographique dans R","heading":"2.2 Données vectorielles","text":"Le modèle de données géographiques vectorielles est basé sur des points situés dans un système de coordonnées et de référence (SCR).\nLes points peuvent représenter des caractéristiques propres (par exemple, l’emplacement d’un arrêt de bus) ou être reliés entre eux pour former des géométries plus complexes telles que des lignes et des polygones.\nLa plupart des géométries construites avec des points ne sont qu’en deux dimensions (les CRS tridimensionnels contiennent une valeur supplémentaire \\(z\\), représentant généralement la hauteur au-dessus du niveau de la mer).Dans ce système, Londres, par exemple, peut être représentée par les coordonnées c(-0,1, 51,5).\nCela signifie que sa position est -0,1 degré est et 51,5 degrés nord par rapport au point d’origine.\nCe dernier se situe à 0 degré de longitude (le méridien d’origine) et à 0 degré de latitude (l’équateur) dans un SCR géographique (‘long/lat’) (Figure 2.1, panneau de gauche).\nCette même localisation pourrait également être approximé dans un SCR projeté avec des valeurs “Est/Nord” de c(530000, 180000) dans le [British National Grid] (https://en.wikipedia.org/wiki/Ordnance_Survey_National_Grid), ce qui signifie que Londres est située à 530 km Est et 180 km Nord de l’origine du SCR.\nCeci peut être vérifié visuellement : un peu plus de 5 “boîtes” — des zones carrées délimitées par les lignes de grille grises de 100 km de large — séparent le point représentant Londres de l’origine (Figure 2.1, panneau de droite).L’emplacement de l’origine de la grille Nationale, dans la mer au-delà de la péninsule du sud-ouest de l’Angleterre, garantit que la plupart des lieux du Royaume-Uni auront des valeurs positives en abscisse et ordonnée.7\nLes SCR sont plus complexes, et seront abordées plus en détail dans les sections 2.4 et ??. Cependant pour les besoins de cette section, il suffit de savoir que les coordonnées consistent en deux nombres représentant la distance par rapport à un point d’origine, généralement dans les dimensions \\(x\\) puis \\(y\\).\nFIGURE 2.1: Représentation de données vectorielles (ponctuelles) dans laquelle l’emplacement de Londres (X rouge) est représenté par rapport à une origine (le cercle bleu). La carte de gauche représente un SCR géographique dont l’origine se situe à 0° de longitude et de latitude. Le graphique de droite représente un SCR projeté dont l’origine est située dans la mer à l’ouest de la péninsule du sud-ouest anglaise.\nsf fournis des classes informatiques pour les données géographiques vectorielles ainsi qu’une interface en ligne de commande pour des bibliothèques de géocomputation de bas niveau :GDAL, pour la lecture, l’écriture et la manipulation d’une large gamme de formats de données géographiques, couverte dans le chapitre ??PROJ, une puissante bibliothèque pour les transformations de systèmes de coordonnées, qui sous-tend le chapitre ??GEOS, un moteur de géométrie éuclidienne pour les opérations telles que le calcul des tampons et des centroïdes sur les données avec un SCR projeté, couvert dans le chapitre ??S2, un moteur de géométrie sphérique écrit en C++ développé par Google, via le paquet s2, couvert dans la section 2.2.9 ci-dessous et dans le chapitre ??.\nLes informations concernant ces interfaces sont indiquées par sf lorsque que celui ci est chargé pour la première fois: via le message Linking GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() TRUE apparue en dessous de ;commande library(sf) au tout début de ce chapitre. Ce message indique les versions des bibliothèques liées GEOS, GDAL et PROJ (chiffre pouvant varier au cours du temps et entre les ordinateurs) et si oui ou non l’interface avec S2 est activée.\nAujourd’hui, nous considérons que c’est un acquis, cependant, c’est grâce à l’intégration étroite entre les différentes bibliothèques géographiques qu’un travail de géocomputation reproductible est possible.Une fonctionnalité intéressante de sf est que vous pouvez changer le moteur de géométrie par défaut utilisé sur les données non projetées : “Désactiver” S2 peut être fait avec la commande sf::sf_use_s2(\"FALSE\"), ce qui signifie que le moteur de géométrie euclidienne GEOS sera utilisé par défaut pour toutes les opérations de géométrie, y compris celles sur les données non projetées.\nComme nous le verrons dans la Section 2.2.9, la géométrie euclidienne, ou plane, est basée sur un espace à 2 dimensions.\nLes moteurs de géométrie euclidienne tels que GEOS supposent des coordonnées “plates” (projetées), tandis que les moteurs de géométrie sphérique tels que S2 supposent des coordonnées non projetées (lon/lat).Cette section présente les classes sf en préparation des chapitres suivants (les chapitres ?? et ?? couvrent respectivement l’interface GEOS et GDAL)","code":""},{"path":"spatial-class.html","id":"une-introduction-aux-simple-features","chapter":"2 La donnée géographique dans R","heading":"2.2.1 Une introduction aux Simple Features","text":"Simple features est un Format ouvert développé et approuvé par l’Open Geospatial Consortium (OGC), une organisation à non lucratif dont nous reviendrons sur les activités dans un chapitre ultérieur (section ??).\n\nSimple Features est un modèle de données hiérarchique qui représente un large éventail de types géométriques.\nSur les 18 types géométriques pris en charge par la spécification, seuls 7 sont utilisés dans la grande majorité des recherches géographiques (voir Figure 2.2) ;\nces types géométriques de base sont entièrement pris en charge par le paquet R sf (Pebesma 2018).8\nFIGURE 2.2: Les types de Simple features pleinement disponibles dans sf.\nsf peut représenter tous les types de géométrie vectorielle courants (les classes de données raster ne sont pas prises en charge par sf) : points, lignes, polygones et leurs versions “multi” respectives (qui regroupent les caractéristiques du même type en une seule caractéristique).\n\n\nsf prend également en charge les collections de géométrie, qui peuvent contenir plusieurs types de géométrie dans un seul objet.\nsf fournit la même fonctionnalité (et plus) que celle fournie précédemment dans trois packages — sp pour les classes de données (Pebesma Bivand 2018), rgdal pour la lecture/écriture de données via une interface avec GDAL et PROJ (Bivand, Keitt, Rowlingson 2018) et rgeos pour les opérations spatiales via une interface avec GEOS (Bivand Rundel 2018).Pour réitérer le message du chapitre 1, les paquets géographiques de Ront une longue histoire d’interfaçage avec des bibliothèques de plus bas inférieur, et sf poursuit cette tradition avec une interface unifiée vers les versions récentes de GEOS pour les opérations de géométrie, la bibliothèque GDAL pour la lecture et l’écriture de fichiers de données géographiques, et la bibliothèque PROJ pour la représentation et la transformation des systèmes de référence de coordonnées projetées.\nGrâce à s2,\n\n\n“une interface avec la bibliothèque de géométrie sphérique de Google [s2] (https://s2geometry.io/), sf également accès à des”mesures et opérations sur des géométries non planes” rapides et précises” (Bivand 2021).\nDepuis la version 1.0.0 de sf, lancée en juin 2021, la fonctionnalité s2 est maintenant utilisée par défaut sur les géométries avec des systèmes de coordonnées géographiques (longitude/latitude), une caractéristique unique de sf qui diffère des bibliothèques spatiales ne prenant en charge que GEOS pour les opérations de géométrie, comme le paquet Python GeoPandas.\nNous aborderons s2 dans les chapitres suivants.\n\nLa capacité de sf à intégrer plusieurs bibliothèques puissantes pour la géoinformatique dans un seul cadre est une réalisation remarquable qui réduit le “coût d’entrée” dans le monde de l’analyse reproductible des données géographiques avec des bibliothèques performantes.\nLa fonctionnalité de sf est bien documentée sur son site web à l’adresse [r-spatial.github.io/sf/] (https://r-spatial.github.io/sf/index.html) qui contient 7 vignettes.\nCelles-ci peuvent être visualisées hors ligne comme suit :Comme l’explique la première vignette, les objets de type simples features dans R sont stockés dans un tableau de données, les données géographiques occupant une colonne spéciale, généralement nommée “geom” ou “geometry”.\nNous allons utiliser le jeu de données world fourni par la bibliothèque spData, chargé au début de ce chapitre, pour montrer ce que sont les objets sf et comment ils fonctionnent.\nworld est un “tableau de données sf” contenant des colonnes spatiales et attributaires, dont les noms sont retournés par la fonction names() (la dernière colonne dans cet exemple contient les informations géographiques) :Le contenu de cette colonne geom donne aux objets sf leurs proprités spatialles : world$geom est une ‘colonne de type liste’ qui contient toutes les coordonnées des polygones du pays.\n\nLes objets sf peuvent être tracés rapidement avec la fonction de base de R, plot() ;\nla commande suivante crée la figure 2.3.\nFIGURE 2.3: Cartes du monde utilisant le paquet sf, avec une dimension pour chaque attribut.\nNotez qu’au lieu de créer une seule carte par défaut pour les objets géographiques, comme le font la plupart des programmes SIG, la fonction plot() sur des objets sf retourne une carte pour chaque variable du jeux de données.\nCe comportement peut être utile pour explorer la distribution spatiale de différentes variables et est abordé plus en détail dans la section 2.2.3.Plus largement, traiter les objets géographiques comme des tableaux de données classiques avec des propriétés spatiales présente de nombreux avantages, surtout si vous avez déjà l’habitude de travailler avec des tableaux de données.\nPar exemple, la fonction très pratique summary(), fournit un aperçu utile des variables de l’objet world.Bien que nous n’ayons sélectionné qu’une seule variable pour la commande summary(), elle produit également un rapport sur la géométrie.\nCela démontre le comportement “permanent” des colonnes de type géométrie des objets sf, cela signifie que la géométrie est conservée à moins que l’utilisateur ne la supprime délibérément, comme nous le verrons dans la Section ??.\nLe résultat fournit un résumé rapide des données spatiales et non spatiales contenues dans world : l’espérance de vie moyenne est de 71 ans (allant de moins de 51 ans à plus de 83 ans avec une médiane de 73 ans) pour tous les pays.Il est important d’examiner de plus près le comportement de base et le contenu de cet objet simple feature, que l’peut utilement considérer comme un “spatial data frames”.Les objets sf sont faciles à extraire: le code ci-dessous extrait ses deux premières lignes et trois premières colonnes de world.\nLa sortie montre deux différences majeures par rapport à un data.frame standard : l’inclusion de données géographiques supplémentaires (geometry type, dimension, bbox et les informations SCR -epsg (SRID),proj4string) ainsi que la présence d'une colonnegeometry, ici nomméegeom` :Tout cela peut sembler assez complexe, surtout pour un système de classes qui est censé être simple.\nCependant, il y de bonnes raisons d’organiser les choses de cette façon et d’utiliser sf.Avant de décrire chaque type de géométrie géré par le paquet sf, il est utile de prendre un peu de recul pour comprendre les éléments constitutifs des objets de type sf.\nLa section 2.2.5 montre comment les objets simples features sont des tableau de données, avec des colonnes géométriques spéciales.\nCes colonnes spatiales sont souvent appelées geom ou geometry : ainsi world$geom fait référence à l’élément spatial de l’objet world décrit plus haut.\nCes colonnes géométriques sont des “colonnes de type liste” de la classe sfc (voir la section 2.2.7).\nPuis, à leur tour, les objets sfc sont composés d’un ou plusieurs objets de la classe sfg : des géométries simples features que nous décriverons dans la section 2.2.6.\n\nPour comprendre comment fonctionnent les composantes spatiales des simples features, il est essentiel de comprendre comment leurs géométries sont prises en comptes.\nC’est pourquoi nous couvrirons chacun des types de géométrie simples features actuellement pris en charge dans la section 2.2.4 puis nous continuerons en montrant comment ils peuvent être représentés dans R en utilisant avec des objets sf, formés à la base d’objets sfg et sfc.","code":"\nvignette(package = \"sf\") # Qu'elles sont les vignettes disponibles\nvignette(\"sf1\")          # Une introduction à la bibliothèque \nclass(world)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…Le morceau de code précédent utilise `=` pour créer un nouvel objet appelé `world_mini` dans la commande `world_mini = world[1:2, 1:3]`.\nC´est ce qu´on appelle une affectation.\nUne commande équivalente pour obtenir le même résultat est `world_mini <- world[1:2, 1:3]`.\nBien que l´affectation par flèche soit plus couramment utilisée, nous utilisons l´affectation par égalité parce qu´elle est légèrement plus rapide à taper et plus facile à enseigner en raison de sa compatibilité avec les langages couramment utilisés tels que Python et JavaScript.\nL´utilisation de l´un ou l´autre est une question de préférence, tant que vous êtes cohérent (des paquets tels que **styler** peuvent être utilisés pour changer de style)."},{"path":"spatial-class.html","id":"pourquoi-simple-features","chapter":"2 La donnée géographique dans R","heading":"2.2.2 Pourquoi simple features?","text":"Les simple features sont un modèle de données largement utilisé qui sous-tend les structures de données de nombreuses applications SIG, notamment QGIS et PostGIS.\nL’un des principaux avantages de cette approche est que l’utilisation du modèle de données garantit que votre travail est transférable à d’autres configurations, par exemple l’importation et l’exportation vers des bases de données spatiales.\nUne question plus spécifique du point de vue de R est “pourquoi utiliser le paquet sf alors que sp est déjà éprouvé” ?\nIl existe de nombreuses raisons (liées notamment aux avantages du modèle des simple features) :Lecture et écriture rapides des donnéesAmélioration des performances de représentation graphiqueLes objets sf peuvent être traités comme des tableau de données dans la plupart des opérations.Les noms des fonctions sf sont relativement cohérents et intuitifs (tous commencent par st_)Les fonctions sf peuvent être combinées à l’aide de l’opérateur %>% et fonctionnent bien avec la collection tidyverse des paquets R.L’intégration de sf pour les paquets tidyverse est illustré avec la fonction de lecture des données géographiques vectorisées: read_sf().\nAu contraire de la fonction st_read() qui va retourner les attributs dans les classes de base R data.frame (et affiche un message de compte rendu plus complet qui dans l’extrait de code ci dessous été omis) la fonction read_sf() va retourner un tidyverse tibble.\nVous en trouvez la démonstration ci-dessous (voir la section ?? sur la lecture et l’écriture des données géographiques vectorielles avec R) :Comme illusté dans le Chapitre ??, montrant la manipulation d’objet `sf avec le tidyverse, sf est désormais la bibliothèquee de référence pour l’analyse des données vectorielles spatiales dans R (sans oublier l’écosystème des pacquets spatstat qui fournit de nombreuses fonctions pour les statistiques spatiales).\nDe nombreux paquets populaires reposent sur sf, comme le montre l’augmentation de sa popularité en termes de nombre de téléchargements par jour, comme indiqué dans la section 1.4 du chapitre précédent.\nLa transition de paquets et de chaîne de processus reposant sur les anciens paquets rgeos et rgdal prends du temps (Bivand 2021), mais le processus été acceleré par le sentiments d’urgence par les messages indiquant qu’ils “seraient indisponible à partir de fin 2023”.\nCela signifie que quiconque utilisant encore ces paquets se doit de “passer aux fonctions de sf/stars/terra pour utiliser GDAL et PROJ le plus rapidement possible.”.En d’autres termes, sf est à l’épreuve du futur mais sp ne l’est pas.\nPour les workflow qui dépendent de l’ancienne classe Spatial, les objets sf peuvent être convertis depuis et vers la classe Spatial du paquet sp comme suit :","code":"\nnc_dfr = st_read(system.file(\"shape/nc.shp\", package = \"sf\"))\n#> Reading layer `nc' from data source \n#>   `/usr/local/lib/R/site-library/sf/shape/nc.shp' using driver `ESRI Shapefile'\n#> Simple feature collection with 100 features and 14 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n#> Geodetic CRS:  NAD27\nnc_tbl = read_sf(system.file(\"shape/nc.shp\", package = \"sf\"))\nclass(nc_dfr)\n#> [1] \"sf\"         \"data.frame\"\nclass(nc_tbl)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nlibrary(sp)\nworld_sp = as(world, \"Spatial\") # de sf à sp\n# sp functions ...\nworld_sf = st_as_sf(world_sp)           # de sp à sf"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 La donnée géographique dans R","heading":"2.2.3 Réalisation rapide de cartes","text":"Des premiers jets de cartes peuvent être crées dans sf avec plot().\nPar défaut, cela crée un graphique avec de multiple encarts (comme spplot() de sp), un encart pour chaque variable de l’objet, comme illustré dans le panneau de gauche de la Figure 2.4.\nUne légende ou “clé” avec une couleur continue est produite si l’objet à tracer une seule variable (voir l’encart de droite).\nLes couleurs peuvent également être définies avec l’argument col =, bien que cela ne permette pas de créer une palette continue ou une légende.\n\nFIGURE 2.4: Cartographie avec sf, avec plusieurs variables (gauche) ou une seule (droite).\nLes graphiques sont ajoutés en tant que couches aux images existantes en ajoutant dans la fonction l’argument add = TRUE.9\nPour illustrer cela et donner un avant-goût du contenu des chapitres ?? et ?? sur les attributs et les opérations sur les données spatiales, l’extrait de code suivant combine des pays d’Asie :Ainsi pouvons maintenant dessiner le continent asiatique sur une carte du monde.\nNotez que le premier graphe ne doit avoir qu’un seul encart pour que add = TRUE fonctionne.\nSi le premier graphe une légende, reset = FALSE doit être utilisé (résultat non montré) :L’ajout de couches de cette manière peut être utilisé pour vérifier la correspondance géographique entre les couches :\nla fonction plot() est rapide à exécuter et nécessite peu de lignes de code, mais ne permet pas de créer des cartes interactives avec une large gamme d’options.\nPour la réalisation de cartes plus poussées, nous recommandons l’utilisation de paquets de visualisation spécifiques tels que tmap (voir le chapitre ??).Il y plusieurs façons de modifier les cartes avec la méthode plot() de sf.\nComme sf étend les méthodes de base de R, les arguments de plot() tels que main = (qui spécifie le titre de la carte) fonctionnent avec les objets sf (voir ?graphics::plot et ?par).10\n\nLa figure 2.5 illustre cette flexibilité en superposant sur une carte du monde des cercles dont les diamètres (définis avec l’argument cex =) représentent les populations des pays.\nUne version non projetée de cette figure peut être créée avec les commandes suivantes (voir les exercices à la fin de ce chapitre et le script 02-contplot.R 2.5):\nFIGURE 2.5: Pays coloriés par continents et leurs populations en 2015 populations (cercles proportionnels à la population).\nLe code ci-dessus utilise la fonction st_centroid() pour convertir un type de géométrie (polygones) en un autre (points) (voir chapitre ??), dont la représentation varie en fonction de l’argument cex.\nLa méthode plot de sf possède également des arguments spécifiques aux données géographiques. expandBB, par exemple, peut être utilisé pour dessiner un objet sf dans son contexte :\nelle prend un vecteur de quatre nombres qui étend la boîte de délimitation de la carte par rapport à zéro en lsuivant l’ordre : bas, gauche, haut, droite.\nC’est ce que nous avons utilisé dans le morceau de code suivant pour représenter l’Inde dans le contexte de ses gigantesques voisins asiatiques, en mettant l’accent sur la Chine à l’est 2.6 (voir les ci-dessous sur l’ajout de texte aux graphiques) :\nFIGURE 2.6: L’Inde en contexte, demonstration de l’argument expandBB.\nNotez l’utilisation de [0] pour ne garder que la colonne de géométrie et de lwd pour mettre l’accent sur l’Inde.\nLa prochaine section ?? présente d’autres techniques de visualisation permettant de représenter une gamme de types de géométrie.","code":"\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 La donnée géographique dans R","heading":"2.2.4 Les types de geométries","text":"Les géométries sont les éléments de base de simples features.\nIls peuvent prendre dans R l’un des 18 types de géométrie pris en charge par le paquet sf.\n\n\nDans ce chapitre, nous nous concentrerons sur les sept types les plus couramment utilisés : POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON et GEOMETRYCOLLECTION.\nLa liste complète des types d’éléments possibles est disponible dans le manuel de PostGIS.En général, le well-known binary (WKB) ou le well-known text (WKT) sont les codages standard pour les géométries simples.\n\n\n\nLes WKB sont généralement représentés par des chaînes hexadécimales facilement lisibles par les ordinateurs.\nC’est pourquoi les SIG et les bases de données spatiales l’utilisent pour transférer et stocker des objets géométriques.\nLe WKT, quant à lui, est une description de balisage textuel lisible par l’homme pour des simples features.\nLes deux formats sont échangeables, et si nous en présentons un, nous choisirons naturellement la représentation WKT.La base de chaque type de géométrie est le point.\nUn point est simplement une coordonnée dans un espace 2D, 3D ou 4D (cf. vignette(\"sf1\") pour plus d’information). Un exemple est disponible sur le second panneau de la figure 2.7:\nPOINT (5 2)\nUne linestring, ligne, est une séquence de points avec une ligne droite reliant ces points, par exemple (cf. le panneau central de la figure 2.7) :LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)Un polygone est une séquence de points qui forment un anneau fermé, sans intersection.\nFermé signifie que le premier et le dernier point d’un polygone ont les mêmes coordonnées (cf. le panneau de droite de la figure 2.7).11\nPolygone sans anneau intérieur: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Exemple de géometries de point, ligne et polygone.\nJusqu’à présent, nous avons créé des géométries avec une seule entité géométrique par élément.\nToutefois, sf permet également l’existence de plusieurs géométries au sein d’une même entité (d’où le terme “collection de géométries”) en utilisant la version “multi” de chaque type de géométrie :\nMultipoint: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilinestring: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolygon: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Examples de multi* geometries.\nEnfin, une collection de géométries peut contenir n’importe quelle combinaison de géométries, y compris des (multi)points et des lignes (voir figure 2.9) :\nGeometry collection: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Exemple de collection de géometrie.\n","code":""},{"path":"spatial-class.html","id":"sf","chapter":"2 La donnée géographique dans R","heading":"2.2.5 The sf class","text":"Les Simple features sont composés de deux parties principales : les géométries et les attributs non géographiques.\nLa figure 2.10 montre comment un objet sf est créé – les géométries proviennent d’un objet sfc, tandis que les attributs sont pris dans un data.frame ou un tibble.\nLes sections 2.2.6 et 2.2.7 reprennent la création de géometries sf à partir de rien.\nFIGURE 2.10: Building blocks sf objects.\nLes attributs non géographiques permettent la représentation du nom de l’entité ou d’autres attributs, mesures, appartenance à des groupes et autres.\n\nPour l’illustrer nous allons représenter une température de 25°C à Londres le 21 juin 2017.\nCet exemple à une géométrie (les coordonnées) et trois attributs de trois classes différentes (le nom, la température et la data).12\nLes objets de la classe sf représentent de telles données en combinant les attributs (data.frame) avec la colonne de géométrie simple feature (sfc).\nIls sont créés avec st_sf(), comme l’illustre le code ci-dessous, créant l’exemple londonien :Que s’est-il passé ? Premièrement, les coordonnés ont été utilisé pour créer la simple feature geometry (sfg).\nDeuxièmement, la géométrie été convertie en une colonne de type simple feature (sfc), avec un SCR.\nTroisièmement, les attributs ont été stockés dans un data.frame, qui été combiné avec l’objet sfc avec st_sf().\nLe résultat est un objet sf, comme démontré ci-dessous (une partie de la sortie de code est omise) :Le résultat montre que les objets sf ont en fait deux classes informatiques, sf et data.frame.\nLes Simple features sont simplement des tableau de données mais avec un attribut spatial stocké dans une colonne de type liste, souvent nommée geometry, comme décrit dans la section ??.\nCette dualité est au coeur du concept de Simple features:\nla plupart du temps un objet sf peut être traité comme un data.frame et se comporté comme tel.\nLes Simple features sont, par essence, des tableaux de données avec une extension spatiale.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # objet sfg\nlnd_geom = st_sfc(lnd_point, crs = 4326)           # objet sfc\nlnd_attrib = data.frame(                           # objet data.frame\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # objet sf\nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"sfg","chapter":"2 La donnée géographique dans R","heading":"2.2.6 Simple feature geometries (sfg)","text":"La classe sfg représente les différents types de géométrie simple feature dans R : point, ligne, polygone (et leurs équivalents “multi”, comme les multipoints) ou collection de géométries.\nEn général, la tâche fastidieuse de création de géométries vous est épargnée car vous pouvez simplement importer un fichier spatial déjà existant.\nCependant, il existe un ensemble de fonctions permettant de créer des objets géométriques simple feature (sfg) à partir de zéro si nécessaire.\nLes noms de ces fonctions sont simples et cohérents, ils commencent tous par le préfixe st_ et se terminent par le nom du type de géométrie en lettres minuscules :Un point : st_point()Une ligne : st_linestring()Un polygone: st_polygon()Un multipoint: st_multipoint()Une multiligne : st_multilinestring()Un multipolygone : st_multipolygon()Une collection de géométries : st_geometrycollection()Les objets sfg peuvent être créer à partir de trois de types de données de R:Un vecteur numérique: un point uniqueUn matrice: un ensemble de points, où chaque ligne représente un point, un multipoint ou une ligneUne liste: une collection d’objets comme des matrices, des multilignes ou des collections de géométries.La fonction st_point() créée un point à partir de vecteurs numériques :Les sorties montrent que les types de points XY (coordonnées 2D), XYZ (coordonnées 3D) et XYZM (3D avec une variable supplémentaire, généralement la précision de mesure) sont créés à partir de vecteurs de longueur 2, 3 et 4, respectivement.\nLe type XYM doit être spécifié en utilisant l’argument dim (qui est l’abréviation de dimension).En revanche, vous devez utiliser des matrices dans le cas des objets multipoints (st_multipoint()) et ligne (st_linestring()) :Enfin, vous devez utiliser les listes pour la création de multilignes, de (multi-)polygones et de collections de géométries :","code":"\nst_point(c(5, 2))                 # point en XY\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # point en XYZ\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # point en XYM\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # point en XYZM\n#> POINT ZM (5 2 3 1)\n# la fonction rbind simplifie la création de matrices\n## MULTIPOINT\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LIGNE\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLYGONE\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLYGONE avec un trou\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILIGNE\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLYGONE\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## COLLECTIONS DE GEOMETRIES\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 La donnée géographique dans R","heading":"2.2.7 Simple feature columns (sfc)","text":"Un objet sfg ne contient qu’un seul élément géométrique simple feature.\nUne colonne de géométrie *simple feature (sfc) est une liste d’objets sfg, qui peut en outre contenir des informations sur le système de référence des coordonnées utilisé.\nPar exemple, pour combiner deux simples features en un seul objet avec deux entités, nous pouvons utiliser la fonction st_sfc().\n\nC’est important car sfc va correspondre à la colonne de géométrie dans les tableaux de données sf** :Dans la plupart des cas, un objet sfc contient des objets du même type géométrique.\nPar conséquent, lorsque nous convertissons des objets sfg de type polygone en une colonne géométrique simple feature, nous obtenons également un objet sfc de type polygone, ce qui peut être vérifié avec st_geometry_type().\nDe même, une colonne géométrique de multilignes donnera un objet sfc de type multiligne :C’est aussi possible de créer un objet sfc à partir d’objets sfg de géométries différentes.Comme indiqué précédemment, les objets sfc peuvent également stocker de l’information sur le système de coordonnées et de référence (SCR).\nLa valeur par défaut est NA (Available) et elle peut être vérifiée avec st_crs() :Toutes les géométries des objets sfc doivent avoir le même SCR.\nUn SCR peut être spécifié avec l’argument crs de st_sfc() (ou st_sf()), il prend un identifiant SCR fourni sous forme de chaîne de texte, comme crs = \"EPSG:4326\" (voir la section ?? pour détails et mieux comprendre ce que cela signifie)","code":"\n# POINT sfc\npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# sfc POLYGON\npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# sfc MULTILINESTRING\nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# GEOMETRIE sfc \npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# Paramètrer le SCR avec un identifiant 'EPSG':\npoints_sfc_wgs = st_sfc(point1, point2, crs = \"EPSG:4326\")\nst_crs(points_sfc_wgs) # indique le SCR (seulement les 4 premières lignes sont montrées)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#> ..."},{"path":"spatial-class.html","id":"le-pacquet-sfheaders","chapter":"2 La donnée géographique dans R","heading":"2.2.8 le pacquet sfheaders","text":"sfheaders est un paquet pour R qui accélère la construction, la conversion et la manipulation d’objets sf (Cooley 2020).\nIl se focalise sur la construction rapide d’objets sf à partir de vecteurs, matrices et tableaux de données, sans dépendre de la bibliothèque sf ; en exposant son code C++ sous-jacent à travers des fichiers d’en-tête (d’où le nom, sfheaders).\nCette approche permet à d’autres de l’étendre en utilisant un code compilé et rapide.\nChaque fonction de base de sfheaders une implémentation C++ correspondante, comme décrit dans la vignette Cpp.\nPour la plupart des gens, les fonctions R seront plus que suffisantes pour bénéficier de la vitesse de calcul du paquet.\nsfheaders été développé séparément de sf, mais vise à être totalement compatible, en créant des objets sf valides du type décrit dans les sections précédentes.Les cas le plus simple d’utilisation de sfheaders sont présentés dans les morceaux de code ci-dessous avec des exemples de construction d’objets sfg, sfc, et sf :Un vecteur converti en sfg_POINT.Une matrice convertie en sfg_LINESTRING.Un cadre de données converti en sfg_POLYGON.Nous allons commencer par créer l’objet sfg le plus simple possible, une seule paire de coordonnées, assignée à un vecteur nommé v :L’exemple ci-dessus montre comment l’objet sfg v_sfg_sfh est affiché lorsque sf n’est pas chargé, démontrant ainsi sa structure sous-jacente.\nLorsque sf est chargé (comme c’est le cas ici), le résultat de la commande ci-dessus est indiscernable des objets sf :Les exemples suivants montrent comment sfheaders crée des objets sfg à partir de matrices et de tableau de données :En réutilisant les objets v, m, et df, nous pouvons également construire des colonnes de géométrie simple feature (sfc) comme suit (sorties non montrées) :De même, les objets sf sont crées comme suis:Dans chacun de ces exemples, le SCR (système de coordonnées et de référence) n’est pas défini.\nSi vous prévoyez d’effectuer des calculs ou des opérations géométriques à l’aide des fonctions sf, nous vous recommandons de définir le SCR (voir le chapitre ?? pour plus de détails) :sfheaders est aussi une bonne option pour “déconstruire” et “reconstruire” les objets sf, c’est-à-dire convertir les colonnes géométriques en tableaux de données contenant les coordonnées de chaque sommet (vertex) et les identifiants de chaque éléments géométriques (et d’éventuels géométrie multiples).\nIl est rapide et fiable pour “passer” des colonnes géométriques vers différents types, un sujet traité dans le chapitre ??.\nDes tests, dans la documentation du paquet et dans le code de test développé pour ce livre, montrent qu’il est beaucoup plus rapide que le paquet sf pour de telles opérations.","code":"\nv = c(1, 1)\nv_sfg_sfh = sfheaders::sfg_point(obj = v)\nv_sfg_sfh # affichage sans sf chargé\n#>      [,1] [,2]\n#> [1,]    1    1\n#> attr(,\"class\")\n#> [1] \"XY\"    \"POINT\" \"sfg\" \nv_sfg_sf = sf::st_point(v, c(1, 2))\nprint(v_sfg_sf) == print(v_sfg_sfh)\n#> POINT (1 1)\n#> POINT (1 1)\n#> [1] TRUE\n# matrices\nm = matrix(1:8, ncol = 2)\nsfheaders::sfg_linestring(obj = m)\n#> LINESTRING (1 5, 2 6, 3 7, 4 8)\n# data.frames\ndf = data.frame(x = 1:4, y = 4:1)\nsfheaders::sfg_polygon(obj = df)\n#> POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))\nsfheaders::sfc_point(obj = v)\nsfheaders::sfc_linestring(obj = m)\nsfheaders::sfc_polygon(obj = df)\nsfheaders::sf_point(obj = v)\nsfheaders::sf_linestring(obj = m)\nsfheaders::sf_polygon(obj = df)\ndf_sf = sfheaders::sf_polygon(obj = df)\nst_crs(df_sf) = \"EPSG:4326\""},{"path":"spatial-class.html","id":"s2","chapter":"2 La donnée géographique dans R","heading":"2.2.9 géométrie sphérique avec S2","text":"Les moteurs de géométrie sphérique sont basés sur le fait que la terre est ronde alors que les procédures mathématiques simples de géocomputation, telles que le calcul d’une ligne droite entre deux points ou de l’aire délimitée par un polygone, supposent des géométries planes (projetées).\nDepuis la version 1.0.0 de sf, R prend en charge les opérations de géométrie sphérique “d’emblée”, grâce à son interface avec le moteur de géométrie sphérique S2 de Google, via le paquet l’interfaçant s2.\nS2 est peut-être mieux connu comme un exemple de système de grille globale discrète (DGGS).\nUn autre exemple est l’indice spatial hiérarchique hexagonal global H3 (Bondaruk, Roberts, Robertson 2020).Bien que potentiellement utile pour décrire des lieux n’importe où sur la Terre en utilisant des chaînes de caractères telles que e66ef376f790adf8a5af7fca9e6e422c03c9143f, le principal avantage de l’interface de sf avec S2 est l’intégration de fonctions de calculs tels que les calculs de distance, de tampon (buffer) et de surface. Ils sont décrit dans la documentation intégrée de sf qui peut être ouverte avec la commande vignette(\"sf7\").sf peut fonctionner sur deux modes par rapport à S2 : activé et désactivé.\nPar défaut, le moteur de géométrie S2 est activé, comme peut le vérifier avec la commande suivante :Un exemple des conséquences de la désactivation du moteur de géométrie est montré ci-dessous, en créant des tampons autour de l’objet india créé plus tôt dans le chapitre (notez les avertissements émis lorsque S2 est désactivé)\nFIGURE 2.11: Exemple des conséquences de la désactivation du moteur géométrique S2. Les deux représentations d’un tampon autour de l’Inde ont été créées avec la même commande, mais l’objet polygone violet été créé avec S2 activé, ce qui donné un tampon de 1 m. Le polygone vert clair, plus grand, été créé avec S2 désactivé, ce qui donné un tampon inexacte avec des degrés en longitude/latitude.\nDans ce livre, nous supposerons que S2 est activé, sauf indication contraire.\nActivez-le à nouveau avec la commande suivante.","code":"\nsf_use_s2()\n#> [1] TRUE\nindia_buffer_with_s2 = st_buffer(india, 1)\nsf_use_s2(FALSE)\n#> Spherical geometry (s2) switched off\nindia_buffer_without_s2 = st_buffer(india, 1)\n#> Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =\n#> endCapStyle, : st_buffer does not correctly buffer longitude/latitude data\n#> dist is assumed to be in decimal degrees (arc_degrees).\nsf_use_s2(TRUE)\n#> Spherical geometry (s2) switched on"},{"path":"spatial-class.html","id":"données-raster","chapter":"2 La donnée géographique dans R","heading":"2.3 Données Raster","text":"Le modèle de données raster représente le monde à l’aide d’une grille continue de cellules (souvent aussi appelées pixels ; Figure 2.12:).\nCe modèle de données fait souvent référence à des grilles dites régulières, dans lesquelles chaque cellule une taille identique et constante - et nous nous concentrerons uniquement sur les grilles régulières dans cet ouvrage.\nCependant, plusieurs autres types de grilles existent, notamment les grilles tournées, cisaillées, rectilignes et curvilignes (voir le chapitre 1 de Pebesma Bivand (2022) ou le chapitre 2 de Tennekes Nowosad (2022)).Un raster se compose généralement d’un en-tête\net d’une matrice (avec des lignes et des colonnes) représentant des cellules équidistantes (souvent aussi nommées pixels; Figure 2.12:).)13\nL’en-tête du raster définit le système de coordonnées et références, l’étendue et l’origine.\n\n\nL’origine (ou point de départ) est souvent la coordonnée du coin inférieur gauche de la matrice (LE paquet terra utilise toutefois le coin supérieur gauche, par défaut (Figure 2.12:B)).\nL’en-tête définit l’étendue via le nombre de colonnes, le nombre de lignes et la résolution de la taille des cellules.\nAinsi, en partant de l’origine, nous pouvons facilement accéder à chaque cellule et la modifier, soit en utilisant l’ID d’une cellule (Figure 2.12:B), soit en spécifiant explicitement les lignes et les colonnes.\nCette représentation matricielle évite de stocker explicitement les coordonnées des quatre points d’angle (en fait, elle ne stocke qu’une seule coordonnée, à savoir l’origine) de chaque coin de cellule, comme ce serait le cas pour les polygones vectoriels rectangulaires.\nGrâce à cela et à l’algèbre matricielle (section ??), le traitement raster est beaucoup plus efficace et rapide que le traitement des données vectorielles.\nCependant, contrairement aux données vectorielles, la cellule d’une couche raster ne peut contenir qu’une seule valeur.\nCette valeur peut être numérique ou catégorique (Figure 2.12:C).\nFIGURE 2.12: Données raster types: () identifiant des pixels, (B) Valeur des pixels, (C) une carte raster colorisée.\nLes rasters représentent généralement des phénomènes continus tels que l’élévation, la température, la densité de population ou des données spectrales.\nLes variables discrètes telles que les classes de sol ou de couverture terrestre peuvent également être représentées dans le modèle de données raster.\nCes deux utilisations sont illustrées dans la figure 2.13, elle montre comment les limites des caractéristiques discrètes peuvent devenir floues dans les ensembles de données matricielles.\nSelon la nature de l’application, les représentations vectorielles des caractéristiques discrètes peuvent être plus adaptées.\nFIGURE 2.13: Exemples de rasters pour des variables continues et catégorielles.\n","code":""},{"path":"spatial-class.html","id":"les-paquets-de-r-pour-travailler-avec-des-rasters","chapter":"2 La donnée géographique dans R","heading":"2.3.1 Les paquets de R pour travailler avec des rasters","text":"Au cours des deux dernières décennies, plusieurs paquets permettant de lire et de traiter des ensembles de données matricielles ont été développés.\nComme indiqué dans la section 1.5, le principal d’entre eux était raster. Il conduit à un changement radical dans les capacités de traitement des rasters avec R lorsqu’il été lancé en 2010 et il dominé ce segment jusqu’au développement de terra et stars.\nLes deux paquets développés plus récemment offrent des fonctions puissantes et performantes pour travailler avec des jeux de données raster et ils ont d’important recoupement entre leurs cas d’usages.\nDans ce livre, nous nous concentrons sur terra, qui remplace raster, plus ancien et (dans la plupart des cas) plus lent.\nAvant de découvrir le fonctionnement du système de classes de terra, cette section décrit les similitudes et les différences entre terra et stars ; ces connaissances aideront à décider lequel est le plus approprié dans différentes situations.Tout d’abord, terra se concentre sur le modèle de données raster le plus courant (grilles régulières), tandis que stars permet également de stocker des modèles moins populaires (notamment des grilles régulières, tournées, cisaillées, rectilignes et curvilignes).\nAlors que terra gère généralement des rasters à une ou plusieurs couches14, le paquet stars fournit des moyens de stocker des cubes de données raster – un objet raster avec de nombreuses couches (par exemple, des bandes), pour de nombreux moments dans le temps (par exemple, des mois), et de nombreux attributs (par exemple, le type de capteur et le type de capteur B).\nPremièrement, il est important de noter que dans les deux paquets, toutes les couches ou éléments d’un cube de données doivent avoir les mêmes dimensions spatiales et la même étendue.\nDeuxièmement, les deux paquets permettent soit de lire toutes les données raster en mémoire, soit de lire uniquement leurs métadonnées, ce qui est généralement effectué automatiquement en fonction de la taille du fichier d’entrée.\nCependant, ils stockent raster de manière très différente.\nterra est basé sur du code C++ et utilise principalement des pointeurs C++.\nstars stocke les valeurs sous forme de listes de tableaux pour les plus petits rasters ou juste un chemin de fichier pour les plus grands.\nTroisièmement, les fonctions de stars sont étroitement liées aux objets et fonctions vectorielles de sf, alors que terra utilise sa propre classe d’objets pour les données vectorielles, à savoir SpatVector.\nQuatrièmement, les deux paquets approchent différemment la façon dont leurs fonctions agissent sur leurs objets.\nLe paquet terra s’appuie principalement sur un grand nombre de fonctions intégrées, où chaque fonction un spécifique (par exemple, le rééchantillonnage ou le recadrage).\nDe son coté stars utilise quelques fonctions intégrées (généralement avec des noms commençant par st_) avec en complément de ses propres méthodes pour les fonctions de R existantes (par exemple, split() ou aggregate()), et des méthodes pour les fonctions de dplyr (par exemple, filter() ou slice()).Il est important de noter qu’il est facile de convertir des objets de terra en stars (en utilisant st_as_stars()) et inversement (en utilisant rast()).\nNous vous encourageons également à lire Pebesma Bivand (2022) pour l’introduction la plus complète au paquet stars.","code":""},{"path":"spatial-class.html","id":"une-introduction-à-terra","chapter":"2 La donnée géographique dans R","heading":"2.3.2 Une introduction à terra","text":"Le paquet terra prend en charge les objets raster dans R.\nComme son prédécesseur raster (créé par le même développeur, Robert Hijmans), il fournit un ensemble complet de fonctions pour créer, lire, exporter, manipuler et traiter des jeux de données rasters.\nLes fonctionnalités de terra sont en grande partie les mêmes que celles du paquetage raster, plus mature, mais il existe quelques différences : Les fonctions terra sont généralement plus efficientes en calcul que les équivalents raster.\n\nD’autre part, le système de classes de raster est populaire et utilisé par de nombreux autres paquets.\nVous pouvez passer sans problème d’un type d’objet à l’autre pour assurer la compatibilité avec les anciens scripts et paquets, par exemple avec les fonctions raster(), stack() et brick() du paquet raster (cf. le chapitre précédent pour en savoir plus sur l’évolution des paquets R pour travailler avec des données géographiques).En plus des fonctions de manipulation des données matricielles, terra fournit de nombreuses fonctions de bas niveau pouvant servir de base au développement de nouveaux outils pour travailler avec des jeux de données raster.\n\nterra vous permet également de travailler sur de grands jeux de données raster qui sont trop volumineux pour tenir dans la RAM.\nDans ce cas, terra offre la possibilité de diviser l’image raster en petits morceaux et de les traiter de manière itérative au lieu de charger un fichier entier dans la RAM.Pour l’illustration des concepts terra, nous utiliserons des jeux de données de la spDataLarge.\nIl s’agit de quelques objets raster et d’un objet vectoriel couvrant une zone du parc national de Zion (Utah, USA).\nPar exemple, srtm.tif est un modèle numérique d’élévation de cette zone (pour plus de détails, voir sa documentation ?srtm).\nTout d’abord, créons un objet SpatRaster nommé my_rast :En tapant le nom du raster dans la console, obtient l’en-tête du raster (dimensions, résolution, étendue, CRS) et quelques informations supplémentaires (classe, source de données, résumé des valeurs du raster) :Des fonctions dédiées renseignent chaque composant : dim(my_rast) renvoie le nombre de lignes, de colonnes et de couches ; ncell() le nombre de cellules (pixels) ; res() la résolution spatiale ; ext() son étendue spatiale ; et crs() son système de référence de coordonnées (la reprojection matricielle est traitée dans la section ??).\ninMemory() indique si le raster est stocké en mémoire vive ou sur disque.help(\"terra-package\") renvoie une liste complète de toutes les fonctions terra disponibles.","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n#> [1] \"SpatRaster\"\n#> attr(,\"package\")\n#> [1] \"terra\"\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 La donnée géographique dans R","heading":"2.3.3 Réalisation de cartes de base","text":"Comme le paquet sf, terra fournit également des méthodes plot() pour ses propres classes.\n\nFIGURE 2.14: Basic raster plot.\nIl existe plusieurs autres approches pour représenter des données raster dans R qui sortent du cadre de cette section, notamment :la fonction plotRGB() du paquet terra pour créer une composition colorée rouge-vert-bleu (RGB) basée sur trois couches dans un objet SpatRaster.Des paquets tels que tmap pour créer des cartes statiques et interactives d’objets rasters et vectoriels (voir le chapitre ??)D’autres fonctions, par exemple levelplot() du paquet rasterVis, pour créer des vignettes, une technique courante pour visualiser les changements dans le temps.","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 La donnée géographique dans R","heading":"2.3.4 Les classes Raster","text":"La classe SpatRaster représente les rasters dans terra.\nLa façon la plus simple de créer un objet raster dans R est de lire un fichier raster à partir du disque ou d’un serveur (Section ??.\nLe paquet terra supporte de nombreux pilotes à l’aide de la bibliothèque GDAL.\nLes rasters provenant de fichiers ne sont généralement pas lus entièrement en RAM, à l’exception de leur en-tête et d’un pointeur vers le fichier lui-même.Les rasters peuvent aussi être créés à partir de zéro en utilisant la même fonction rast().\nCeci est illustré dans l’extrait de code suivant produisant en un nouvel objet SpatRaster.\nCe raster consiste en 36 cellules (6 colonnes et 6 lignes spécifiées par nrows et ncols) centrées autour du Méridien d’origine et de l’Équateur (voir les paramètres xmin, xmax, ymin et ymax).\nLe SCR par défaut des objets rasters est WGS84, mais peut être changé avec l’argument crs.\nCela signifie que l’unité de résolution est en degrés, que nous fixons à 0.5 (resolution).\nDes valeurs (vals) sont assignées à chaque cellule : 1 à la cellule 1, 2 à la cellule 2, et ainsi de suite.\nRappelez-vous : rast() remplit les cellules par rangées (contrairement à matrix()) en commençant par le coin supérieur gauche, ce qui signifie que la première rangée contient les valeurs 1 à 6, la seconde 7 à 12, etc.?rast permet de découvrir d’autre facons de créer des objets rasters.La classe SpatRaster gère également les couches multiples, qui correspondent généralement à un seul fichier satellite multispectral ou à une série temporelle de rasters.nlyr() fournit le nombre de couches stockées dans un objet SpatRaster :Pour les objets raster multi-couches, les couches peuvent être sélectionnées avec terra::subset().15.\nElle accepte un numéro de couche ou son nom comme second argument :L’opération inverse, qui consiste à combiner plusieurs objets SpatRaster en un seul, peut être réalisée à l’aide de la fonction c :","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : landsat_1, landsat_2, landsat_3, landsat_4 \n#> min values  :      7550,      6404,      5678,      5252 \n#> max values  :     19071,     22051,     25780,     31961\nnlyr(multi_rast)\n#> [1] 4\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, 4)\nmulti_rast34 = c(multi_rast3, multi_rast4)"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 La donnée géographique dans R","heading":"2.4 Système de Coordonnés et de Réferences géographiques et projetés","text":"\nLes types de données spatiales vectorielles et rasters partagent des concepts intrinsèques aux données spatiales.\nLe plus fondamental d’entre eux est peut-être le système de référence des coordonnées (SCR), qui définit la manière dont les éléments spatiaux des données se rapportent à la surface de la Terre (ou d’autres corps).\nLes CRS sont soit géographiques, soit projetés, comme nous l’avons présenté au début de ce chapitre (voir Figure 2.1).\nCette section reprend chaque type, posant ainsi les bases du chapitre ??, qui offre une plongée en profondeur dans la configuration, la transformation et l’interrogation des SCR.","code":""},{"path":"spatial-class.html","id":"système-de-référence-des-coordonnées","chapter":"2 La donnée géographique dans R","heading":"2.4.1 Système de référence des coordonnées","text":"\nLes systèmes de coordonnées géographiques identifient tout emplacement sur la surface de la Terre à l’aide de deux valeurs — la longitude et la latitude (voir le panneau gauche de la figure 2.16).\nLa longitude est la position dans la direction est-ouest en distance angulaire par rapport au plan du méridien d’origine.\nLa latitude est la distance angulaire au nord ou au sud du plan équatorial.\nLes distances dans les SCR géographiques ne sont donc pas mesurées en mètres.\nCela des conséquences importantes, comme le montre la section ??.La surface de la Terre dans les systèmes de coordonnées géographiques est représentée par une surface sphérique ou ellipsoïdale.\nLes modèles sphériques supposent que la Terre est une sphère parfaite d’un rayon donné. Ils ont l’avantage de la simplicité mais, en même temps, ils sont inexacts : la Terre n’est pas une sphère !\nLes modèles ellipsoïdaux sont définis par deux paramètres : le rayon équatorial et le rayon polaire.\nIls sont adaptés car la Terre est comprimée : le rayon équatorial est environ 11,5 km plus long que le rayon polaire (Maling 1992).16Les ellipsoïdes font partie d’un composant plus large des SCR : le datum.\nIl contient des informations sur l’ellipsoïde à utiliser et la relation précise entre les coordonnées cartésiennes et l’emplacement sur la surface de la Terre.\nIl existe deux types de datum — géocentrique (tel que WGS84) et local (tel que NAD83).\nVous pouvez voir des exemples de ces deux types de référentiels dans la figure 2.15.\nLes lignes noires représentent un * datum géocentrique, dont le centre est situé au centre de gravité de la Terre et n’est pas optimisé pour un emplacement spécifique.\nDans un datum référentiel*, représenté par une ligne pointillée violette, la surface ellipsoïdale est décalée pour s’aligner sur la surface à un endroit particulier.\nCela permet de prendre en compte les variations locales de la surface de la Terre, dues par exemple à de grandes chaînes de montagnes, dans un SCR local.\npeut le voir sur la figure 2.15, où le système de référence local est adapté à la région des Philippines, mais n’est pas aligné avec la majeure partie du reste de la surface de la planète.\nLes deux référentiels de la figure 2.15 sont placés au-dessus d’un géoïde - un modèle du niveau moyen des mers à l’échelle mondiale 17.\nFIGURE 2.15: Données géocentriques et géodésiques locales représentées sur un géoïde (en fausses couleurs et avec un facteur d’échelle de 10 000 pour l’exagération verticale). L’image du géoïde est adaptée du travail de Ince et al. (2019).\n","code":""},{"path":"spatial-class.html","id":"système-de-réference-projetées","chapter":"2 La donnée géographique dans R","heading":"2.4.2 Système de réference projetées","text":"\nTous les SCR projetés sont basés sur un SCR géographique, décrit dans la section précédente, et s’appuient sur des projections cartographiques pour convertir la surface tridimensionnelle de la Terre en valeurs d’abscisses et d’ordonnées (x et y) dans un SCR projeté.\nLes SRC projetés sont basés sur des coordonnées cartésiennes sur une surface implicitement plane (panneau de droite de la figure 2.16).\nIls ont une origine, des axes x et y, et une unité de mesure linéaire telle que le mètre.Cette transition ne peut se faire sans ajouter certaines déformations.\nPar conséquent, certaines propriétés de la surface de la Terre sont déformées au cours de ce processus, telles que la superficie, la direction, la distance et la forme.\nUn système de coordonnées projeté ne peut préserver qu’une ou deux de ces propriétés.\nLes projections sont souvent nommées en fonction de la propriété qu’elles préservent : la projection de surface égale préserve l’aire, la projection azimutale préserve la direction, la projection équidistante préserve la distance et la projection conforme préserve la forme locale.Il existe trois groupes principaux de types de projection : conique, cylindrique et plane (azimutale).\nDans une projection conique, la surface de la Terre est projetée sur un cône le long d’une seule ligne de tangence ou de deux lignes de tangence.\nLes distorsions sont minimisées le long des lignes de tangence et augmentent avec la distance à ces lignes dans cette projection.\nElle est donc le mieux adaptée aux cartes des zones de latitude moyenne.\nUne projection cylindrique représente la surface sur un cylindre.\nCette projection peut également être créée en touchant la surface de la Terre le long d’une seule ligne de tangence ou de deux lignes de tangence.\nLes projections cylindriques sont le plus souvent utilisées pour cartographier le monde entier.\nUne projection plane projette les données sur une surface plate en touchant le globe en un point ou le long d’une ligne de tangence.\nElle est généralement utilisée pour cartographier les régions polaires.\nsf_proj_info(type = \"proj\") donne une liste des projections disponibles supportées par la bibliothèque PROJ.Un résumé rapide des différentes projections, de leurs types, de leurs propriétés et de leur adéquation peut être trouvé dans “Map Projections” (1993) et sur https://www.geo-projections.com/.\nNous nous étendrons sur les SCR et expliquerons comment projeter d’un SCR à un autre dans le chapitre ??.\nPour l’instant, il suffit de savoir :Les systèmes de coordonnées sont un élément clé des objets géographiques.Il est important de savoir dans quel SCR se trouvent vos données, et s’il s’agit d’un système géographique (lon/lat) ou d’un système projeté (généralement en mètres), car cela des conséquences sur la façon dont R gère les opérations spatiales et géométriques.Les SCR des objets sf peuvent être interrogés avec la fonction st_crs(), les SCR des objets terra peuvent être interrogés avec la fonction crs().\nFIGURE 2.16: Exemples de systèmes de coordonnées géographiques (WGS 84 ; à gauche) et projetées (NAD83 / UTM zone 12N ; à droite) pour un type de données vectorielles.\n","code":""},{"path":"spatial-class.html","id":"unités","chapter":"2 La donnée géographique dans R","heading":"2.5 Unités","text":"Une caractéristique importante des SCR est qu’ils contiennent des informations sur les unités spatiales.\nDe toute évidence, il est essentiel de savoir si les mesures d’une maison sont en pieds ou en mètres, et il en va de même pour les cartes.\nIl est de bonne pratique cartographique d’ajouter une barre d’échelle ou un autre indicateur de distance sur les cartes afin de démontrer la relation entre les distances sur la page ou l’écran et les distances sur le terrain.\nDe même, il est important de spécifier formellement les unités dans lesquelles les données géométriques ou les cellules sont mesurées afin de fournir un contexte et de garantir que les calculs ultérieurs sont effectués dans ce contexte.Une nouvelle caractéristique des données géométriques dans les objets sf est qu’elles ont un support natif pour les unités.\nCela signifie que les calculs de distance, de surface et autres calculs géométriques dans sf renvoient des valeurs accompagnées d’un attribut units, défini par le paquet units (Pebesma, Mailund, Hiebert 2016).\nCeci est avantageux, car cela évite la confusion causée par les différentes unités (la plupart des SCR utilisent les mètres, certains les pieds) et fournit des informations sur la dimensionnalité.\nCeci est démontré dans le morceau de code ci-dessous, qui calcule la superficie du Luxembourg :\n\nLa sortie est en unités de mètres carrés (m2), montrant que le résultat représente un espace bidimensionnel.\nCette information, stockée sous forme d’attribut (que les lecteurs intéressés peuvent découvrir avec attributs(st_area(luxembourg))), peut alimenter des calculs ultérieurs qui utilisent des unités, comme la densité de population (nombre de personnes par unité de surface, typiquement par km2).\nLe fait de déclarer les unités permet d’éviter toute confusion.\nPour reprendre l’exemple du Luxembourg, si les unités n’étaient pas précisées, pourrait supposer à tort que les unités sont en hectares.\nPour traduire ce chiffre énorme en une taille plus digeste, il est tentant de diviser les résultats par un million (le nombre de mètres carrés dans un kilomètre carré)Cependant, le résultat est alors donné de manière incorrecte en mètres carrés.\nLa solution consiste à définir les unités correctes avec le paquet units :Les unités sont tout aussi importantes dans le cas des jeux de données raster.\nCependant, jusqu’à présent, sf est le seul paquet spatial qui supporte les unités, ce qui signifie que les personnes travaillant sur des données raster doivent aborder les changements d’unités d’analyse (par exemple, la conversion de la largeur des pixels des unités impériales aux unités décimales) avec précaution.\nL’objet my_rast (voir ci-dessus) utilise une projection WGS84 avec des degrés décimaux comme unités.\nPar conséquent, sa résolution est également donnée en degrés décimaux, mais il faut le savoir, puisque la fonction res() renvoie simplement un vecteur numérique.Si nous utilisions la projection UTM, les unités changeraient.Encore une fois, la commande res() renvoie un tableau numérique sans unité, ce qui nous oblige à savoir que l’unité de la projection UTM est le mètre.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # nécessite le paquet s2 des récentes version de sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)\n#> [1] 83.5 83.5"},{"path":"spatial-class.html","id":"ex2","chapter":"2 La donnée géographique dans R","heading":"2.6 Exercises","text":"E1. Use summary() geometry column world data object included spData package. output tell us :geometry type?number countries?coordinate reference system (CRS)?E2. Run code ‘generated’ map world Section 2.2.3 (Basic map making).\nFind two similarities two differences image computer book.cex argument (see ?plot)?cex set sqrt(world$pop) / 10000?Bonus: experiment different ways visualize global population.E3. Use plot() create maps Nigeria context (see Section 2.2.3).Adjust lwd, col expandBB arguments plot().Challenge: read documentation text() annotate map.E4. Create empty SpatRaster object called my_raster 10 columns 10 rows.\nAssign random values 0 10 new raster plot .E5. Read-raster/nlcd.tif file spDataLarge package.\nkind information can get properties file?E6. Check CRS raster/nlcd.tif file spDataLarge package.\nkind information can learn ?","code":""}]
