[{"path":"index.html","id":"bienvenue","chapter":"Bienvenue!","heading":"Bienvenue!","text":"Il s’agit du site en français de Geocomputation R, un livre sur l’analyse, la visualisation et la modélisation des données géographiques. Le site en anglais est ici.Note: La première édition été imprimée par CRC Press dans la collection R Series.\nIl est possible de l’acheter chez CRC Press, ou sur Amazon, la première version est aussi hebergée sur bookdown.org.Inspiré par le mouvement libriste et l’Open Source Software Geospatial (FOSS4G), le code et le texte qui sous-tendent ce livre sont ouverts, ce qui garantit que le contenu est reproductible, transparent et accessible.\nL’hébergement du code source sur GitHub permet à quiconque d’interagir avec le projet en ouvrant des questions ou en contribuant au nouveau contenu et à la correction des fautes de frappe pour le bénéfice de tous.\nLa version en ligne du livre est hébergée sur geocompr.github.io et mise à jour par GitHub Actions.\nL’état actuel de sa construction est le suivant :Cette version du livre en français été produite via l’action GitHub du 2022-08-27. Ce travail est sous licence : Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"index.html","id":"comment-contribuer","chapter":"Bienvenue!","heading":"Comment contribuer ?","text":"bookdown rend l’édition d’un livre aussi facile que l’édition d’un wiki, à condition d’avoir un compte GitHub (inscription sur github.com).\nUne fois connecté à GitHub, cliquez sur l’icône “Edit page” dans le panneau de droite du site Web du livre.\nVous accéderez ainsi à une version modifiable du fichier source R Markdown qui généré la page sur laquelle vous vous trouvez.Pour signaler un problème concernant le contenu du livre (par exemple, un code qui ne fonctionne pas) ou pour demander une fonctionnalité, consultez la [liste des issues] (https://github.com/Robinlovelace/geocompr/issues).Les mainteneurs et les contributeurs doivent suivre les règles de conduite de ce dépôt : CODE CONDUCT.","code":""},{"path":"index.html","id":"reproducibilité","chapter":"Bienvenue!","heading":"Reproducibilité","text":"Le moyen le plus rapide de reproduire le contenu du livre si vous êtes novice en matière de données géographiques avec R peut être via le navigateur web, grâce à Binder.\nEn cliquant sur le lien ci-dessous, vous ouvrirez une nouvelle fenêtre contenant RStudio Server dans votre navigateur Web, ce qui vous permettra d’ouvrir les fichiers du chapitre et d’exécuter des morceaux de code pour vérifier que le code est reproductible.Si vous voyez quelque chose comme l’image ci-dessous, félicitations, cela fonctionné et vous pouvez commencer à explorer la géocomputation avec R dans un environnement cloud.(tout en étant conscient des consignes d’utilisation de mybinder.org):\nFIGURE 0.1: Capture d’écran du code reproductible contenu dans Geocomputation avec R s’exécutant dans RStudio Server sur un navigateur servi par Binder.\nPour reproduire le code du livre sur votre propre ordinateur, vous avez besoin d’une version récente de R et des paquets à jour.\nIls peuvent être installés en utilisant le paquet remotes.Après avoir installé les dépendances du livre, vous pouvez reconstruire le livre à des fins de test et d’enseignement.\nPour ce faire, vous devez télécharger et déziper ou cloner le code source du libre.\nAprès avoir ouvert le projet geocompr.Rproj dans RStudio (ou ouvert le dossier dans un autre IDE tel que VS Code), vous devriez être en mesure de reproduire le contenu avec la commande suivante :La page GitHub contient plus de détail pour reproduire ce livre.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"geocompr/geocompkg\")\nbookdown::serve_book(\".\")"},{"path":"index.html","id":"soutenir-le-projet","chapter":"Bienvenue!","heading":"Soutenir le projet","text":"Si vous trouvez ce livre utile (sa traduction ou sa version originale), vous pouvez le soutenir :En en parlant à d’autres personnesEn communiquant sur le livre dans les réseaux sociaux, par exemple, via #geocompr hashtag sur Twitter (cf. notre Guestbook sur geocompr.github.io) ou en référençant les cours mobilisant le livreLe citant ou le metre en lien‘Starring’ le dépôt GitHub geocomprEcrivant un recension, sur Amazon ou GoodreadsPosant des questions ou faire des suggestions de contenus sur GitHub ou Twitter.Achetant une copiePlus de détails sur le github.com/Robinlovelace/geocompr.L’icône du globe utilisé en couverture de ce livre été créé par Jean-Marc Viglino et est sous licence CC-4.0 International.","code":""},{"path":"foreword-1st-edition.html","id":"foreword-1st-edition","chapter":"Foreword (1st Edition)","heading":"Foreword (1st Edition)","text":"‘spatial’ R always broad, seeking provide integrate tools geography, geoinformatics, geocomputation spatial statistics anyone interested joining : joining asking interesting questions, contributing fruitful research questions, writing improving code.\n, ‘spatial’ R always included open source code, open data reproducibility.‘spatial’ R also sought open interaction many branches applied spatial data analysis, also implement new advances data representation methods analysis expose cross-disciplinary scrutiny.\nbook demonstrates, often alternative workflows similar data similar results, may learn comparisons others create understand workflows.\nincludes learning similar communities around Open Source GIS complementary languages Python, Java .R’s wide range spatial capabilities never evolved without people willing share creating adapting.\nmight include teaching materials, software, research practices (reproducible research, open data), combinations .\nR users also benefitted greatly ‘upstream’ open source geo libraries GDAL, GEOS PROJ.book clear example , curious willing join , can find things need match aptitudes.\nadvances data representation workflow alternatives, ever increasing numbers new users often without applied quantitative command-line exposure, book kind really needed.\nDespite effort involved, authors supported pressing forward publication., fresh book ready go; authors tried many tutorials workshops, readers instructors able benefit knowing contents continue tried people like .\nEngage authors wider R-spatial community, see value choice building workflows important, enjoy applying learn things care .Roger BivandBergen, September 2018","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"who-this-book-is-for","chapter":"Preface","heading":"Who this book is for","text":"book people want analyze, visualize model geographic data open source software.\nbased R, statistical programming language powerful data processing, visualization geospatial capabilities.\nbook covers wide range topics interest wide range people many different backgrounds, especially:People learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):\n\nadvent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.\nPeople learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):advent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.Graduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceGraduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningThe book designed intermediate--advanced R users interested geocomputation R beginners prior experience geographic data.\nnew R geographic data, discouraged: provide links materials describe nature spatial data beginner’s perspective Chapter 2 links provided .","code":""},{"path":"preface.html","id":"how-to-read-this-book","chapter":"Preface","heading":"How to read this book","text":"book divided three parts:Part : Foundations, aimed getting --speed geographic data R.Part II: Extensions, covers advanced techniques.Part III: Applications, real-world problems.chapters get progressively harder recommend reading book order.\nmajor barrier geographical analysis R steep learning curve.\nchapters Part aim address providing reproducible code simple datasets ease process getting started.important aspect book teaching/learning perspective exercises end chapter.\nCompleting develop skills equip confidence needed tackle range geospatial problems.\nSolutions exercises, number extended examples, provided book’s supporting website, geocompr.github.io.Impatient readers welcome dive straight practical examples, starting Chapter 2.\nHowever, recommend reading wider context Geocomputation R Chapter 1 first.\nnew R, also recommend learning language attempting run code chunks provided chapter (unless ’re reading book understanding concepts).\nFortunately R beginners R supportive community developed wealth resources can help.\nparticularly recommend three tutorials: R Data Science (Grolemund Wickham 2016) Efficient R Programming (Gillespie Lovelace 2016), especially Chapter 2 (installing setting-R/RStudio) Chapter 10 (learning learn), introduction R (R Core Team, Smith, Team 2021).","code":""},{"path":"preface.html","id":"why-r","chapter":"Preface","heading":"Why R?","text":"Although R steep learning curve, command-line approach advocated book can quickly pay .\n’ll learn subsequent chapters, R effective tool tackling wide range geographic data challenges.\nexpect , practice, R become program choice geospatial toolbox many applications.\nTyping executing commands command-line , many cases, faster pointing--clicking around graphical user interface (GUI) desktop GIS.\napplications Spatial Statistics modeling R may realistic way get work done.outlined Section 1.2, many reasons using R geocomputation:\nR well-suited interactive use required many geographic data analysis workflows compared languages.\nR excels rapidly growing fields Data Science (includes data carpentry, statistical learning techniques data visualization) Big Data (via efficient interfaces databases distributed computing systems).\nFurthermore R enables reproducible workflow: sharing scripts underlying analysis allow others build-work.\nensure reproducibility book made source code available github.com/Robinlovelace/geocompr.\nfind script files code/ folder generate figures:\ncode generating figure provided main text book, name script file generated provided caption (see example caption Figure ??).languages Python, Java C++ can used geocomputation excellent resources learning geocomputation without R, discussed Section 1.3.\nNone provide unique combination package ecosystem, statistical capabilities, visualization options, powerful IDEs offered R community.\nFurthermore, teaching use one language (R) depth, book equip concepts confidence needed geocomputation languages.","code":""},{"path":"preface.html","id":"real-world-impact","chapter":"Preface","heading":"Real-world impact","text":"Geocomputation R equip knowledge skills tackle wide range issues, including scientific, societal environmental implications, manifested geographic data.\ndescribed Section 1.1, geocomputation using computers process geographic data:\nalso real-world impact.\ninterested wider context motivations behind book, read ; covered Chapter 1..","code":""},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"Acknowledgements","text":"","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introduction","heading":"1 Introduction","text":"book using power computers things geographic data.\nteaches range spatial skills, including: reading, writing manipulating geographic data; making static interactive maps; applying geocomputation solve real-world problems; modeling geographic phenomena.\ndemonstrating various geographic operations can linked, reproducible ‘code chunks’ intersperse prose, book also teaches transparent thus scientific workflow.\nLearning use wealth geospatial tools available R command line can exciting, creating new ones can truly liberating.\nUsing command-line driven approach taught throughout, programming techniques covered Chapter ??, can help remove constraints creativity imposed software.\nreading book completing exercises, therefore feel empowered strong understanding possibilities opened R’s impressive geographic capabilities, new skills solve real-world problems geographic data, ability communicate work maps reproducible code.last decades free open source software geospatial (FOSS4G) progressed astonishing rate.\nThanks organizations OSGeo, geographic data analysis longer preserve expensive hardware software: anyone can now download run high-performance spatial libraries.\nOpen source Geographic Information Systems (GIS), QGIS, made geographic analysis accessible worldwide.\nGIS programs tend emphasize graphical user interfaces (GUIs), unintended consequence discouraging reproducibility (although many can used command line ’ll see Chapter ??).\nR, contrast, emphasizes command line interface (CLI).\nsimplistic comparison different approaches illustrated Table 1.1.TABLE 1.1: Differences emphasis software packages (Graphical User Interface (GUI) Geographic Information Systems (GIS) R).book motivated importance reproducibility scientific research (see note ).\naims make reproducible geographic data analysis workflows accessible, demonstrate power open geospatial software available command-line.\n“Interfaces software part R” (Eddelbuettel Balamuta 2018).\nmeans addition outstanding ‘house’ capabilities, R allows access many spatial software libraries, explained Section 1.2 demonstrated Chapter ??.\ngoing details software, however, worth taking step back thinking mean geocomputation.Reproducibility major advantage command-line interfaces, mean practice?\ndefine follows: “process results can generated others using publicly accessible code.”","code":""},{"path":"intro.html","id":"what-is-geocomputation","chapter":"1 Introduction","heading":"1.1 What is geocomputation?","text":"Geocomputation young term, dating back first conference subject 1996.1\ndistinguished geocomputation (time) commonly used term ‘quantitative geography’, early advocates proposed, emphasis “creative experimental” applications (Longley et al. 1998) development new tools methods (Openshaw Abrahart 2000):\n“GeoComputation using various different types geodata developing relevant geo-tools within overall context ‘scientific’ approach.”\nbook aims go beyond teaching methods code; end able use geocomputational skills, “practical work beneficial useful” (Openshaw Abrahart 2000).approach differs early adopters Stan Openshaw, however, emphasis reproducibility collaboration.\nturn 21st Century, unrealistic expect readers able reproduce code examples, due barriers preventing access necessary hardware, software data.\nFast-forward two decades things progressed rapidly.\nAnyone access laptop ~4GB RAM can realistically expect able install run software geocomputation publicly accessible datasets, widely available ever (see Chapter ??).2\nUnlike early works field, work presented book reproducible using code example data supplied alongside book, R packages spData, installation covered Chapter 2.Geocomputation closely related terms including: Geographic Information Science (GIScience); Geomatics; Geoinformatics; Spatial Information Science; Geoinformation Engineering (Longley 2015); Geographic Data Science (GDS).\nterm shares emphasis ‘scientific’ (implying reproducible falsifiable) approach influenced GIS, although origins main fields application differ.\nGDS, example, emphasizes ‘data science’ skills large datasets, Geoinformatics tends focus data structures.\noverlaps terms larger differences use geocomputation rough synonym encapsulating :\nseek use geographic data applied scientific work.\nUnlike early users term, however, seek imply cohesive academic field called ‘Geocomputation’ (‘GeoComputation’ Stan Openshaw called ).\nInstead, define term follows: working geographic data computational way, focusing code, reproducibility modularity.Geocomputation recent term influenced old ideas.\ncan seen part Geography, 2000+ year history (Talbert 2014);\nextension Geographic Information Systems (GIS) (Neteler Mitasova 2008), emerged 1960s (Coppock Rhind 1991).Geography played important role explaining influencing humanity’s relationship natural world long invention computer, however.\nAlexander von Humboldt’s travels South America early 1800s illustrates role:\nresulting observations lay foundations traditions physical plant geography, also paved way towards policies protect natural world (Wulf 2015).\nbook aims contribute ‘Geographic Tradition’ (Livingstone 1992) harnessing power modern computers open source software.book’s links older disciplines reflected suggested titles book: Geography R R GIS.\nadvantages.\nformer conveys message comprises much just spatial data:\nnon-spatial attribute data inevitably interwoven geometry data, Geography something map.\nlatter communicates book using R GIS, perform spatial operations geographic data (Bivand, Pebesma, Gómez-Rubio 2013).\nHowever, term GIS conveys connotations (see Table 1.1) simply fail communicate one R’s greatest strengths:\nconsole-based ability seamlessly switch geographic non-geographic data processing, modeling visualization tasks.\ncontrast, term geocomputation implies reproducible creative programming.\ncourse, (geocomputational) algorithms powerful tools can become highly complex.\nHowever, algorithms composed smaller parts.\nteaching foundations underlying structure, aim empower create innovative solutions geographic data problems.","code":""},{"path":"intro.html","id":"why-use-r-for-geocomputation","chapter":"1 Introduction","heading":"1.2 Why use R for geocomputation?","text":"Early geographers used variety tools including barometers, compasses sextants advance knowledge world (Wulf 2015).\ninvention marine chronometer 1761 became possible calculate longitude sea, enabling ships take direct routes.Nowadays lack geographic data hard imagine.\nEvery smartphone global positioning (GPS) receiver multitude sensors devices ranging satellites semi-autonomous vehicles citizen scientists incessantly measure every part world.\nrate data produced overwhelming.\nautonomous vehicle, example, can generate 100 GB data per day (Economist 2016).\nRemote sensing data satellites become large analyze corresponding data single computer, leading initiatives OpenEO.‘geodata revolution’ drives demand high performance computer hardware efficient, scalable software handle extract signal noise, understand perhaps change world.\nSpatial databases enable storage generation manageable subsets vast geographic data stores, making interfaces gaining knowledge vital tools future.\nR one tool, advanced analysis, modeling visualization capabilities.\ncontext focus book language (see Wickham 2019).\nInstead use R ‘tool trade’ understanding world, similar Humboldt’s use tools gain deep understanding nature complexity interconnections (see Wulf 2015).\nAlthough programming can seem like reductionist activity, aim teach geocomputation R fun, understanding world.R multi-platform, open source language environment statistical computing graphics (r-project.org/).\nwide range packages, R also supports advanced geospatial statistics, modeling visualization.\nNew integrated development environments (IDEs) RStudio made R user-friendly many, easing map making panel dedicated interactive visualization.core, R object-oriented, functional programming language (Wickham 2019), specifically designed interactive interface software (Chambers 2016).\nlatter also includes many ‘bridges’ treasure trove GIS software, ‘geolibraries’ functions (see Chapter ??).\nthus ideal quickly creating ‘geo-tools’, without needing master lower level languages (compared R) C, FORTRAN Java (see Section 1.3).\ncan feel like breaking free metaphorical ‘glass ceiling’ imposed GUI-based proprietary geographic information systems (see Table 1.1 definition GUI).\nFurthermore, R facilitates access languages:\npackages Rcpp reticulate enable access C++ Python code, example.\nmeans R can used ‘bridge’ wide range geospatial programs (see Section 1.3).Another example showing R’s flexibility evolving geographic capabilities interactive map making.\n’ll see Chapter ??, statement R “limited interactive [plotting] facilities” (Bivand, Pebesma, Gómez-Rubio 2013) longer true.\ndemonstrated following code chunk, creates Figure 1.1 (functions generate plot covered Section ??).\nFIGURE 1.1: blue markers indicate authors . basemap tiled image Earth night provided NASA. Interact online version geocompr.robinlovelace.net, example zooming clicking popups.\ndifficult produce Figure 1.1 using R years ago, let alone interactive map.\nillustrates R’s flexibility , thanks developments knitr leaflet, can used interface software, theme recur throughout book.\nuse R code, therefore, enables teaching geocomputation reference reproducible examples representing real world phenomena, rather just abstract concepts.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(lng = c(-3, 23, 11),\n             lat = c(52, 53, 49), \n             popup = popup)"},{"path":"intro.html","id":"software-for-geocomputation","chapter":"1 Introduction","heading":"1.3 Software for geocomputation","text":"R powerful language geocomputation many options geographic data analysis providing thousands geographic functions.\nAwareness languages geocomputation help decide different tool may appropriate specific task, place R wider geospatial ecosystem.\nsection briefly introduces languages C++, Java Python geocomputation, preparation Chapter ??.important feature R (Python) interpreted language.\nadvantageous enables interactive programming Read–Eval–Print Loop (REPL):\ncode entered console immediately executed result printed, rather waiting intermediate stage compilation.\nhand, compiled languages C++ Java tend run faster (compiled).C++ provides basis many GIS packages QGIS, GRASS SAGA sensible starting point.\nWell-written C++ fast, making good choice performance-critical applications processing large geographic datasets, harder learn Python R.\nC++ become accessible Rcpp package, provides good ‘way ’ C programming R users.\nProficiency low-level languages opens possibility creating new, high-performance ‘geoalgorithms’ better understanding GIS software works (see Chapter ??).Java another important versatile language geocomputation.\nGIS packages gvSig, OpenJump uDig written Java.\nmany GIS libraries written Java, including GeoTools JTS, Java Topology Suite (GEOS C++ port JTS).\nFurthermore, many map server applications use Java including Geoserver/Geonode, deegree 52°North WPS.Java’s object-oriented syntax similar C++.\nmajor advantage Java platform-independent (unusual compiled language) highly scalable, making suitable language IDEs RStudio, book written.\nJava fewer tools statistical modeling visualization Python R, although can used data science (Brzustowicz 2017).Python important language geocomputation especially many Desktop GIS GRASS, SAGA QGIS provide Python API (see Chapter ??).\nLike R, popular tool data science.\nlanguages object-oriented, many areas overlap, leading initiatives reticulate package facilitates access Python R Ursa Labs initiative support portable libraries benefit entire open source data science ecosystem.practice R Python strengths extent use less important domain application communication results.\nLearning either provide head-start learning .\nHowever, major advantages R Python geocomputation.\nincludes much better support geographic data models vector raster language (see Chapter 2) corresponding visualization possibilities (see Chapters 2 ??).\nEqually important, R unparalleled support statistics, including spatial statistics, hundreds packages (unmatched Python) supporting thousands statistical methods.major advantage Python general-purpose programming language.\nused many domains, including desktop software, computer games, websites data science.\nPython often shared language different (geocomputation) communities can seen ‘glue’ holds many GIS programs together.\nMany geoalgorithms, including QGIS ArcMap, can accessed Python command line, making well-suited starter language command-line GIS.3For spatial statistics predictive modeling, however, R second--none.\nmean must choose either R Python: Python supports common statistical techniques (though R tends support new developments spatial statistics earlier) many concepts learned Python can applied R world.\n\n\nLike R, Python also supports geographic data analysis manipulation packages osgeo, Shapely, NumPy PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"r-ecosystem","chapter":"1 Introduction","heading":"1.4 R’s spatial ecosystem","text":"many ways handle geographic data R, dozens packages area.4\nbook endeavor teach state---art field whilst ensuring methods future-proof.\nLike many areas software development, R’s spatial ecosystem rapidly evolving (Figure 1.2).\nR open source, developments can easily build previous work, ‘standing shoulders giants’, Isaac Newton put 1675.\napproach advantageous encourages collaboration avoids ‘reinventing wheel’.\npackage sf (covered Chapter 2), example, builds predecessor sp.surge development time (interest) ‘R-spatial’ followed award grant R Consortium development support Simple Features, open-source standard model store access vector geometries.\nresulted sf package (covered Section ??).\nMultiple places reflect immense interest sf.\nespecially true R-sig-Geo Archives, long-standing open access email list containing much R-spatial wisdom accumulated years.\nFIGURE 1.2: Downloads selected R packages working geographic data. y-axis shows average number downloads per day, within 91-day rolling window.\nnoteworthy shifts wider R community, exemplified data processing package dplyr (released 2014) influenced shifts R’s spatial ecosystem.\nAlongside packages shared style emphasis ‘tidy data’ (including, e.g., ggplot2), dplyr placed tidyverse ‘metapackage’ late 2016.\n\n\ntidyverse approach, focus long-form data fast intuitively named functions, become immensely popular.\nled demand ‘tidy geographic data’ partly met sf.\nobvious feature tidyverse tendency packages work harmony.\n\n\nequivalent geoverse, attempts harmonization packages hosted r-spatial organization growing number packages use sf (Table 1.2).TABLE 1.2: top 5 downloaded packages depend sf, terms average number downloads per day previous month. 2021-11-19 289 packages import sf.Parallel group developments relates rspatial set packages.5\nmain member terra package spatial raster handling (see Section ??).","code":""},{"path":"intro.html","id":"the-history-of-r-spatial","chapter":"1 Introduction","heading":"1.5 The history of R-spatial","text":"many benefits using recent spatial packages sf, also important aware history R’s spatial capabilities: many functions, use-cases teaching material contained older packages.\ncan still useful today, provided know look.\nR’s spatial capabilities originated early spatial packages S language (Bivand Gebhardt 2000).\n1990s saw development numerous S scripts handful packages spatial statistics.\nR packages arose 2000 R packages various spatial methods “point pattern analysis, geostatistics, exploratory spatial data analysis spatial econometrics”, according article presented GeoComputation 2000 (Bivand Neteler 2000).\n, notably spatial, sgeostat splancs still available CRAN (B. S. Rowlingson Diggle 1993; B. Rowlingson Diggle 2017; Venables Ripley 2002; Majure Gebhardt 2016).subsequent article R News (predecessor R Journal) contained overview spatial statistical software R time, much based previous code written S/S-PLUS (Ripley 2001).\noverview described packages spatial smoothing interpolation, including akima geoR (Akima Gebhardt 2016; Jr Diggle 2016), point pattern analysis, including splancs (B. Rowlingson Diggle 2017) spatstat (Baddeley, Rubak, Turner 2015).following R News issue (Volume 1/3) put spatial packages spotlight , detailed introduction splancs commentary future prospects regarding spatial statistics (Bivand 2001).\nAdditionally, issue introduced two packages testing spatial autocorrelation eventually became part spdep (Bivand 2017).\nNotably, commentary mentions need standardization spatial interfaces, efficient mechanisms exchanging data GIS, handling spatial metadata coordinate reference systems (CRS).maptools (written Nicholas Lewin-Koh; Bivand Lewin-Koh (2017)) another important package time.\nInitially maptools just contained wrapper around shapelib permitted reading ESRI Shapefiles geometry nested lists.\ncorresponding nowadays obsolete S3 class called “Map” stored list alongside attribute data frame.\nwork “Map” class representation nevertheless important since directly fed sp prior publication CRAN.2003 Roger Bivand published extended review spatial packages.\nproposed class system support “data objects offered GDAL”, including ‘fundamental’ point, line, polygon, raster types.\nFurthermore, suggested interfaces external libraries form basis modular R packages (Bivand 2003).\nlarge extent ideas realized packages rgdal sp.\nprovided foundation spatial data analysis R, described Applied Spatial Data Analysis R (ASDAR) (Bivand, Pebesma, Gómez-Rubio 2013), first published 2008.\nTen years later, R’s spatial capabilities evolved substantially still build ideas set-Bivand (2003):\ninterfaces GDAL PROJ, example, still power R’s high-performance geographic data /O CRS transformation capabilities (see Chapters ?? ??, respectively).rgdal, released 2003, provided GDAL bindings R greatly enhanced ability import data previously unavailable geographic data formats.\ninitial release supported raster drivers subsequent enhancements provided support coordinate reference systems (via PROJ library), reprojections import vector file formats (see Chapter ?? file formats).\nMany additional capabilities developed Barry Rowlingson released rgdal codebase 2006 (see B. Rowlingson et al. 2003 R-help email list context).sp, released 2005, overcame R’s inability distinguish spatial non-spatial objects (Pebesma Bivand 2005).\nsp grew workshop Vienna 2003 hosted sourceforge migrating R-Forge.\nPrior 2005, geographic coordinates generally treated like number.\nsp changed classes generic methods supporting points, lines, polygons grids, attribute data.sp stores information bounding box, coordinate reference system attributes slots Spatial objects using S4 class system,\nenabling data operations work geographic data (see Section ??).\n, sp provides generic methods summary() plot() geographic data.\nfollowing decade, sp classes rapidly became popular geographic data R number packages depended increased around 20 2008 100 2013 (Bivand, Pebesma, Gómez-Rubio 2013).\n2018 almost 500 packages rely sp, making important part R ecosystem.\nProminent R packages using sp include: gstat, spatial spatio-temporal geostatistics; geosphere, spherical trigonometry; adehabitat used analysis habitat selection animals (Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).rgdal sp solved many spatial issues, R still lacked ability geometric operations (see Chapter 5).\nColin Rundel addressed issue developing rgeos, R interface open-source geometry library (GEOS) Google Summer Code project 2010 (Bivand Rundel 2018).\nrgeos enabled GEOS manipulate sp objects, functions gIntersection().Another limitation sp — restricted support raster data — overcome raster, first released 2010 (Hijmans 2017).\nclass system functions support range raster operations outlined Section ??.\nkey feature raster ability work datasets large fit RAM (R’s interface PostGIS supports -disk operations vector geographic data).\nraster also supports map algebra (see Section ??).parallel developments class systems methods came support R interface dedicated GIS software.\nGRASS (Bivand 2000) follow-packages spgrass6 rgrass7 (GRASS GIS 6 7, respectively) prominent examples direction (Bivand 2016a, 2016b).\nexamples bridges R GIS include RSAGA (Brenning, Bangs, Becker 2018, first published 2008), RPyGeo (Brenning 2012, first published 2008), RQGIS (Muenchow, Schratz, Brenning 2017, first published 2016), rqgisprocess (see Chapter ??).\n\nVisualization focus initially, bulk R-spatial development focused analysis geographic operations.\nsp provided methods map making using base lattice plotting system demand growing advanced map making capabilities.\nRgoogleMaps first released 2009, allowed overlay R spatial data top ‘basemap’ tiles online services Google Maps OpenStreetMap (Loecher Ropkins 2015).\nfollowed ggmap package added similar ‘basemap’ tiles capabilities ggplot2 (Kahle Wickham 2013).\nThough ggmap facilitated map-making ggplot2, utility limited need fortify spatial objects, means converting long data frames.\nworks well points computationally inefficient lines polygons, since coordinate (vertex) converted row, leading huge data frames represent complex geometries.\nAlthough geographic visualization tended focus vector data, raster visualization supported raster received boost release rasterVis, described book subject spatial temporal data visualization (Lamigueiro 2018).\n2018 map making R hot topic dedicated packages tmap, leaflet mapview supporting class system provided sf, focus next chapter (see Chapter ?? visualization).Since 2018, movement modernizing basic R packages related handling spatial data continued.\nterra – successor raster package aimed better performance straightforward user interface firstly released (see Chapter ??) 2020 (Hijmans 2021).\nmid-2021, significant change made sf package incorporating spherical geometry calculations.\nSince change, default, many spatial operations data geographic CRSs apply C++ s2geometry library’s spherical geometry algorithms, types operations data projected CRSs still using GEOS.\n\n\nNew ideas spatial data representations also developed period.\nincludes stars package, closely connected sf, handling raster vector data cubes (Pebesma 2021) lidR processing airborne LiDAR (Light Detection Ranging) point clouds (Roussel et al. 2020).modernization several reasons, including emergence new technologies standard, impacts spatial software development outside R environment (Bivand 2021).\nimportant external factor affecting spatial software, including R spatial packages, major updates, including many breaking changes PROJ library begun 2018.\nimportantly, changes forced replacement proj4string WKT representation storage coordinate reference systems coordinates operations (learn Section 2.4 Chapter ??).\nSince 2018, progress spatial visualization tools R related factors.\nFirstly, new types spatial plots developed, including rayshader package offering combination raytracing multiple hill-shading methods produce 2D 3D data visualizations (Morgan-Wall 2021).\nSecondly, ggplot2 gained new spatial capabilities, mostly thanks ggspatial package adds spatial visualization elements, including scale bars north arrows (Dunnington 2021) gganimate enables smooth customizable spatial animations (Pedersen Robinson 2020).\nThirdly, performance visualizing large spatial dataset improved.\nespecially relates automatic plotting downscaled rasters tmap possibility using high-performance interactive rendering platforms mapview package, \"leafgl\" \"mapdeck\".\nLastly, existing mapping tools rewritten minimize dependencies, improve user interface, allow easier creation extensions.\nincludes mapsf package (successor cartography) (Giraud 2021) version 4 tmap package, internal code revised.late 2021, planned retirement rgdal, rgeos maptools end 2023 announced R-sig-Geo mailing list Roger Bivand.\nlarge impact existing workflows applying packages, also influence packages depend rgdal, rgeos maptools.\nTherefore, Bivand’s suggestion plan transition modern tools, including sf terra, explained book’s next chapters.","code":""},{"path":"intro.html","id":"exercises","chapter":"1 Introduction","heading":"1.6 Exercises","text":"E1. Think terms ‘GIS’, ‘GDS’ ‘geocomputation’ described . () best describes work like using geo* methods software ?E2. Provide three reasons using scriptable language R geocomputation instead using graphical user interface (GUI) based GIS QGIS.E3. Think real world problem like solve geographic data help people living local area sketch map geographic processes involved.E4. Consider datasets needed represent problem computationally sketch workflow processing , resulting outputs help inform decision making related problem thought previous exercise. Use pen paper digital sketching tool Excalidraw.","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 La donnée géographique dans R","heading":"2 La donnée géographique dans R","text":"","code":""},{"path":"spatial-class.html","id":"prérequis","chapter":"2 La donnée géographique dans R","heading":"Prérequis","text":"C’est le premier chapitre pratique du livre. Il faut donc installer certains logiciels et les avoir un peu pratiqué.\nVous devez avoir accès à un ordinateur sur lequel est installé R (version 4.2.0 ou supérieure).\nNous vous recommandons vivement de ne pas vous contenter de lire le texte, mais également d’exécuter le code afin de renforcer vos compétences en géocomputation.Pour garder une trace de votre progression, il est utile de créer un nouveau dossier sur votre ordinateur pour enregistrer au fur et à mesure vos notes dans des scripts R, vos sorties graphiques ou autres.\nVous pouvez télécharger ou cloner le code source du livre en anglais à partir de github.com/robinlovelace/geocompr pour vous aider dans votre apprentissage.\nNous vous recommandons vivement d’installer un environnement de développement intégré (IDE) tel que RStudio (recommandé pour la plupart des gens) ou VS Code)6Si vous ne connaissez pas R, nous vous recommandons de suivre les ressources d’introduction à R telles que Hands Programming R de Garrett Grolemund ou Introduction R de Claudia Engel avant de vous lancer dans ce livre.\nOrganisez votre travail (par exemple, avec des projets RStudio) et donnez à vos scripts des noms judicieux tels que 02-chapter.R pour documenter le code que vous écrivez au fur et à mesure de votre apprentissage.\nUne fois confortable il est temps de tester un peu de code !\nÀ moins que ces paquets ne soient déjà installés, la première chose à faire est d’installer les paquets R fondamentaux utilisés dans ce chapitre, à l’aide des commandes suivantes :7Tous les paquets nécessaires pour reproduire la première partie du livre peuvent être installés via la commande suivante : remotes::install_github(\"geocompr/geocompkg\").\nCette commande utilise la fonction install_packages() du package remotes pour installer le code source hébergé sur la plate-forme d’hébergement, de version et de collaboration de code GitHub.\nLa commande suivante installera toutes les dépendances nécessaires pour reproduire l’intégralité du livre (attention : cela peut prendre plusieurs minutes) : remotes::install_github(\"geocompr/geocompkg\", dependencies = TRUE)Les paquets nécessaires peuvent être “chargés” (techniquement, ils sont attachés) avec la fonction library() :Conformément à la section ??, la sortie de library(sf) mentionne les versions des bibliothèques géographiques clés, comme GEOS, utilisées par ce paquet.Les autres paquets installés contiennent des données qui seront utilisées dans le livre:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # classes et fonctions pour les données vectorielles\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE\nlibrary(terra)      # classes et fonctions pour les données rasters\nlibrary(spData)        # chargement de données geographiques\nlibrary(spDataLarge)   # chargement de données geographiques plus volumineuses"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 La donnée géographique dans R","heading":"2.1 Introduction","text":"Ce chapitre fournit de brèves explications sur les modèles fondamentaux des données géographiques : vecteur et raster.\nNous présenterons la théorie qui sous-tend chaque modèle de données et les disciplines dans lesquelles ils prédominent, avant de démontrer leur mise en œuvre dans R.Le modèle de données vectoriel représente le monde à l’aide de points, de lignes et de polygones.\nCeux-ci ont des frontières discrètes et bien définies, ce qui signifie que les ensembles de données vectorielles ont généralement un haut niveau de précision (mais pas nécessairement d’exactitude, comme nous le verrons dans la section @ref(unités)).\nLe modèle de données raster divise la surface en pixel de taille constante.\nLes données rasters sont la base des images d’arrière-plan utilisées dans les cartes Web et constituent une source essentielle de données géographiques depuis les débuts de la photographie aérienne et des dispositifs de télédétection par satellite.\nLes rasters agrègent spatialement des informations à une résolution donnée. Ils maintiennent ainsi une consistance temporelle sur de grandes superficies (de nombreux jeux de données rasters sont disponibles à l’échelle planétaire).Que faut-il utiliser ?\nLa réponse dépend probablement de votre domaine d’application :Les données vectorielles ont tendance à dominer les sciences sociales parce que les constructions humaines ont tendance à avoir des frontières discrètes.Les données rasters dominent de nombreuses sciences de l’environnement en raison de la dépendance aux données de télédétection.Il y beaucoup de chevauchements dans certains domaines et les ensembles de données rasters et vectorielles peuvent être utilisés conjointement :\nles écologistes et les démographes, par exemple, utilisent couramment les deux.\nEn outre, il est possible de les convertir (voir la section 6).\nQue votre travail mobilise plus un type de jeux de données, vectorielles ou rasters, il reste utile de comprendre leurs modèles de données sous-jacents pour bien les utiliser, comme nous le verrons dans les chapitres suivants.\nCe livre utilise les paquets sf et terra pour travailler, respectivement, avec des données vectorielles et des jeux de données raster.","code":""},{"path":"spatial-class.html","id":"données-vectorielles","chapter":"2 La donnée géographique dans R","heading":"2.2 Données vectorielles","text":"Le modèle de données géographiques vectorielles est basé sur des points situés dans un système de coordonnées de référence (CRS).\nLes points peuvent représenter des caractéristiques propres (par exemple, l’emplacement d’un arrêt de bus) ou être reliés entre eux pour former des géométries plus complexes telles que des lignes et des polygones.\nLa plupart des géométries construites avec des points ne sont qu’en deux dimensions (les CRS tridimensionnels contiennent une valeur supplémentaire \\(z\\), représentant généralement la hauteur au-dessus du niveau de la mer).Dans ce système, Londres, par exemple, peut être représentée par les coordonnées c(-0,1, 51,5).\nCela signifie que sa position est -0,1 degré est et 51,5 degrés nord par rapport au point d’origine.\nCe dernier se situe à 0 degré de longitude (le méridien d’origine) et à 0 degré de latitude (l’équateur) dans un CRS géographique (‘long/lat’) (Figure 2.1, panneau de gauche).\nCette même localisation pourrait également être approximée dans un SCR projeté avec des valeurs “Est/Nord” de c(530000, 180000) dans le British National Grid, ce qui signifie que Londres est située à 530 km Est et 180 km Nord de l’origine du SCR.\nCeci peut être vérifié visuellement : un peu plus de 5 “boîtes” — des zones carrées délimitées par les lignes de grille grises de 100 km de large — séparent le point représentant Londres de l’origine (Figure 2.1, panneau de droite).L’emplacement de l’origine de la grille nationale, dans la mer au-delà de la péninsule du sud-ouest de l’Angleterre, garantit que la plupart des lieux du Royaume-Uni auront des valeurs positives en abscisse et ordonnée.8\nLes CRS sont plus complexes, et seront abordées plus en détail dans les sections 2.4 et ??. Cependant pour les besoins de cette section, il suffit de savoir que les coordonnées consistent en deux nombres représentant la distance par rapport à un point d’origine, généralement dans les dimensions \\(x\\) puis \\(y\\).\nFIGURE 2.1: Représentation de données vectorielles (ponctuelles) dans laquelle l’emplacement de Londres (X rouge) est représenté par rapport à une origine (le cercle bleu). La carte de gauche représente un SCR géographique dont l’origine se situe à 0° de longitude et de latitude. Le graphique de droite représente un SCR projeté dont l’origine est située dans la mer à l’ouest de la péninsule du sud-ouest anglaise.\nsf fournit des classes informatiques pour les données géographiques vectorielles ainsi qu’une interface en ligne de commande pour des bibliothèques de géocomputation de bas niveau :GDAL, pour la lecture, l’écriture et la manipulation d’une large gamme de formats de données géographiques, couverte dans le chapitre ??PROJ, une puissante bibliothèque pour les transformations de systèmes de coordonnées, qui sous-tend le chapitre ??GEOS, un moteur de géométrie euclidienne pour les opérations telles que le calcul des tampons et des centroïdes sur les données avec un SCR projeté, couvert dans le chapitre 5S2, un moteur de géométrie sphérique écrit en C++ développé par Google, via le paquet s2, couvert dans la section 2.2.9 ci-dessous et dans le chapitre ??.\nLes informations concernant ces interfaces sont indiquées par sf lorsque que celui ci est chargé pour la première fois: via le message Linking GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() TRUE apparue en dessous de la commande library(sf) au tout début de ce chapitre. Ce message indique les versions des bibliothèques liées GEOS, GDAL et PROJ (chiffre pouvant varier au cours du temps et entre les ordinateurs) et si oui ou non l’interface avec S2 est activée.\nAujourd’hui, nous considérons que c’est un acquis, cependant, c’est grâce à l’intégration étroite entre les différentes bibliothèques géographiques qu’un travail de géocomputation reproductible est possible.Une fonctionnalité intéressante de sf est que vous pouvez changer le moteur de géométrie par défaut utilisé sur les données non projetées : “Désactiver” S2 peut être fait avec la commande sf::sf_use_s2(FALSE), ce qui signifie que le moteur de géométrie euclidienne GEOS sera utilisé par défaut pour toutes les opérations de géométrie, y compris celles sur les données non projetées.\nComme nous le verrons dans la Section 2.2.9, la géométrie euclidienne, ou plane, est basée sur un espace à 2 dimensions.\nLes moteurs de géométrie euclidienne tels que GEOS supposent des coordonnées “plates” (projetées), tandis que les moteurs de géométrie sphérique tels que S2 supposent des coordonnées non projetées (lon/lat).Cette section présente les classes sf en préparation des chapitres suivants (les chapitres 5 et ?? couvrent respectivement l’interface GEOS et GDAL)","code":""},{"path":"spatial-class.html","id":"une-introduction-aux-simple-features","chapter":"2 La donnée géographique dans R","heading":"2.2.1 Une introduction aux Simple Features","text":"Simple features ou “entités simples” est un Format ouvert développé et approuvé par l’Open Geospatial Consortium (OGC), une organisation à non lucratif dont nous reviendrons sur les activités dans un chapitre ultérieur (section ??).\nSimple Features est un modèle de données hiérarchique qui représente un large éventail de types géométriques.\nSur les 18 types géométriques pris en charge par la spécification, seuls 7 sont utilisés dans la grande majorité des recherches géographiques (voir Figure 2.2) ;\nces types géométriques de base sont entièrement pris en charge par le paquet R sf (Pebesma 2018).9\nFIGURE 2.2: Les types de Simple features pleinement disponibles dans sf.\nsf peut représenter tous les types de géométrie vectorielle courants (les classes de données raster ne sont pas prises en charge par sf) : points, lignes, polygones et leurs versions “multi” respectives (qui regroupent les caractéristiques du même type en une seule caractéristique).\nsf prend également en charge les collections de géométrie, qui peuvent contenir plusieurs types de géométrie dans un seul objet.\nsf fournit la même fonctionnalité (et plus) que celle fournie précédemment dans trois packages — sp pour les classes de données (Pebesma Bivand 2018), rgdal pour la lecture/écriture de données via une interface avec GDAL et PROJ (Bivand, Keitt, Rowlingson 2018) et rgeos pour les opérations spatiales via une interface avec GEOS (Bivand Rundel 2018).Comme expliqué au chapitre 1, les paquets géographiques de R ont une longue histoire d’interfaçage avec des bibliothèques de niveau inférieur, et sf poursuit cette tradition avec une interface unifiée vers les versions récentes de GEOS pour les opérations de géométrie, la bibliothèque GDAL pour la lecture et l’écriture de fichiers de données géographiques, et la bibliothèque PROJ pour la représentation et la transformation des systèmes de référence de coordonnées projetées.\nGrâce à s2,\n\n\n“une interface avec la bibliothèque de géométrie sphérique de Google [s2] (https://s2geometry.io/), sf également accès à des”mesures et opérations sur des géométries non planes” rapides et précises” (Bivand 2021).\nDepuis la version 1.0.0 de sf, lancée en juin 2021, la fonctionnalité s2 est maintenant utilisée par défaut sur les géométries avec des systèmes de coordonnées géographiques (longitude/latitude), une caractéristique unique de sf qui diffère des bibliothèques spatiales ne prenant en charge que GEOS pour les opérations de géométrie, comme le paquet Python GeoPandas.\nNous aborderons s2 dans les chapitres suivants.\n\nLa capacité de sf à intégrer plusieurs bibliothèques puissantes pour la géoinformatique dans un seul cadre est une réalisation remarquable qui réduit le “coût d’entrée” dans le monde de l’analyse reproductible des données géographiques avec des bibliothèques performantes.\nLa fonctionnalité de sf est bien documentée sur son site web à l’adresse [r-spatial.github.io/sf/] (https://r-spatial.github.io/sf/index.html) contient 7 vignettes.\nCelles-ci peuvent être visualisées hors ligne comme suit :Comme l’explique la première vignette, les objets de type simples features dans R sont stockés dans un tableau de données, les données géographiques occupant une colonne spéciale, généralement nommée “geom” ou “geometry”.\nNous allons utiliser le jeu de données world fourni par la bibliothèque spData, chargé au début de ce chapitre, pour montrer ce que sont les objets sf et comment ils fonctionnent.\nworld est un “tableau de données sf” contenant des colonnes spatiales et attributaires, dont les noms sont retournés par la fonction names() (la dernière colonne dans cet exemple contient les informations géographiques) :Le contenu de cette colonne geom donne aux objets sf leurs propriétés spatiales : world$geom est une ‘colonne de type liste’ qui contient toutes les coordonnées des polygones du pays.\nLes objets sf peuvent être tracés rapidement avec la fonction de base de R, plot() ;\nla commande suivante crée la figure 2.3.\nFIGURE 2.3: Cartes du monde utilisant le paquet sf, avec une dimension pour chaque attribut.\nNotez qu’au lieu de créer une seule carte par défaut pour les objets géographiques, comme le font la plupart des programmes SIG, la fonction plot() sur des objets sf retourne une carte pour chaque variable du jeux de données.\nCe comportement peut être utile pour explorer la distribution spatiale de différentes variables et est abordé plus en détail dans la section 2.2.3.Plus largement, traiter les objets géographiques comme des tableaux de données classiques avec des propriétés spatiales présente de nombreux avantages, surtout si vous avez déjà l’habitude de travailler avec des tableaux de données.\nPar exemple, la fonction très pratique summary(), fournit un aperçu utile des variables de l’objet world.Bien que nous n’ayons sélectionné qu’une seule variable pour la commande summary(), elle produit également un rapport sur la géométrie.\nCela démontre le comportement “permanent” des colonnes de type géométrie des objets sf, cela signifie que la géométrie est conservée à moins que l’utilisateur ne la supprime délibérément, comme nous le verrons dans la Section ??.\nLe résultat fournit un résumé rapide des données spatiales et non spatiales contenues dans world : l’espérance de vie moyenne est de 71 ans (allant de moins de 51 ans à plus de 83 ans avec une médiane de 73 ans) pour tous les pays.Il est important d’examiner de plus près le comportement de base et le contenu de cet objet simple feature, que l’peut utilement considérer comme un “spatial data frames”.Les objets sf sont faciles à extraire: le code ci-dessous extrait ses deux premières lignes et trois premières colonnes de world.\nLa sortie montre deux différences majeures par rapport à un data.frame standard : l’inclusion de données géographiques supplémentaires (geometry type, dimension, bbox et les informations SCR -epsg (SRID),proj4string) ainsi que la présence d'une colonnegeometry, ici nomméegeom` :Tout cela peut sembler assez complexe, surtout pour un système de classes qui est censé être simple.\nCependant, il y de bonnes raisons d’organiser les choses de cette façon et d’utiliser sf.Avant de décrire chaque type de géométrie géré par le paquet sf, il est utile de prendre un peu de recul pour comprendre les éléments constitutifs des objets de type sf.\nLa section 2.2.5 montre comment les objets simples features sont des tableau de données, avec des colonnes géométriques spéciales.\nCes colonnes spatiales sont souvent appelées geom ou geometry : ainsi world$geom fait référence à l’élément spatial de l’objet world décrit plus haut.\nCes colonnes géométriques sont des “colonnes de type liste” de la classe sfc (voir la section 2.2.7).\nPuis, à leur tour, les objets sfc sont composés d’un ou plusieurs objets de la classe sfg : des géométries d’entités simples que nous décriverons dans la section 2.2.6.\nPour comprendre comment fonctionnent les composantes spatiales des entités simples, il est essentiel de comprendre comment leurs géométries sont prises en comptes.\nC’est pourquoi nous couvrirons chacun des types de géométrie d’entités simples actuellement pris en charge dans la section 2.2.4 puis nous continuerons en montrant comment ils peuvent être représentés dans R avec des objets sf, formés à la base d’objets sfg et sfc.","code":"\nvignette(package = \"sf\") # Qu'elles sont les vignettes disponibles\nvignette(\"sf1\")          # Une introduction à la bibliothèque \nclass(world)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…Le morceau de code précédent utilise `=` pour créer un nouvel objet appelé `world_mini` dans la commande `world_mini = world[1:2, 1:3]`.\nC´est ce qu´on appelle une affectation.\nUne commande équivalente pour obtenir le même résultat est `world_mini <- world[1:2, 1:3]`.\nBien que l´affectation par flèche soit plus couramment utilisée, nous utilisons l´affectation par égalité parce qu´elle est légèrement plus rapide à taper et plus facile à enseigner en raison de sa compatibilité avec les langages couramment utilisés tels que Python et JavaScript.\nL´utilisation de l´un ou l´autre est une question de préférence, tant que vous êtes cohérent (des paquets tels que **styler** peuvent être utilisés pour changer de style)."},{"path":"spatial-class.html","id":"pourquoi-simple-features","chapter":"2 La donnée géographique dans R","heading":"2.2.2 Pourquoi simple features?","text":"Les simple features ou entités simples sont un modèle de données largement utilisé qui sous-tend les structures de données de nombreuses applications SIG, notamment QGIS et PostGIS.\nL’un des principaux avantages de cette approche est que l’utilisation du modèle de données garantit que votre travail est transférable à d’autres configurations, par exemple l’importation et l’exportation vers des bases de données spatiales.\nUne question plus spécifique du point de vue de R est “pourquoi utiliser le paquet sf alors que sp est déjà éprouvé” ?\nIl existe de nombreuses raisons (liées notamment aux avantages du modèle des entités simples) :lecture et écriture rapides des données ;amélioration des performances de représentation graphique ;les objets sf peuvent être traités comme des tableaux de données dans la plupart des opérations ;les noms des fonctions sf sont relativement cohérents et intuitifs (tous commencent par st_) ;les fonctions sf peuvent être combinées à l’aide de l’opérateur |> et fonctionnent bien avec la collection tidyverse des paquets R.L’intégration de sf pour les paquets tidyverse est illustrée avec la fonction de lecture des données géographiques vectorisées: read_sf().\nAu contraire de la fonction st_read() qui va retourner les attributs dans les classes de base R data.frame (et affiche un message de compte rendu plus complet qui dans l’extrait de code ci dessous été omis) la fonction read_sf() va retourner un tidyverse tibble.\nVous en trouvez la démonstration ci-dessous (voir la section ?? sur la lecture et l’écriture des données géographiques vectorielles avec R) :Comme illusté dans le Chapitre 3, montrant la manipulation d’objets `sf avec le tidyverse, sf est désormais la bibliothèquee de référence pour l’analyse des données vectorielles spatiales dans R (sans oublier l’écosystème des paquets spatstat qui fournit de nombreuses fonctions pour les statistiques spatiales).\nDe nombreux paquets populaires reposent sur sf, comme le montre l’augmentation de sa popularité en termes de nombre de téléchargements par jour, comme indiqué dans la section 1.4 du chapitre précédent.\nLa transition de paquets et de chaînes de processus reposant sur les anciens paquets rgeos et rgdal prends du temps (Bivand 2021), mais le processus été acceleré par le sentiments d’urgence par les messages indiquant qu’ils “seraient indisponibles à partir de fin 2023”.\nCela signifie que quiconque utilisant encore ces paquets se doit de “passer aux fonctions de sf/stars/terra pour utiliser GDAL et PROJ le plus rapidement possible.”.En d’autres termes, sf est à l’épreuve du futur mais sp ne l’est pas.\nPour les workflow qui dépendent de l’ancienne classe Spatial, les objets sf peuvent être convertis depuis et vers la classe Spatial du paquet sp comme suit :","code":"\nworld_dfr = st_read(system.file(\"shapes/world.shp\", package = \"spData\"))\n#> Reading layer `world' from data source \n#>   `/usr/local/lib/R/site-library/spData/shapes/world.shp' using driver `ESRI Shapefile'\n#> Simple feature collection with 177 features and 10 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.6\n#> Geodetic CRS:  WGS 84\nworld_tbl = read_sf(system.file(\"shapes/world.shp\", package = \"spData\"))\nclass(world_dfr)\n#> [1] \"sf\"         \"data.frame\"\nclass(world_tbl)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nlibrary(sp)\nworld_sp = as(world, \"Spatial\") # de sf à sp\n# sp functions ...\nworld_sf = st_as_sf(world_sp)           # de sp à sf"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 La donnée géographique dans R","heading":"2.2.3 Réalisation rapide de cartes","text":"Des premiers jets de cartes peuvent être crées dans sf avec plot().\nPar défaut, cela crée un graphique avec de multiple encarts, un encart pour chaque variable de l’objet, comme illustré dans le panneau de gauche de la Figure 2.4.\nUne légende ou “clé” avec une couleur continue est produite si l’objet à tracer une seule variable (voir l’encart de droite).\nLes couleurs peuvent également être définies avec l’argument col =, bien que cela ne permette pas de créer une palette continue ou une légende.\n\nFIGURE 2.4: Cartographie avec sf, avec plusieurs variables (gauche) ou une seule (droite).\nLes graphiques sont ajoutés en tant que couches aux images existantes en ajoutant dans la fonction l’argument add = TRUE.10\nPour illustrer cela et donner un avant-goût du contenu des chapitres 3 et 4 sur les attributs et les opérations sur les données spatiales, l’extrait de code suivant filtre et combine des pays d’Asie en un seul élément :Ainsi, nous pouvons maintenant dessiner le continent asiatique sur une carte du monde.\nNotez que le premier graphique ne doit avoir qu’un seul encart pour que add = TRUE fonctionne.\nSi le premier graphique une légende, reset = FALSE doit être utilisé (résultat non montré) :L’ajout de couches de cette manière peut être utilisé pour vérifier la correspondance géographique entre les couches :\nla fonction plot() est rapide à exécuter et nécessite peu de lignes de code, mais ne permet pas de créer des cartes interactives avec une large gamme d’options.\nPour la réalisation de cartes plus poussées, nous recommandons l’utilisation de paquets de visualisation spécifiques tels que tmap (voir le chapitre ??).Il y plusieurs façons de modifier les cartes avec la méthode plot() de sf.\nComme sf étend les méthodes de base de R, les arguments de plot() tels que main = (qui spécifie le titre de la carte) fonctionnent avec les objets sf (voir ?graphics::plot et ?par).11\nLa figure 2.5 illustre cette flexibilité en superposant sur une carte du monde des cercles dont les diamètres (définis avec l’argument cex =) représentent les populations des pays.\nUne version non projetée de cette figure peut être créée avec les commandes suivantes (voir les exercices à la fin de ce chapitre et le script 02-contplot.R 2.5):\nFIGURE 2.5: Pays coloriés par continent et leur population en 2015 (cercles proportionnels à la population).\nLe code ci-dessus utilise la fonction st_centroid() pour convertir un type de géométrie (polygones) en un autre (points) (voir chapitre 5), dont la représentation varie en fonction de l’argument cex.\nLa méthode plot de sf possède également des arguments spécifiques aux données géographiques. expandBB, par exemple, peut être utilisé pour dessiner un objet sf dans son contexte :\nelle prend un vecteur de quatre nombres qui étend la boîte de délimitation de la carte par rapport à zéro en suivant l’ordre : bas, gauche, haut, droite.\nDans le programme suivant, ce paramètre est utilisé pour représenter l’Inde et ses gigantesques voisins asiatiques, en mettant l’accent sur la Chine à l’est 2.6 (voir les ci-dessous sur l’ajout de texte aux graphiques):12\nFIGURE 2.6: L’Inde et ses pays voisins, exemple d’utilisation du paramètre expandBB.\nNotez l’utilisation de lwddans le code afin de renforcer l’Inde.\nLa section ?? vous équipera d’autres techniques de visualisation pour représenter une gamme de types de géométrie.","code":"\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 La donnée géographique dans R","heading":"2.2.4 Les types de géométries","text":"Les géométries sont les éléments de base des éntités simples.\nCes derniers peuvent prendre dans R l’un des 18 types de géométrie pris en charge par le paquet sf.\nDans ce chapitre, nous nous concentrerons sur les sept types les plus couramment utilisés : POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON et GEOMETRYCOLLECTION.\nLa liste complète des types d’éléments possibles est disponible dans le manuel de PostGIS.En général, le well-known binary (WKB) ou le well-known text (WKT) sont les codages standard pour les géométries simples.\nLes WKB sont généralement représentés par des chaînes hexadécimales facilement lisibles par les ordinateurs.\nC’est pourquoi les SIG et les bases de données spatiales l’utilisent pour transférer et stocker des objets géométriques.\nLe WKT, quant à lui, est une description de balisage textuel lisible par l’homme pour des éntités simples.\nLes deux formats sont échangeables, et si nous en présentons un, nous choisirons naturellement la représentation WKT.La base de chaque type de géométrie est le point.\nUn point est simplement une coordonnée dans un espace 2D, 3D ou 4D (cf. vignette(\"sf1\") pour plus d’informations). Un exemple est disponible sur le second panneau de la figure 2.7:\nPOINT (5 2)\nUne linestring, ligne, est une séquence de points avec une ligne droite reliant ces points, par exemple (cf. le panneau central de la figure 2.7) :LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)Un polygone est une séquence de points qui forment un anneau fermé, sans intersection.\nFermé signifie que le premier et le dernier point d’un polygone ont les mêmes coordonnées (cf. le panneau de droite de la figure 2.7).13\nPolygone sans anneau intérieur: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Exemple de géometries de point, ligne et polygone.\nJusqu’à présent, nous avons créé des géométries avec une seule entité géométrique par élément.\nToutefois, sf permet également l’existence de plusieurs géométries au sein d’une même entité (d’où le terme “collection de géométries”) en utilisant la version “multi” de chaque type de géométrie :\nMultipoint: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilinestring: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolygon: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Examples de multi* geometries.\nEnfin, une collection de géométries peut contenir n’importe quelle combinaison de géométries, y compris des (multi)points et des lignes (voir figure 2.9) :\nGeometry collection: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Exemple de collection de géometrie.\n","code":""},{"path":"spatial-class.html","id":"sf","chapter":"2 La donnée géographique dans R","heading":"2.2.5 La classe sf","text":"Les Simple features ou entités simples sont composés de deux parties principales : les géométries et les attributs non géographiques.\nLa figure 2.10 montre comment un objet sf est créé – les géométries proviennent d’un objet sfc, tandis que les attributs sont pris dans un data.frame ou un tibble.\nLes sections 2.2.6 et 2.2.7 reprennent la création de géometries sf à partir de rien.\nFIGURE 2.10: Différentes étapes de construction des objets sf.\nLes attributs non géographiques permettent la représentation du nom de l’entité ou d’autres attributs, mesures, appartenance à des groupes et autres.\nPour l’illustrer nous allons représenter une température de 25°C à Londres le 21 juin 2017.\nCet exemple à une géométrie (les coordonnées) et trois attributs de trois classes différentes (le nom, la température et la date).14\nLes objets de la classe sf représentent de telles données en combinant les attributs (data.frame) avec la colonne de géométrie simple feature (sfc).\nIls sont créés avec st_sf(), comme l’illustre le code ci-dessous, créant l’exemple londonien :Que s’est-il passé ? Premièrement, les coordonnés ont été utilisées pour créer la simple feature geometry (sfg).\nDeuxièmement, la géométrie été convertie en une colonne de type simple feature (sfc), avec un SCR.\nTroisièmement, les attributs ont été stockés dans un data.frame, qui été combiné avec l’objet sfc avec st_sf().\nLe résultat est un objet sf, comme montré ci-dessous (une partie de la sortie de code est omise) :Le résultat montre que les objets sf ont en fait deux classes informatiques, sf et data.frame.\nLes entités simples sont simplement des tableaux de données mais avec un attribut spatial stocké dans une colonne de type liste, souvent nommée geometry, comme décrit dans la section ??.\nCette dualité est au coeur du concept d’éntités simple:\nla plupart du temps un objet sf peut être traité comme un data.frame et se comporté comme tel.\nLes entités simples sont, par essence, des tableaux de données avec une extension spatiale.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # objet sfg\nlnd_geom = st_sfc(lnd_point, crs = 4326)           # objet sfc\nlnd_attrib = data.frame(                           # objet data.frame\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # objet sf\nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"sfg","chapter":"2 La donnée géographique dans R","heading":"2.2.6 Simple feature geometries (sfg)","text":"La classe sfg représente les différents types de géométrie des éntités simples dans R : point, ligne, polygone (et leurs équivalents “multi”, comme les multipoints) ou collection de géométries.\nEn général, la tâche fastidieuse de création de géométries vous est épargnée car vous pouvez simplement importer un fichier spatial déjà existant.\nCependant, il existe un ensemble de fonctions permettant de créer des objets géométriques simple feature (sfg) à partir de zéro si nécessaire.\nLes noms de ces fonctions sont simples et cohérents, ils commencent tous par le préfixe st_ et se terminent par le nom du type de géométrie en lettres minuscules :Un point : st_point()Une ligne : st_linestring()Un polygone: st_polygon()Un multipoint: st_multipoint()Une multiligne : st_multilinestring()Un multipolygone : st_multipolygon()Une collection de géométries : st_geometrycollection()Les objets sfg peuvent être créés à partir de trois de types de données de R:Un vecteur numérique: un point uniqueUn matrice: un ensemble de points, où chaque ligne représente un point, un multipoint ou une ligneUne liste: une collection d’objets comme des matrices, des multilignes ou des collections de géométries.La fonction st_point() crée un point à partir de vecteurs numériques :Les sorties montrent que les types de points XY (coordonnées 2D), XYZ (coordonnées 3D) et XYZM (3D avec une variable supplémentaire, généralement la précision de mesure) sont créés à partir de vecteurs de longueur 2, 3 et 4, respectivement.\nLe type XYM doit être spécifié en utilisant l’argument dim (qui est l’abréviation de dimension).En revanche, vous devez utiliser des matrices dans le cas des objets multipoints (st_multipoint()) et ligne (st_linestring()) :Enfin, vous devez utiliser les listes pour la création de multilignes, de (multi-)polygones et de collections de géométries :","code":"\nst_point(c(5, 2))                 # point en XY\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # point en XYZ\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # point en XYM\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # point en XYZM\n#> POINT ZM (5 2 3 1)\n# la fonction rbind simplifie la création de matrices\n## MULTIPOINT\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LIGNE\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLYGONE\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLYGONE avec un trou\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILIGNE\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLYGONE\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## COLLECTIONS DE GEOMETRIES\ngeometrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(geometrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 La donnée géographique dans R","heading":"2.2.7 Simple feature columns (sfc)","text":"Un objet sfg ne contient qu’un seul élément géométrique simple feature.\nUne colonne de géométrie simple feature (sfc) est une liste d’objets sfg, qui peut en outre contenir des informations sur le système de référence des coordonnées utilisé.\nPar exemple, pour combiner deux entités simples en un seul objet avec deux entités, nous pouvons utiliser la fonction st_sfc().\nC’est important car sfc va correspondre à la colonne de géométrie dans les tableaux de données sf :Dans la plupart des cas, un objet sfc contient des objets du même type géométrique.\nPar conséquent, lorsque nous convertissons des objets sfg de type polygone en une colonne géométrique simple feature, nous obtenons également un objet sfc de type polygone, ce qui peut être vérifié avec st_geometry_type().\nDe même, une colonne géométrique de multilignes donnera un objet sfc de type multiligne :C’est aussi possible de créer un objet sfc à partir d’objets sfg de géométries différentes.Comme indiqué précédemment, les objets sfc peuvent également stocker de l’information sur le système de coordonnées et de référence (CRS).\nLa valeur par défaut est NA (Available) et elle peut être vérifiée avec st_crs() :Toutes les géométries des objets sfc doivent avoir le même SCR.\nUn SCR peut être spécifié avec l’argument crs de st_sfc() (ou st_sf()), il prend un identifiant CRS fourni sous forme de chaîne de texte, comme crs = \"EPSG:4326\" (voir la section ?? pour détails et mieux comprendre ce que cela signifie)","code":"\n# POINT sfc\npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# sfc POLYGON\npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# sfc MULTILINESTRING\nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# GEOMETRIE sfc \npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# Paramètrer le SCR avec un identifiant 'EPSG':\npoints_sfc_wgs = st_sfc(point1, point2, crs = \"EPSG:4326\")\nst_crs(points_sfc_wgs) # indique le SCR (seulement les 4 premières lignes sont montrées)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#> ..."},{"path":"spatial-class.html","id":"le-paquet-sfheaders","chapter":"2 La donnée géographique dans R","heading":"2.2.8 le paquet sfheaders","text":"sfheaders est un paquet pour R qui accélère la construction, la conversion et la manipulation d’objets sf (Cooley 2020).\nIl se focalise sur la construction rapide d’objets sf à partir de vecteurs, matrices et tableaux de données, sans dépendre de la bibliothèque sf ; en exposant son code C++ sous-jacent à travers des fichiers d’en-tête (d’où le nom, sfheaders).\nCette approche permet à d’autres de l’étendre en utilisant un code compilé et rapide.\nChaque fonction de base de sfheaders une implémentation C++ correspondante, comme décrit dans la vignette Cpp.\nPour la plupart des gens, les fonctions R seront plus que suffisantes pour bénéficier de la vitesse de calcul du paquet.\nsfheaders été développé séparément de sf, mais vise à être totalement compatible, en créant des objets sf valides du type décrit dans les sections précédentes.Les cas le plus simple d’utilisation de sfheaders sont présentés dans les morceaux de code ci-dessous avec des exemples de construction d’objets sfg, sfc, et sf :un vecteur converti en sfg_POINT;une matrice convertie en sfg_LINESTRING;un tableau de données converti en sfg_POLYGON.Nous allons commencer par créer l’objet sfg le plus simple possible, une seule paire de coordonnées, assignée à un vecteur nommé v :L’exemple ci-dessus montre comment l’objet sfg v_sfg_sfh est affiché lorsque sf n’est pas chargé, démontrant ainsi sa structure sous-jacente.\nLorsque sf est chargé (comme c’est le cas ici), le résultat de la commande ci-dessus est indiscernable des objets sf :Les exemples suivants montrent comment sfheaders crée des objets sfg à partir de matrices et de tableaux de données :En réutilisant les objets v, m, et df, nous pouvons également construire des colonnes de géométrie simple feature (sfc) comme suit (sorties non montrées) :De même, les objets sf sont crées comme suis:Dans chacun de ces exemples, le SCR (système de coordonnées et de référence) n’est pas défini.\nSi vous prévoyez d’effectuer des calculs ou des opérations géométriques à l’aide des fonctions sf, nous vous recommandons de définir le CRS (voir le chapitre ?? pour plus de détails) :sfheaders est aussi une bonne option pour “déconstruire” et “reconstruire” les objets sf, c’est-à-dire convertir les colonnes géométriques en tableaux de données contenant les coordonnées de chaque sommet (vertex) et les identifiants de chaque éléments géométriques (et d’éventuels géométrie multiples).\nIl est rapide et fiable pour “passer” des colonnes géométriques vers différents types, un sujet traité dans le chapitre 5.\nDes tests, dans la documentation du paquet et dans le code de test développé pour ce livre, montrent qu’il est beaucoup plus rapide que le paquet sf pour de telles opérations.","code":"\nv = c(1, 1)\nv_sfg_sfh = sfheaders::sfg_point(obj = v)\nv_sfg_sfh # affichage sans sf chargé\n#>      [,1] [,2]\n#> [1,]    1    1\n#> attr(,\"class\")\n#> [1] \"XY\"    \"POINT\" \"sfg\" \nv_sfg_sf = sf::st_point(v)\nprint(v_sfg_sf) == print(v_sfg_sfh)\n#> POINT (1 1)\n#> POINT (1 1)\n#> [1] TRUE\n# matrices\nm = matrix(1:8, ncol = 2)\nsfheaders::sfg_linestring(obj = m)\n#> LINESTRING (1 5, 2 6, 3 7, 4 8)\n# data.frames\ndf = data.frame(x = 1:4, y = 4:1)\nsfheaders::sfg_polygon(obj = df)\n#> POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))\nsfheaders::sfc_point(obj = v)\nsfheaders::sfc_linestring(obj = m)\nsfheaders::sfc_polygon(obj = df)\nsfheaders::sf_point(obj = v)\nsfheaders::sf_linestring(obj = m)\nsfheaders::sf_polygon(obj = df)\ndf_sf = sfheaders::sf_polygon(obj = df)\nst_crs(df_sf) = \"EPSG:4326\""},{"path":"spatial-class.html","id":"s2","chapter":"2 La donnée géographique dans R","heading":"2.2.9 géométrie sphérique avec S2","text":"Les moteurs de géométrie sphérique sont basés sur le fait que la terre est ronde alors que les procédures mathématiques simples de géocomputation, telles que le calcul d’une ligne droite entre deux points ou de l’aire délimitée par un polygone, supposent des géométries planes (projetées).\nDepuis la version 1.0.0 de sf, R prend en charge les opérations de géométrie sphérique “d’emblée”, grâce à son interface avec le moteur de géométrie sphérique S2 de Google, via le paquet l’interfaçant s2.\nS2 est peut-être mieux connu comme un exemple de système de grille globale discrète (DGGS).\nUn autre exemple est l’indice spatial hiérarchique hexagonal global H3 (Bondaruk, Roberts, Robertson 2020).Bien que potentiellement utile pour décrire des lieux n’importe où sur la Terre en utilisant des chaînes de caractères telles que e66ef376f790adf8a5af7fca9e6e422c03c9143f, le principal avantage de l’interface de sf avec S2 est l’intégration de fonctions de calculs tels que les calculs de distance, de tampon (buffer) et de surface. Ils sont décrit dans la documentation intégrée de sf qui peut être ouverte avec la commande vignette(\"sf7\").sf peut fonctionner sur deux modes par rapport à S2 : activé et désactivé.\nPar défaut, le moteur de géométrie S2 est activé, comme peut le vérifier avec la commande suivante :Un exemple des conséquences de la désactivation du moteur de géométrie est montré ci-dessous, en créant des tampons autour de l’objet india créé plus tôt dans le chapitre (notez les avertissements émis lorsque S2 est désactivé)\nFIGURE 2.11: Exemple des conséquences de la désactivation du moteur géométrique S2. Les deux représentations d’un tampon autour de l’Inde ont été créées avec la même commande, mais l’objet polygone violet été créé avec S2 activé, ce qui donné un tampon de 1 m. Le polygone vert clair, plus grand, été créé avec S2 désactivé, ce qui donné un tampon inexacte avec des degrés en longitude/latitude.\nDans ce livre, nous supposerons que S2 est activé, sauf indication contraire.\nActivez-le à nouveau avec la commande suivante.","code":"\nsf_use_s2()\n#> [1] TRUE\nindia_buffer_with_s2 = st_buffer(india, 1)\nsf_use_s2(FALSE)\n#> Spherical geometry (s2) switched off\nindia_buffer_without_s2 = st_buffer(india, 1)\n#> Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =\n#> endCapStyle, : st_buffer does not correctly buffer longitude/latitude data\n#> dist is assumed to be in decimal degrees (arc_degrees).\nsf_use_s2(TRUE)\n#> Spherical geometry (s2) switched on"},{"path":"spatial-class.html","id":"les-données-raster","chapter":"2 La donnée géographique dans R","heading":"2.3 Les données raster","text":"Le modèle de données raster représente le monde à l’aide d’une grille continue de cellules (souvent aussi appelées pixels ; Figure 2.12:).\nCe modèle de données fait souvent référence à des grilles dites régulières, dans lesquelles chaque cellule une taille identique et constante - et nous nous concentrerons uniquement sur les grilles régulières dans cet ouvrage.\nCependant, plusieurs autres types de grilles existent, notamment les grilles tournées, cisaillées, rectilignes et curvilignes (voir le chapitre 1 de Pebesma Bivand (2022) ou le chapitre 2 de Tennekes Nowosad (2022)).Un raster se compose généralement d’un en-tête\net d’une matrice (avec des lignes et des colonnes) représentant des cellules équidistantes (souvent aussi nommées pixels; Figure 2.12:).)15\nL’en-tête du raster définit le système de coordonnées de référence, l’étendue et l’origine.\nL’origine (ou point de départ) est souvent la coordonnée du coin inférieur gauche de la matrice (le paquet terra utilise toutefois le coin supérieur gauche, par défaut (Figure 2.12:B)).\nL’en-tête définit l’étendue via le nombre de colonnes, le nombre de lignes et la résolution de la taille des cellules.\nAinsi, en partant de l’origine, nous pouvons facilement accéder à chaque cellule et la modifier, soit en utilisant l’ID d’une cellule (Figure 2.12:B), soit en spécifiant explicitement les lignes et les colonnes.\nCette représentation matricielle évite de stocker explicitement les coordonnées des quatre points d’angle (en fait, elle ne stocke qu’une seule coordonnée, à savoir l’origine) de chaque coin de cellule, comme ce serait le cas pour les polygones vectoriels rectangulaires.\nGrâce à cela et à l’algèbre raster (section ??), le traitement raster est beaucoup plus efficace et rapide que le traitement des données vectorielles.\nCependant, contrairement aux données vectorielles, la cellule d’une couche raster ne peut contenir qu’une seule valeur.\nCette valeur peut être numérique ou catégorique (Figure 2.12:C).\nFIGURE 2.12: Le modèle des données raster: () identifiant des pixels, (B) valeur des pixels, (C) une carte raster colorisée.\nLes rasters représentent généralement des phénomènes continus tels que l’altitude, la température, la densité de population ou des données spectrales.\nLes variables discrètes telles que la classification des sols ou les typologies d’occupation des sols peuvent également être représentées dans le modèle de données raster.\nCes deux utilisations sont illustrées dans la figure 2.13 qui montre que les limites des caractéristiques discrètes peuvent devenir floues dans les ensembles de données matricielles.\nSelon la nature de l’application, les représentations vectorielles des caractéristiques discrètes peuvent être plus adaptées.\nFIGURE 2.13: Exemples de rasters pour des variables continues et catégorielles.\n","code":""},{"path":"spatial-class.html","id":"les-paquets-de-r-pour-travailler-avec-des-rasters","chapter":"2 La donnée géographique dans R","heading":"2.3.1 Les paquets de R pour travailler avec des rasters","text":"Au cours des deux dernières décennies, plusieurs paquets permettant de lire et de traiter des ensembles de données matricielles ont été développés.\nComme indiqué dans la section 1.5, le principal d’entre eux était raster. Il conduit à un changement radical dans les capacités de traitement des rasters avec R lorsqu’il été lancé en 2010 et il dominé ce segment jusqu’au développement de terra et stars.\nDéveloppés plus récemment, ces deux paquets offrent des fonctions puissantes et performantes pour travailler avec des jeux de données raster et ils offrent de nombreuses fonctionnalités communes.\nDans ce livre, nous nous concentrons sur terra, qui remplace raster, plus ancien et (dans la plupart des cas) plus lent.\nAvant de découvrir le fonctionnement du système de classes de terra, cette section décrit les similitudes et les différences entre terra et stars ; ces connaissances aideront à décider lequel est le plus approprié dans différentes situations.Tout d’abord, terra se concentre sur le modèle de données raster le plus courant (grilles régulières), tandis que stars permet également de stocker des modèles moins populaires (notamment des grilles régulières, tournées, cisaillées, rectilignes et curvilignes).\nAlors que terra gère généralement des rasters à une ou plusieurs couches16, le paquet stars fournit des moyens de stocker des cubes de données raster – un objet raster avec de nombreuses couches (par exemple, des bandes), pour plusieurs points dans le temps (par exemple, chaque mois), et de nombreux attributs (par exemple, le type de capteur et le type de capteur B).\nPremièrement, il est important de noter que dans les deux paquets, toutes les couches ou éléments d’un cube de données doivent avoir les mêmes dimensions spatiales et la même étendue.\nDeuxièmement, les deux paquets permettent soit de lire toutes les données raster en mémoire, soit de lire uniquement leurs métadonnées, ce qui est généralement effectué automatiquement en fonction de la taille du fichier d’entrée.\nCependant, ils stockent différement les valeurs associées aux cellules.\nterra est basé sur du code C++ et utilise principalement des pointeurs C++.\nstars stocke les valeurs sous forme de listes de tableaux pour les plus petits rasters ou juste un chemin de fichier pour les plus grands.\nTroisièmement, les fonctions de stars sont étroitement liées aux objets et fonctions vectorielles de sf, alors que terra utilise sa propre classe d’objets pour les données vectorielles, à savoir SpatVector.\nQuatrièmement, les deux paquets approchent différemment la façon dont leurs fonctions agissent sur leurs objets.\nLe paquet terra s’appuie principalement sur un grand nombre de fonctions intégrées, où chaque fonction un spécifique (par exemple, le rééchantillonnage ou le recadrage).\nDe son coté stars propose quelques fonctions intégrées (généralement avec des noms commençant par st_) mais aussi ses propres méthodes pour les fonctions de R (par exemple, split() ou aggregate()) et celles de dplyr (par exemple, filter() ou slice()).Il est important de noter qu’il est facile de convertir des objets de terra en stars (en utilisant st_as_stars()) et inversement (en utilisant rast()).\nNous vous encourageons également à lire Pebesma Bivand (2022) pour l’introduction la plus complète au paquet stars.","code":""},{"path":"spatial-class.html","id":"une-introduction-à-terra","chapter":"2 La donnée géographique dans R","heading":"2.3.2 Une introduction à terra","text":"Le paquet terra prend en charge les objets raster dans R.\nComme son prédécesseur raster (créé par le même développeur, Robert Hijmans), il fournit un ensemble complet de fonctions pour créer, lire, exporter, manipuler et traiter des jeux de données rasters.\nLes fonctionnalités de terra sont en grande partie les mêmes que celles de raster, plus mature, mais il existe quelques différences : les fonctions terra sont généralement plus efficientes en calcul que leurs équivalents raster.\n\nD’autre part, le système de classes de raster est populaire et utilisé par de nombreux autres paquets.\nVous pouvez passer sans problème d’un type d’objet à l’autre pour assurer la compatibilité avec les anciens scripts et paquets, par exemple avec les fonctions raster(), stack() et brick() du paquet raster (cf. le chapitre précédent pour en savoir plus sur l’évolution des paquets R pour travailler avec des données géographiques).En plus des fonctions de manipulation des données matricielles, terra fournit de nombreuses fonctions de bas niveau pouvant servir de base au développement de nouveaux outils pour travailler avec des jeux de données raster.\nterra vous permet également de travailler sur de grands jeux de données raster qui sont trop volumineux pour tenir dans la RAM.\nDans ce cas, terra offre la possibilité de diviser l’image raster en petits morceaux et de les traiter de manière itérative au lieu de charger un fichier entier dans la RAM.Pour l’illustration des concepts terra, nous utiliserons des jeux de données de spDataLarge.\nIl s’agit de quelques objets raster et d’un objet vectoriel couvrant une zone du parc national de Zion (Utah, USA).\nPar exemple, srtm.tif est un modèle numérique de terrain de cette zone (pour plus de détails, voir sa documentation ?srtm).\nTout d’abord, créons un objet SpatRaster nommé my_rast :En tapant le nom du raster dans la console, obtient l’en-tête du raster (dimensions, résolution, étendue, CRS) et quelques informations supplémentaires (classe, source de données, résumé des valeurs du raster) :Des fonctions dédiées renseignent sur chaque composant : dim() renvoie le nombre de lignes, de colonnes et de couches ; ncell() le nombre de cellules (pixels) ; res() la résolution spatiale ; ext() son étendue spatiale ; et crs() son système de coordonnées de référence (la reprojection de raster est traitée dans la section ??).\ninMemory() indique si le raster est stocké en mémoire vive ou sur disque.help(\"terra-package\") renvoie une liste complète de toutes les fonctions terra disponibles.","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nclass(my_rast)\n#> [1] \"SpatRaster\"\n#> attr(,\"package\")\n#> [1] \"terra\"\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 La donnée géographique dans R","heading":"2.3.3 Réalisation de cartes de base","text":"Comme le paquet sf, terra fournit également des méthodes plot() pour ses propres classes.\n\nFIGURE 2.14: Une représentation raster basique.\nIl existe plusieurs autres approches pour représenter des données raster dans R qui sortent du cadre de cette section, notamment :la fonction plotRGB() du paquet terra pour créer une composition colorée rouge-vert-bleu (RGB) basée sur trois couches dans un objet SpatRaster;des paquets tels que tmap pour créer des cartes statiques et interactives d’objets rasters et vectoriels (voir le chapitre ??) ;d’autres fonctions, par exemple levelplot() du paquet rasterVis, pour créer des vignettes, une technique courante pour visualiser les changements dans le temps.","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 La donnée géographique dans R","heading":"2.3.4 Les classes raster","text":"La classe SpatRaster représente les rasters dans terra.\nLa façon la plus simple de créer un objet raster dans R est de lire un fichier raster à partir du disque ou d’un serveur (Section ??.\nLe paquet terra supporte de nombreux pilotes grâce à la bibliothèque GDAL.\nLes rasters provenant de fichiers ne sont généralement pas lus entièrement en RAM, à l’exception de leur en-tête et d’un pointeur vers le fichier lui-même.Les rasters peuvent aussi être créés à partir de zéro en utilisant la même fonction rast().\nCeci est illustré dans l’extrait de code suivant créant un nouvel objet SpatRaster.\nCe raster consiste en 36 cellules (6 colonnes et 6 lignes spécifiées par nrows et ncols) centrées autour du Méridien d’origine et de l’Équateur (voir les paramètres xmin, xmax, ymin et ymax).\nLe SCR par défaut des objets rasters est WGS84, mais peut être changé avec l’argument crs.\nCela signifie que l’unité de résolution est en degrés, que nous fixons à 0.5 (resolution).\nDes valeurs (vals) sont assignées à chaque cellule : 1 à la cellule 1, 2 à la cellule 2, et ainsi de suite.\nRappelez-vous : rast() remplit les cellules par ligne (contrairement à matrix()) en commençant par le coin supérieur gauche, ce qui signifie que la première ligne contient les valeurs 1 à 6, la seconde 7 à 12, etc.?rast permet de découvrir d’autre façons de créer des objets rasters.La classe SpatRaster gère également les couches multiples, qui correspondent généralement à un seul fichier satellite multispectral ou à une série temporelle de rasters.nlyr() fournit le nombre de couches stockées dans un objet SpatRaster :Pour les objets raster multi-couches, les couches peuvent être sélectionnées avec terra::subset()17\nqui accepte un numéro ou un nom de couche comme second argument :L’opération inverse, qui consiste à combiner plusieurs objets SpatRaster en un seul, peut être réalisée à l’aide de la fonction c :","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : landsat_1, landsat_2, landsat_3, landsat_4 \n#> min values  :      7550,      6404,      5678,      5252 \n#> max values  :     19071,     22051,     25780,     31961\nnlyr(multi_rast)\n#> [1] 4\nmulti_rast3 = subset(multi_rast, 3)\nmulti_rast4 = subset(multi_rast, \"landsat_4\")\nmulti_rast34 = c(multi_rast3, multi_rast4)"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 La donnée géographique dans R","heading":"2.4 Les systèmes de référence des coordonnées","text":"\nLes types de données spatiales vectorielles et rasters partagent des concepts intrinsèques aux données spatiales.\nLe plus fondamental d’entre eux est peut-être le système de référence des coordonnées (CRS), qui définit la manière dont les éléments spatiaux des données se rapportent à la surface de la Terre (ou d’autres corps).\nLes CRS sont soit géographiques, soit projetés, comme nous l’avons présenté au début de ce chapitre (voir Figure 2.1).\nCette section reprend chaque type, posant ainsi les bases du chapitre ??, qui offre une plongée en profondeur dans la configuration, la transformation et l’interrogation des SCR.","code":""},{"path":"spatial-class.html","id":"les-systèmes-de-coordonnées-géographiques","chapter":"2 La donnée géographique dans R","heading":"2.4.1 Les systèmes de coordonnées géographiques","text":"\nLes systèmes de coordonnées géographiques identifient tout emplacement sur la surface de la Terre à l’aide de deux valeurs — la longitude et la latitude (voir le panneau gauche de la figure 2.16).\nLa longitude est la position dans la direction est-ouest en distance angulaire par rapport au plan du méridien d’origine.\nLa latitude est la distance angulaire au nord ou au sud du plan équatorial.\nLes distances dans les SCR géographiques ne sont donc pas mesurées en mètres.\nCela des conséquences importantes, comme le montre la section ??.La surface de la Terre dans les systèmes de coordonnées géographiques est représentée par une surface sphérique ou ellipsoïdale.\nLes modèles sphériques supposent que la Terre est une sphère parfaite d’un rayon donné. Ils ont l’avantage de la simplicité mais, en même temps, ils sont inexacts : la Terre n’est pas une sphère !\nLes modèles ellipsoïdaux sont définis par deux paramètres : le rayon équatorial et le rayon polaire.\nIls sont adaptés car la Terre est comprimée : le rayon équatorial est environ 11,5 km plus long que le rayon polaire (Maling 1992).18Les ellipsoïdes font partie d’un composant plus large des CRS : le datum.\nIl contient des informations sur l’ellipsoïde à utiliser et la relation précise entre les coordonnées cartésiennes et l’emplacement sur la surface de la Terre.\nIl existe deux types de datum — géocentrique (tel que WGS84) et local (tel que NAD83).\nVous pouvez voir des exemples de ces deux types de référentiels dans la figure 2.15.\nLes lignes noires représentent un * datum géocentrique, dont le centre est situé au centre de gravité de la Terre et n’est pas optimisé pour un emplacement spécifique.\nDans un datum référentiel*, représenté par une ligne pointillée violette, la surface ellipsoïdale est décalée pour s’aligner sur la surface à un endroit particulier.\nCela permet de prendre en compte les variations locales de la surface de la Terre, dues par exemple à de grandes chaînes de montagnes, dans un SCR local.\npeut le voir sur la figure 2.15, où le système de référence local est adapté à la région des Philippines, mais n’est pas aligné avec la majeure partie du reste de la surface de la planète.\nLes deux référentiels de la figure 2.15 sont placés au-dessus d’un géoïde - un modèle du niveau moyen des mers à l’échelle mondiale 19.\nFIGURE 2.15: Données géocentriques et géodésiques locales représentées sur un géoïde (en fausses couleurs et avec un facteur d’échelle de 10 000 pour l’exagération verticale). L’image du géoïde est adaptée du travail de Ince et al. (2019).\n","code":""},{"path":"spatial-class.html","id":"les-systèmes-de-coordonnées-projetés","chapter":"2 La donnée géographique dans R","heading":"2.4.2 Les systèmes de coordonnées projetés","text":"\nTous les CRS projetés sont basés sur un CRS géographique, décrit dans la section précédente, et s’appuient sur des projections cartographiques pour convertir la surface tridimensionnelle de la Terre en valeurs d’abscisses et d’ordonnées (x et y) dans un CRS projeté.\nLes CRS projetés reposent sur des coordonnées cartésiennes sur une surface implicitement plane (panneau de droite de la figure 2.16).\nIls ont une origine, des axes x et y, et une unité de mesure linéaire telle que le mètre.Cette transition ne peut se faire sans ajouter certaines déformations.\nPar conséquent, certaines propriétés de la surface de la Terre sont déformées au cours de ce processus, telles que la superficie, la direction, la distance et la forme.\nUn système de coordonnées projeté ne peut préserver qu’une ou deux de ces propriétés.\nLes projections sont souvent nommées en fonction de la propriété qu’elles préservent : la projection de surface égale préserve l’aire, la projection azimutale préserve la direction, la projection équidistante préserve la distance et la projection conforme préserve la forme locale.Il existe trois groupes principaux de types de projection : conique, cylindrique et plane (azimutale).\nDans une projection conique, la surface de la Terre est projetée sur un cône le long d’une seule ligne de tangence ou de deux lignes de tangence.\nLes distorsions sont minimisées le long des lignes de tangence et augmentent avec la distance à ces lignes dans cette projection.\nElle est donc mieux adaptée aux cartes des zones de latitude moyenne.\nUne projection cylindrique représente la surface sur un cylindre.\nCette projection peut également être créée en plaçant la surface de la Terre le long d’une seule ligne de tangence ou de deux lignes de tangence.\nLes projections cylindriques sont le plus souvent utilisées pour cartographier le monde entier.\nUne projection plane projette les données sur une surface plate en touchant le globe en un point ou le long d’une ligne de tangence.\nElle est généralement utilisée pour cartographier les régions polaires.\nsf_proj_info(type = \"proj\") donne une liste des projections disponibles supportées par la bibliothèque PROJ.Un résumé rapide des différentes projections, de leurs types, de leurs propriétés et de leur adéquation peut être trouvé dans “Map Projections” (1993) et sur https://www.geo-projections.com/.\nNous nous étendrons sur les CRS et expliquerons comment projeter d’un SCR à un autre dans le chapitre ??.\nPour l’instant, il suffit de savoir :Les systèmes de coordonnées sont un élément clé des objets géographiques.Il est important de savoir dans quel CRS se trouvent vos données, et s’il s’agit d’un système géographique (lon/lat) ou d’un système projeté (généralement en mètres), car cela des conséquences sur la façon dont R gère les opérations spatiales et géométriques.Les CRS des objets sf peuvent être interrogés avec la fonction st_crs(), les CRS des objets terra peuvent être interrogés avec la fonction crs().\nFIGURE 2.16: Exemples de systèmes de coordonnées géographiques (WGS 84 ; à gauche) et projetées (NAD83 / UTM zone 12N ; à droite) pour un type de données vectorielles.\n","code":""},{"path":"spatial-class.html","id":"unités","chapter":"2 La donnée géographique dans R","heading":"2.5 Unités","text":"Une caractéristique importante des SCR est qu’ils contiennent des informations sur les unités spatiales.\nDe toute évidence, il est essentiel de savoir si les mesures d’une maison sont en pieds ou en mètres, et il en va de même pour les cartes.\nIl est de bonne pratique cartographique d’ajouter une barre d’échelle ou un autre indicateur de distance sur les cartes afin de démontrer la relation entre les distances sur la page ou l’écran et les distances sur le terrain.\nDe même, il est important de spécifier formellement les unités dans lesquelles les données géométriques ou les cellules sont mesurées afin de fournir un contexte et de garantir que les calculs ultérieurs sont effectués dans ce contexte.Une nouvelle caractéristique des données géométriques dans les objets sf est qu’elles ont un support natif pour les unités.\nCela signifie que les calculs de distance, de surface et autres calculs géométriques dans sf renvoient des valeurs accompagnées d’un attribut units, défini par le paquet units (Pebesma, Mailund, Hiebert 2016).\nCeci est avantageux, car cela évite la confusion causée par les différentes unités (la plupart des SCR utilisent les mètres, certains les pieds) et fournit des informations sur la dimensionnalité.\nCeci est démontré dans le morceau de code ci-dessous, qui calcule la superficie du Luxembourg :\nLa sortie est en unités de mètres carrés (m2), montrant que le résultat représente un espace bidimensionnel.\nCette information, stockée sous forme d’attribut (que les lecteurs intéressés peuvent découvrir avec attributs(st_area(luxembourg))), peut alimenter des calculs ultérieurs qui utilisent des unités, comme la densité de population (nombre de personnes par unité de surface, typiquement par km2).\nLe fait de déclarer les unités permet d’éviter toute confusion.\nPour reprendre l’exemple du Luxembourg, si les unités n’étaient pas précisées, pourrait supposer à tort que les unités sont en hectares.\nPour traduire ce chiffre énorme en une taille plus digeste, il est tentant de diviser les résultats par un million (le nombre de mètres carrés dans un kilomètre carré)Cependant, le résultat est alors donné de manière incorrecte en mètres carrés.\nLa solution consiste à définir les unités correctes avec le paquet units :Les unités sont tout aussi importantes dans le cas des jeux de données raster.\nCependant, jusqu’à présent, sf est le seul paquet spatial qui supporte les unités, ce qui signifie que les personnes travaillant sur des données raster doivent aborder les changements d’unités d’analyse (par exemple, la conversion de la largeur des pixels des unités impériales aux unités décimales) avec précaution.\nL’objet my_rast (voir ci-dessus) utilise une projection WGS84 avec des degrés décimaux comme unités.\nPar conséquent, sa résolution est également donnée en degrés décimaux, mais il faut le savoir, puisque la fonction res() renvoie simplement un vecteur numérique.Si nous utilisions la projection UTM, les unités changeraient.Encore une fois, la commande res() renvoie un tableau numérique sans unité, ce qui nous oblige à savoir que l’unité de la projection UTM est le mètre.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # nécessite le paquet s2 des récentes version de sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)\n#> [1] 83.5 83.5"},{"path":"spatial-class.html","id":"ex2","chapter":"2 La donnée géographique dans R","heading":"2.6 Exercises","text":"E1. Utilisez summary() sur la colonne géométrie de l’objet de données world qui est inclus dans le paquet spData. Qu’en déduisez vous sur :Son type de géométrie ?Le nombre de pays ?Son système de coordonnées et de référence (SCR) ?E2. Exécutez le code qui “généré” la carte du monde dans la section 2.2.3 (Création de cartes de base).\nTrouvez deux similitudes et deux différences entre l’image sur votre ordinateur et celle du livre.Que fait l’argument cex (voir ?plot) ?Pourquoi le paramètre cex -t-il été fixé à sqrt(world$pop) / 10000 ?Bonus : expérimentez différentes façons de visualiser la population mondiale.E3. Utilisez plot() pour créer des cartes du Nigeria et les pays avoisinants (voir section 2.2.3).Ajustez les arguments lwd, col et expandBB de plot().Défi! : lisez la documentation de text() et annotez la carte.E4. Créez un objet SpatRaster vide appelé mon_raster avec 10 colonnes et 10 lignes.\nAttribuez des valeurs aléatoires entre 0 et 10 au nouveau raster et représentez-le.E5. Lisez le fichier raster/nlcd.tif du paquet spDataLarge.\nQuel type d’information pouvez-vous obtenir sur les propriétés de ce fichier ?E6. Regardez le SCR du fichier raster/nlcd.tif du paquet spDataLarge.\nQuel type d’information pouvez-vous en tirer ?","code":""},{"path":"attr.html","id":"attr","chapter":"3 Opérations sur les tables attributaires","heading":"3 Opérations sur les tables attributaires","text":"","code":""},{"path":"attr.html","id":"prérequis-1","chapter":"3 Opérations sur les tables attributaires","heading":"Prérequis","text":"Ce chapitre nécessite l’installation et le chargement des paquets suivant :Il s’appuie également sur spData, qui charge des jeux de données utilisés dans les exemples de ce chapitre :","code":"\nlibrary(sf)      # paquet pour les données vectorielles présenté dans le Chapitre 2\nlibrary(terra)   # paquet pour les données raster présenté dans le Chapitre 2\nlibrary(dplyr)   # paquet du tidyverse pour la manipulation de tableaux de données\nlibrary(spData)  # paquet de données spatiales présenté dans le Chapitre 2"},{"path":"attr.html","id":"introduction","chapter":"3 Opérations sur les tables attributaires","heading":"3.1 Introduction","text":"Les données attributaires sont des informations non spatiales associées à des données géographiques (géométrie).\nUn arrêt de bus en est un exemple simple : sa position est généralement représentée par des coordonnées de latitude et de longitude (données géométriques), en plus de son nom.\nL’arrêt Elephant & Castle / New Kent Road à Londres, par exemple, pour coordonnées -0,098 degrés de longitude et 51,495 degrés de latitude, ce qui peut être représenté par POINT (-0,098 51,495) dans la représentation sfc décrite au chapitre 2.\nLes attributs tels que le nom attribut de élément POINT (pour utiliser la terminologie de Simple Features) sont le sujet de ce chapitre.Un autre exemple est la valeur d’altitude (attribut) pour un pixel spécifique dans les données raster.\nContrairement au modèle de données vectorielles, le modèle de données raster stocke indirectement les coordonnées de la cellule de grille, ce qui signifie que la distinction entre attribut et information spatiale est moins claire.\nPour illustrer ce point, pensez à un pixel dans la 3e ligne et la 4e colonne d’une matrice raster.\nSon emplacement spatial est défini par son indice dans la matrice : déplacez-vous depuis l’origine de quatre cellules dans la direction x (généralement vers l’est et la droite sur les cartes) et de trois cellules dans la direction y (généralement vers le sud et le bas).\nLa résolution de la trame définit la distance pour chaque étape x et y qui est spécifiée dans l’en-tête du fichier.\nL’en-tête est un composant essentiel des ensembles de données raster qui spécifie comment les pixels se rapportent aux coordonnées géographiques (voir également le chapitre 4).Vous apprendrez ainsi à manipuler des objets géographiques en fonction d’attributs, tels que le nom des arrêts de bus, dans un jeux de données vectorielles et l’altitude des pixels dans un jeux de données raster.\nPour les données vectorielles, cela implique des techniques telles que le sous-ensemble et l’agrégation (voir les sections ?? et ??).\nLes sections ?? et 3.2.5 montrent respectivement comment joindre des données à des objets d’entités simples (simple features) à l’aide d’un ID (identifiant) partagé et comment créer de nouvelles variables.\nChacune de ces opérations un équivalent spatial :\nL’opérateur [ de la version de base de R, par exemple, fonctionne pour faire des sous-ensembles d’objets basé sur leur attribut que ces objets soient spatiaux ou non ; vous pouvez également joindre les attributs de deux jeux de données géographiques à l’aide de jointures spatiales.\nC’est une bonne nouvelle : les compétences développées dans ce chapitre sont transférables.\nLe chapitre 4 étend les méthodes présentées ici au monde spatial.Après une exploration en profondeur dans les différents types d’opérations sur les attributs vectoriels, les opérations sur les données attributaires raster sont abordées dans la section ??. Elle montrera comment créer des couches raster contenant des attributs continus et catégoriels et comment extraire les valeurs des cellules d’une ou de plusieurs couches (sous-ensemble raster).\nLa section ?? fournit une vue d’ensemble des calculs matricielles “globaux” qui peuvent être utilisées pour résumer des jeux de données raster entiers.","code":""},{"path":"attr.html","id":"manipulations-des-attributs-de-données-vectorielles.","chapter":"3 Opérations sur les tables attributaires","heading":"3.2 Manipulations des attributs de données vectorielles.","text":"Les jeux de données géographiques vectorielles sont bien supportés dans R grâce à la classe sf, qui étend la classe data.frame de R.\nComme les tableaux de données, les objets sf ont une colonne par variable attributaire (comme le ‘nom’) et une ligne par observation ou entité (par exemple, par station de bus).\nLes objets sf diffèrent des cadres de données de base parce qu’ils ont une colonne geometry de la classe sfc qui peut contenir une gamme d’entités géographiques (points simples et ‘multi’, lignes et polygones) par ligne.\nCeci été décrit dans le chapitre 2, qui démontré comment les méthodes génériques telles que plot() et summary() fonctionnent avec les objets sf.\nsf fournit également des méthodes génériques permettant aux objets sf de se comporter comme des tableaux de données ordinaires, comme le montre l’impression des méthodes de la classe :Beaucoup d’entre elles (aggregate(), cbind(), merge(), rbind() et [) servent à manipuler des tableaux de données.\nrbind(), par exemple, lie deux tableaux de données, l’un “au-dessus” de l’autre.\n$<- crée de nouvelles colonnes.\nUne caractéristique essentielle des objets sf est qu’ils stockent des données spatiales et non spatiales de la même manière, comme des colonnes dans un data.frame.La colonne géométrique des objets sf est typiquement appelée geometry ou geom mais n´importe quel nom peut être utilisé.\nLa commande suivante, par exemple, crée une colonne géométrique nommée g :st_sf(data.frame(n = world$name_long), g = world$geom)Les objets sf peuvent également étendre les classes tidyverse pour les tableaux de données, tibble et tbl.\n.\nAinsi, sf permet d’utiliser toute la puissance des capacités d’analyse de données de R sur les données géographiques, que vous utilisiez les fonctions de base de R ou du tidyverse pour l’analyse des données.\n(Voir Rdatatable/data.table#2273 pour une discussion sur la compatibilité entre les objets sf et le paquet data.table très rapide).\nAvant d’utiliser ces capacités, il est utile de rappeler comment découvrir les propriétés de base des objets de données vectorielles.\nCommençons par utiliser les fonctions de base de R pour découvrir l’ensemble de données world du paquet spData.world contient dix colonnes non-géographiques (et une colonne de liste de géométrie) avec presque 200 lignes représentant les pays du monde.\nLa fonction st_drop_geometry() ne conserve que les données attributaires d’un objet sf, c’est-à-dire qu’elle supprime sa géométrie.Il peut être utile de supprimer la colonne de géométrie avant de travailler avec des données attributaires ; les processus de manipulation des données peuvent s’exécuter plus rapidement lorsqu’ils ne travaillent que sur les attributs et les colonnes de géométrie ne sont pas toujours nécessaires.\nDans la plupart des cas, cependant, il est judicieux de conserver la colonne géométrique, ce qui explique pourquoi cette colonne est “collante” (elle reste après la plupart des opérations sur les attributs, sauf si elle est spécifiquement abandonnée).\nLes opérations de données non spatiales sur les objets sf ne modifient la géométrie d’un objet que lorsque cela est approprié (par exemple, en supprimant les frontières entre les polygones adjacents après l’agrégation).\nDevenir compétent dans la manipulation des données d’attributs géographiques signifie devenir compétent dans la manipulation des tableaux de données.Pour de nombreuses applications, le paquet du tidyverse dplyr offre une approche efficace pour travailler avec des tableaux de données.\nLa compatibilité avec le tidyverse est un avantage de sf par rapport à son prédécesseur sp, mais il y quelques pièges à éviter (voir la vignette supplémentaire tidyverse-pitfalls à geocompr.github.io pour plus de détails).","code":"\nmethods(class = \"sf\") # liste des 12 premières méthodes possibles avec la class sf \n#>  [1] aggregate             cbind                 coerce               \n#>  [4] initialize            merge                 plot                 \n#>  [7] print                 rbind                 [                    \n#> [10] [[<-                  $<-                   show                 \nclass(world) # c'est un objet sf et un (tidy) data.frame\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\ndim(world)   # c'est un objet de deux dimensions avec 177 lignes et 11 colonnes\n#> [1] 177  11\nworld_df = st_drop_geometry(world)\nclass(world_df)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\nncol(world_df)\n#> [1] 10"},{"path":"attr.html","id":"sélection-de-sous-ensemble-dans-des-attributs-de-données-vectorielles","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.1 Sélection de sous-ensemble dans des attributs de données vectorielles","text":"Les méthodes de sélection de sous-ensembles de base de R incluent l’opérateur [ et la fonction subset().\nLes principales fonctions de sélection de sous-ensembles dplyr sont filter() et slice() pour la sélection des lignes, et select() pour la sélection des colonnes.\nCes deux approches préservent les composantes spatiales des données attributaires dans les objets sf, tandis que l’utilisation de l’opérateur $ ou de la fonction dplyr pull() pour retourner une seule colonne d’attribut sous forme de vecteur perdra les données d’attribut, comme nous le verrons plus loin.\nCette section se concentre sur la sélection de sous-ensembles de tableaux de données sf ; pour plus de détails sur les cas de vecteurs et de tableaux de données non géographiques, nous vous recommandons de lire respectivement la section 2.7 de Introduction R (R Core Team, Smith, Team 2021) et le chapitre 4 de Advanced R Programming (Wickham 2019).L’opérateur [ peut sélectionner à la fois les lignes et les colonnes.\nIl est possible de spécifier les éléments à conserver en indiquant leur rang entre crochets, directement après le nom de l’objet de type tableau de données qui les contient.\nLa commande object[, j] signifie ’retourner les lignes représentées par et les colonnes représentées par j, où et j contiennent typiquement des entiers ou des TRUE et FALSE (les index peuvent aussi être des chaînes de caractères, indiquant les noms de lignes ou de colonnes).\nPar exemple, objet[5, 1:3] signifie ’retourner des données contenant la cinquième ligne et les colonnes 1 à 3 : le résultat devrait être un tableau de données avec seulement une ligne et trois colonnes, et une quatrième colonne de géométrie si c’est un objet sf.\nLaisser ou j vide retourne toutes les lignes ou colonnes, donc world[1:5, ] retourne les cinq premières lignes et les 11 colonnes.\nLes exemples ci-dessous illustrent les sélections avec cette syntaxe de base de R.\nDevinez le nombre de lignes et de colonnes dans les tableaux de données sf retournés par chaque commande et vérifiez les résultats sur votre propre ordinateur (cf. la fin du chapitre pour d’autres exercices) :Une démonstration de l’intérêt de l’utilisation de vecteurs logiques pour la sélection est démontrée dans le morceau de code ci-dessous.\nIl crée un nouvel objet, small_countries, contenant les nations dont la surface est inférieure à 10,000 km2 :L’objet intermédiaire i_small (variable indicatrice des petits pays) est un vecteur logique qui peut être utilisé pour sélectionner les sept plus petits pays du monde en fonction de leur superficie.\nUne commande plus concise, qui omet l’objet intermédiaire, génère le même résultat :La fonction de base de R subset() fournit un autre moyen d’obtenir le même résultat :Les fonctions de base de R sont matures, stables et largement utilisées, ce qui en fait un choix solide, en particulier dans les contextes où la reproductibilité et la fiabilité sont essentielles.\nLes fonctions dplyr permettent des flux de travail “ordonnés” que certaines personnes (dont les auteurs de ce livre) trouvent intuitifs et productifs pour l’analyse interactive des données, en particulier lorsqu’elles sont associées à des éditeurs de code tels que RStudio qui permettent l’auto-complétion des noms de colonnes.\nLes fonctions clés pour les sélection dans les tableaux de données (y compris les tableaux de données sf) avec les fonctions dplyr sont démontrées ci-dessous.\n\n\n\nselect() sélectionne les colonnes par nom ou par leur position.\nPar exemple, vous pouvez sélectionner seulement deux colonnes, name_long et pop, avec la commande suivante :Note : comme avec la commande équivalente de base de R (world[, c(\"name_long\", \"pop\")]), la colonne collante geom reste.\nselect() permet également de sélectionner une plage de colonnes à l’aide de l’opérateur : :Vous pouvez supprimer des colonnes spécifiques avec l’opérateur - :Sélectionner et renommer les colonnes en même temps avec la syntaxe nouveau_nom = ancien_nom :Il est intéressant de noter que la commande ci-dessus est plus concise que l’équivalent de base R, qui nécessite deux lignes de code :select() fonctionne également avec des “fonctions d’aide” pour des opérations de sélections plus avancées, notamment contains(), starts_with() et num_range() (voir la page d’aide de ?select pour plus de détails).La plupart des verbes de dplyr retournent un tableau de données, mais vous pouvez extraire une seule colonne comme un vecteur avec pull().\n\n\n\nVous pouvez obtenir le même résultat via la syntaxe de base de R avec les opérateurs de sélection de listes $ et [[, les trois commandes suivantes retournent le même tableau numérique :slice() est l’équivalent pour les lignes de select().\nLe morceau de code suivant, par exemple, sélectionne les lignes 1 à 6 :filter() est l’équivalent pourdplyr de la fonction subset() de R de base.\nElle ne conserve que les lignes correspondant à des critères donnés, par exemple, uniquement les pays dont la superficie est inférieure à un certain seuil, ou dont l’espérance de vie moyenne est élevée, comme le montrent les exemples suivants :L’ensemble des opérateurs de comparaison peut être utilisé dans la fonction filter(), comme illustré dans le tableau 3.1 :TABLE 3.1: Opérateurs de comparaison renvoyant des booléens (TRUE/FALSE).","code":"\nworld[1:6, ]    # sélection de lignes par position\nworld[, 1:3]    # sélection de colonnes par position\nworld[1:6, 1:3] # sélection de lignes et colonnes par position\nworld[, c(\"name_long\", \"pop\")] # sélection de colonnes par leurs noms\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # sélection en utilisant un vecteur logique\nworld[, 888] # un index référençant une colonne non-existante\ni_small = world$area_km2 < 10000\nsummary(i_small) # on confirme le vecteur logique\n#>    Mode   FALSE    TRUE \n#> logical     170       7\nsmall_countries = world[i_small, ]\nsmall_countries = world[world$area_km2 < 10000, ]\nsmall_countries = subset(world, area_km2 < 10000)\nworld1 = dplyr::select(world, name_long, pop)\nnames(world1)\n#> [1] \"name_long\" \"pop\"       \"geom\"\n# toutes les colonnes entre name_long et pop incluses\nworld2 = dplyr::select(world, name_long:pop)\n# toutes les colonnes sauf subregion et area_km2 \nworld3 = dplyr::select(world, -subregion, -area_km2)\nworld4 = dplyr::select(world, name_long, population = pop)\nworld5 = world[, c(\"name_long\", \"pop\")] # sélectionne les colonnes par nom\nnames(world5)[names(world5) == \"pop\"] = \"population\" # renommer les colonnes\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\nslice(world, 1:6)\nworld7 = filter(world ,area_km2 < 10000) # les pays avec une petite surface\nworld7 = filter(world, lifeExp > 82)      # ceux avec une grande espérance de vie"},{"path":"attr.html","id":"enchainement-de-commandes-avec-des-pipes","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.2 Enchainement de commandes avec des pipes","text":"La clé des flux de travail utilisant les fonctions dplyr est l’opérateur ‘pipe’ %>% (ou depuis R 4.1.0 le pipe natif |>), qui tire son nom du pipe Unix | (Grolemund Wickham 2016).\nLes pipes permettent un code expressif : la sortie d’une fonction précédente devient le premier argument de la fonction suivante, permettant l’enchaînement.\nCeci est illustré ci-dessous, dans lequel seuls les pays d’Asie sont filtrés de l’ensemble de données world, l’objet est ensuite sélectionné par les colonnes (name_long et continent) et les cinq premières lignes (résultat non montré).Les lignes de code ci-dessus montrent comment l’opérateur pipe permet d’écrire des commandes dans un ordre précis :\nles commandes ci-dessus sont écrites de haut en bas (ligne par ligne) et de gauche à droite.\nL’alternative à %>% est un appel de fonction imbriqué, ce qui est plus difficile à lire :","code":"\nworld7 = world %>%\n  filter(continent == \"Asia\") %>%\n  dplyr::select(name_long, continent) %>%\n  slice(1:5)\nworld8 = slice(\n  dplyr::select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)"},{"path":"attr.html","id":"agrégation-sur-la-base-des-attributs-de-données-vectorielles","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.3 Agrégation sur la base des attributs de données vectorielles","text":"\nL’agrégation consiste à résumer les données à l’aide d’une ou plusieurs “variables de regroupement”, généralement issues des colonnes du tableau de données à agréger (l’agrégation géographique est traitée au chapitre suivant).\nUn exemple d’agrégation d’attributs est le calcul du nombre d’habitants par continent à partir des données par pays (une ligne par pays).\nLe jeu de données world contient les ingrédients nécessaires : les colonnes pop et continent, respectivement la population et la variable de regroupement.\nLe est de trouver la somme() des populations des pays pour chaque continent, ce qui permet d’obtenir un tableau de données plus petit (l’agrégation est une forme de réduction des données et peut être une première étape utile lorsqu’travaille avec de grands jeux de données).\nCeci peut être fait avec la fonction de base de R aggregate() comme suit :Le résultat est un tableau de données non spatialisées comportant six lignes, une par continent, et deux colonnes indiquant le nom et la population de chaque continent (voir le tableau 3.2 avec les résultats pour les 3 continents les plus peuplés).aggregate() est une fonction générique ce qui signifie qu’elle se comporte différemment en fonction de ses entrées.\nsf fournit la méthode aggregate.sf() qui est activée automatiquement lorsque x est un objet sf et qu’un argument est fourni :L’objet world_agg2 résultant est un objet spatial contenant 8 entités représentant les continents du monde (et les océans).\ngroup_by() %>% summarize() est l’équivalent dplyr de aggregate(): le nom de variable indiqué dans la fonction group_by() spécifie la variable de regroupement et les informations sur ce qui doit être résumé sont passées à la fonction summarize(), comme indiqué ci-dessous :Cette approche peut sembler plus complexe mais elle présente des avantages : flexibilité, lisibilité et contrôle sur les nouveaux noms de colonnes.\nCette flexibilité est illustrée dans la commande ci-dessous, qui calcule non seulement la population mais aussi la superficie et le nombre de pays de chaque continent :Dans le morceau de code précédent, pop, area (sqkm) et n sont des noms de colonnes dans le résultat, et sum() et n() sont les fonctions d’agrégation.\nCes fonctions d’agrégation renvoient des objets sf avec des lignes représentant les continents et des géométries contenant les multiples polygones représentant chaque masse terrestre et les îles associées (cela fonctionne grâce à l’opération géométrique ‘union’, comme expliqué dans la section ??).Combinons ce que nous avons appris jusqu’à présent sur les fonctions dplyr, en enchaînant plusieurs commandes pour résumer les données attributaires des pays du monde entier par continent.\nLa commande suivante calcule la densité de population (avec mutate()), classe les continents selon le nombre de pays qu’ils contiennent (avec dplyr::arrange()), et ne conserve que les 3 continents les plus peuplés (avec top_n()), dont le résultat est présenté dans le Tableau 3.2) :TABLE 3.2: Les 3 continents les plus peuplés classés par densité de population ordonnés par nombre de pays.","code":"\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world,\n                       na.rm = TRUE)\nclass(world_agg1)\n#> [1] \"data.frame\"\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), FUN = sum, \n                       na.rm = TRUE)\nclass(world_agg2)\n#> [1] \"sf\"         \"data.frame\"\nnrow(world_agg2)\n#> [1] 8\nworld_agg3 = world %>%\n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE))\nworld_agg4  = world %>% \n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE), `area (sqkm)` = sum(area_km2), n = n())\nworld_agg5 = world %>% \n  st_drop_geometry() %>%                      # enlève la colonne géométrie pour un gain de temps\n  dplyr::select(pop, continent, area_km2) %>% # sélectionne les colonnes d’intérêt  \n  group_by(continent) %>%                     # regroupe par continents et synthétise:\n  summarize(Pop = sum(pop, na.rm = TRUE), Superficie = sum(area_km2), N = n()) %>%\n  mutate(Densité = round(Pop / Superficie)) %>%     # calcule la densité de population\n  top_n(n = 3, wt = Pop) %>%                  # ne garde que les 3 plus peuplés\n  arrange(desc(N))                            # trie par ordre du nombre de pays"},{"path":"attr.html","id":"jointures-attributaires-de-données-vectorielles","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.4 Jointures attributaires de données vectorielles","text":"La combinaison de données provenant de différentes sources est une tâche courante dans la préparation des données.\nLes jointures le font en combinant des tables basées sur une variable “clé” partagée.\ndplyr possède plusieurs fonctions de jointure, dont left_join() et inner_join() — voir vignette(\"two-table\") pour une liste complète.\nCes noms de fonctions suivent les conventions utilisées dans le langage des base de données SQL (Grolemund Wickham 2016, Chapitre 13) ; leur utilisation pour joindre des ensembles de données non spatiales à des objets sf est l’objet de cette section.\nLes fonctions de jointure dplyr fonctionnent de la même manière sur les tableau de données et les objets sf, la seule différence importante étant la colonne de liste geometry.\nLe résultat des jointures de données peut être un objet sf ou data.frame.\nLe type le plus courant de jointure attributaures sur des données spatiales prend un objet sf comme premier argument et lui ajoute des colonnes à partir d’un data.frame spécifié comme second argument.\nPour découvrir les jointures, nous allons combiner les données sur la production de café avec l’ensemble de données world.\nLes données sur le café sont dans un tableau de données appelé coffee_data du paquet spData (voir ?coffee_data pour plus de détails).\nIl comporte 3 colonnes :\nname_long nomme les principales nations productrices de café et coffee_production_2016 et coffee_production_2017 contiennent les valeurs estimées de la production de café en unités de sacs de 60 kg pour chaque année.\nUne “jointure gauche” (left join), qui préserve le premier ensemble de données, fusionne world avec coffee_data :Comme les données d’entrée partagent une “variable clé” (name_long), la jointure fonctionne sans utiliser l’argument (voir ?left_join pour plus de détails).\nLe résultat est un objet sf identique à l’objet original world mais avec deux nouvelles variables (indexées comme les colonne 11 et 12) sur la production de café.\nCet objet peut être représenté sous forme de carte, comme l’illustre la figure 3.1, générée avec la fonction plot() ci-dessous :\nFIGURE 3.1: Production mondiale de café (milliers de sacs de 60 kg) par pays, 2017. Source : Organisation internationale du café.\nPour que la jointure fonctionne, une “variable clé” doit être fournie dans les deux ensembles de données.\nPar défaut, dplyr utilise toutes les variables dont le nom correspond.\nDans ce cas, les deux objets world_coffee et world contenaient une variable appelée name_long, expliquant le message Joining, = \"name_long\".\nDans la majorité des cas où les noms des variables ne sont pas les mêmes, vous avez deux options :Renommez la variable clé dans l’un des objets pour qu’ils correspondent.Utiliser l’argument pour spécifier les variables de jonction.Cette dernière approche est présentée ci-dessous sur une version renommée de coffee_data :Remarquez que la dénomination initiale est conservée, ce qui signifie que world_coffee et le nouvel objet world_coffee2 sont identiques.\nUne autre caractéristique de l’objet final est qu’il le même nombre de lignes que le jeu de données initial.\nBien qu’il n’y ait que 47 lignes de données dans coffee_data, les 177 enregistrements sont conservés tels quels dans world_coffee et world_coffee2:\nles lignes du jeu de données initial pour lesquelles aucune correspondance n’est trouvée contiennent alors des valeurs NA pour les nouvelles variables relatives à la production de café.\nMais alors, comment procéder pour conserver uniquement les pays dont l’identifiant est présent dans les deux tables ?\nDans ce cas, il faut recourir à une jointure interne, ìnner join:Notez que le résultat de inner_join() ne comporte que 45 lignes contre 47 dans coffee_data.\nQu’est-il arrivé aux lignes restantes ?\nNous pouvons identifier les lignes qui ne correspondent pas en utilisant la fonction setdiff() comme suit :Le résultat montre que “Others” représente une ligne non présente dans la base de données “monde” et que le nom de la “Democratic Republic Congo” représente l’autre ligne :\nil été abrégé, ce qui fait que la jointure l’manqué.\nLa commande suivante utilise une fonction de correspondance de chaîne (regex) du paquet stringr pour confirmer ce que devrait être Congo, Dem. Rep. :Pour résoudre ce problème, nous allons créer une nouvelle version de coffee_data et mettre à jour le nom.\nEn utilisant le tableau de données mis à jour, inner_join() renvoie un résultat avec les 46 pays producteurs de café :Il est également possible d’effectuer une jointure dans l’autre sens : en partant d’un ensemble de données non spatiales et en ajoutant des variables provenant d’un objet spatial en entités simples (simples features).\nCi-dessous, commence avec l’objet coffee_data et ajoute les variables du jeux de données world.\nContrairement aux jointures précédentes, le résultat n’est pas un autre objet simple features , mais un tableau de données sous la forme d’un tibble tidyverse :\nLe résultat d’une jointure tend à correspondre à son premier argument :Cette section couvre la majorité des cas d’utilisation de la jointure.\nPour plus d’informations, nous recommandons Grolemund Wickham (2016), la vignette join dans le paquet geocompkg qui accompagne ce livre, et la documentation du paquet data.table .20\nUn autre type de jointure est la jointure spatiale, traitée dans le chapitre suivant (section ??).","code":"\nworld_coffee = left_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nclass(world_coffee)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world_coffee)\n#>  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n#>  [4] \"region_un\"              \"subregion\"              \"type\"                  \n#>  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n#> [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n#> [13] \"coffee_production_2017\"\nplot(world_coffee[\"coffee_production_2017\"])\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = c(name_long = \"nm\"))\nworld_coffee_inner = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_inner)\n#> [1] 45\nsetdiff(coffee_data$name_long, world$name_long)\n#> [1] \"Congo, Dem. Rep. of\" \"Others\"\n(drc = stringr::str_subset(world$name_long, \"Dem*.+Congo\"))\n#> [1] \"Democratic Republic of the Congo\"\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_match)\n#> [1] 46\ncoffee_world = left_join(coffee_data, world)\n#> Joining, by = \"name_long\"\nclass(coffee_world)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"vec-attr-creation","chapter":"3 Opérations sur les tables attributaires","heading":"3.2.5 Création d’attributs et suppression d’informations spatiales","text":"Souvent, nous souhaitons créer une nouvelle colonne à partir de colonnes déjà existantes.\nPar exemple, nous voulons calculer la densité de population pour chaque pays.\nPour cela, nous devons diviser une colonne de population, ici pop, par une colonne de surface, ici area_km2 avec une unité de surface en kilomètres carrés.\nEn utilisant les fonctions de base de R, nous pouvons écrire :Alternativement, nous pouvons utiliser l’une des fonctions dplyr - mutate() ou transmute().\nmutate() ajoute de nouvelles colonnes à l’avant-dernière position dans l’objet sf (la dernière est réservée à la géométrie) :La différence entre mutate() et transmute() est que ce dernier supprime toutes les autres colonnes existantes (à l’exception de la colonne de géométrie collante) :unite() du paquet tidyr (qui fournit de nombreuses fonctions utiles pour remodeler les ensembles de données, notamment pivot_longer()) colle ensemble des colonnes existantes.\nPar exemple, ici nous voulons combiner les colonnes continent et region_un dans une nouvelle colonne nommée con_reg.\nDe plus, nous pouvons définir un séparateur (ici : deux points :) qui définit comment les valeurs des colonnes d’entrée doivent être jointes, et si les colonnes originales doivent être supprimées (ici : TRUE) :La fonction separate() fait l’inverse de unite() : elle divise une colonne en plusieurs colonnes en utilisant soit une expression régulière, soit les positions des caractères.\nCette fonction provient également du paquetage tidyr.La fonction dplyr rename() et la fonction de base de R setNames() sont utiles pour renommer des colonnes.\nLa première remplace un ancien nom par un nouveau.\nIci, par exemple, elle renomme la longue colonne name_long en un simple name :setNames() change tous les noms de colonnes en une fois, et nécessite un vecteur de caractères avec un nom correspondant pour chaque colonne.\nCeci est illustré ci-dessous et produit le même objet world mais avec des noms très courts :Il est important de noter que les opérations sur les données attributaires préservent la géométrie des entités simples.\nComme mentionné au début du chapitre, il peut être utile de supprimer la géométrie.\nPour ce faire, vous devez la supprimer explicitement.\nPar conséquent, une approche telle que select(world, -geom) sera infructueuse et vous devriez plutôt utiliser st_drop_geometry().21","code":"\nworld_new = world # afin de ne pas écraser nos données\nworld_new$pop_dens = world_new$pop / world_new$area_km2\nworld %>% \n  mutate(pop_dens = pop / area_km2)\nworld %>% \n  transmute(pop_dens = pop / area_km2)\nworld_unite = world %>%\n  unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\nworld_separate = world_unite %>% \n  separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\nworld %>% \n  rename(name = name_long)\nnew_names = c(\"i\", \"n\", \"c\", \"r\", \"s\", \"t\", \"a\", \"p\", \"l\", \"gP\", \"geom\")\nworld %>% \n  setNames(new_names)\nworld_data = world %>% st_drop_geometry()\nclass(world_data)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"manipuler-des-objets-raster","chapter":"3 Opérations sur les tables attributaires","heading":"3.3 Manipuler des objets raster","text":"Contrairement au modèle de données vectorielles sous-tendu par les entités simples (qui représente les points, les lignes et les polygones comme des entités discrètes dans l’espace), les données matricielles représentent des surfaces continues.\nCette section présente le fonctionnement des objets raster en les créant de bout en bout, en s’appuyant sur la section ??.\nEn raison de leur structure unique, les sélections et les autres opérations sur les jeux de données raster fonctionnent d’une manière différente, comme le montre la section ??.\nLe code suivant recrée le jeu de données matricielles utilisé dans la section 2.3.4, dont le résultat est illustré dans la figure 3.2.\nCela montre comment la fonction rast() fonctionne pour créer un exemple de données matricielles nommé elev (représentant les altitudes).Le résultat est un objet raster avec 6 lignes et 6 colonnes (spécifiées par les arguments nrow et ncol), et une étendue spatiale comprise dans les directions x et y (xmin, xmax, ymin, ymax).\nL’argument vals définit les valeurs que chaque cellule contient : des données numériques allant de 1 à 36 dans ce cas.\nLes objets raster peuvent également contenir des valeurs catégorielles de la classe des variables logiques ou factor de R.\nLe code suivant crée les ensembles de données matricielles illustrés dans la figure 3.2 :L’objet raster stocke la table de correspondance ou “Raster Attribute Table” (RAT) correspondante sous la forme d’une liste de tableaux de données, qui peuvent être visualisés avec cats(grain) (cf. ?cats() pour plus d’informations).\nChaque élément de cette liste est une couche du raster.\nIl est également possible d’utiliser la fonction levels() pour récupérer et ajouter de nouveaux niveaux de facteurs ou remplacer des niveaux existants\nFIGURE 3.2: Jeux de données raster avec des valeurs numériques (à gauche) et catégorielles (à droite).\n","code":"\nelev = rast(nrows = 6, ncols = 6, resolution = 0.5, \n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, resolution = 0.5, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\nlevels(grain)[[1]] = c(levels(grain)[[1]], wetness = c(\"wet\", \"moist\", \"dry\"))\n#> Warning: [set.cats] setting categories like this is deprecated; use a two-column\n#> data.frame instead\nlevels(grain)\n#> [[1]]\n#>   value category\n#> 1     0        0\n#> 2     1        1\n#> 3     2        2"},{"path":"attr.html","id":"sélection-sur-des-raster","chapter":"3 Opérations sur les tables attributaires","heading":"3.3.1 Sélection sur des raster","text":"La sélection de données raster est réalisée à l’aide de l’opérateur de base de R [, qui accepte une large gamme d’entrées :\nindexation ligne-colonne ;ID des cellules ;coordonnées (voir la section 4.3.1) ;autre objet spatial (voir la section 4.3.1).Nous ne présentons ici que les deux premières options, car elles peuvent être considérées comme des opérations non spatiales.\nSi nous avons besoin d’un objet spatial pour en sélectionner un autre ou si le résultat est un objet spatial, nous en parlerons comme une sélection spatiale.\nPar conséquent, les deux dernières options seront présentées dans le chapitre suivant (voir la section 4.3.1).Les deux premières options de sous-ensembles sont présentées dans les commandes ci-dessous —\ntoutes deux renvoient la valeur du pixel supérieur gauche dans l’objet raster elev (résultats non montrés) :Les sélections d’objets raster à couches multiples renverront la ou les valeurs des cellules pour chaque couche.\nPar exemple, two_layers = c(grain, elev); two_layers[1] renvoie un tableau de données avec une ligne et deux colonnes — une pour chaque couche.\nPour extraire toutes les valeurs ou des lignes complètes, vous pouvez également utiliser values().Les valeurs des cellules peuvent être modifiées en écrasant les valeurs existantes en conjonction avec une opération de sélection.\nL’exemple de code suivant, par exemple, définit la cellule supérieure gauche de elev à 0 (résultats non montrés) :Laisser les crochets vides est une version raccourcie de values() pour récupérer toutes les valeurs d’un raster.\nPlusieurs cellules peuvent également être modifiées de cette manière :Le remplacement des valeurs des rasters multicouches peut se faire avec une matrice comportant autant de colonnes que de couches et de lignes que de cellules remplaçables (résultats non montrés) :","code":"\n# ligne 1, colonne 1\nelev[1, 1]\n# pixel ID 1\nelev[1]\nelev[1, 1] = 0\nelev[]\nelev[1, c(1, 2)] = 0\ntwo_layers = c(grain, elev) \ntwo_layers[1] = cbind(c(1), c(4))\ntwo_layers[]"},{"path":"attr.html","id":"résumer-les-objets-raster","chapter":"3 Opérations sur les tables attributaires","heading":"3.3.2 Résumer les objets raster","text":"terra contient des fonctions permettant d’extraire des statistiques descriptives pour des rasters entiers.\nL’impression d’un objet raster sur la console en tapant son nom renvoie les valeurs minimales et maximales d’un objet raster.\nsummary() fournit des statistiques descriptives courantes – minimum, maximum, quartiles et nombre de NAs pour les matrices continues et un nombre de cellules de chaque classe pour les matrices catégorielles.\nD’autres opérations de synthèse telles que l’écart-type (voir ci-dessous) ou des statistiques de synthèse personnalisées peuvent être calculées avec global().\nDe plus, la fonction freq() permet d’obtenir le tableau de fréquence des valeurs catégorielles.Les statistiques des données raster peuvent être visualisées de différentes manières.\nDes fonctions spécifiques telles que boxplot(), density(), hist() et pairs() fonctionnent également avec les objets raster, comme le montre l’histogramme créé avec la commande ci-dessous (non montré) :Si la fonction de visualisation souhaitée ne fonctionne pas avec les objets raster, peut extraire les données à représenter à l’aide de values() (section ??).\nLes statistiques descriptives sur des raster font partie des opérations raster dites globales.\nCes opérations, ainsi que d’autres opérations de traitement raster typiques, font partie du traitement algébrique sur raster, qui est abordé dans le chapitre suivant (section ??).\nCertains noms de fonctions sont réutilisés entre les paquets et\nrentrent en conflit(par exemple, une fonction avec le nom\nextract() existe à la fois dans les paquets\nterra et tidyr). En plus de ne pas\ncharger les paquets en se référant verbalement aux fonctions (par\nexemple, tidyr::extract()), une autre façon d’éviter les\nconflits de noms de fonctions est de décharger le paquet en question\navec detach(). La commande suivante, par exemple, décharge\nle paquet terra (ceci peut également être fait dans\nl’onglet package qui se trouve par défaut dans le panneau\ninférieur droit de RStudio) :\ndetach(“package:terra”, unload = TRUE, force = TRUE).\nL’argument force permet de s’assurer que le paquet sera\ndétaché même si d’autres paquets en dépendent. Cependant, cela peut\nconduire à une utilisation restreinte des paquets dépendant du paquet\ndétaché, et n’est donc pas recommandé.\n","code":"\nglobal(elev, sd)\nhist(elev)"},{"path":"attr.html","id":"exercices","chapter":"3 Opérations sur les tables attributaires","heading":"3.4 Exercices","text":"Pour ces exercices, nous allons utiliser les jeux de données us_states et us_states_df du paquetage spData.\nVous devez avoir chargé ce paquet, ainsi que les autres paquets utilisés dans le chapitre sur les opérations d’attributs (sf, dplyr, terra) avec des commandes telles que library(spData) avant de tenter ces exercices :us_states est un objet spatial (de classe sf), contenant la géométrie et quelques attributs (dont le nom, la région, la superficie et la population) des états des États-Unis contigus.\nus_states_df est un tableau de données (de classe data.frame) contenant le nom et des variables supplémentaires (dont le revenu médian et le niveau de pauvreté, pour les années 2010 et 2015) des états américains, y compris l’Alaska, Hawaii et Porto Rico.\nLes données proviennent du United States Census Bureau, et sont documentées dans ?us_states et ?us_states_df.E1. Créez un nouvel objet appelé us_states_name qui ne contient que la colonne NAME de l’objet us_states en utilisant la syntaxe de base de R ([) ou du tidyverse (select()).\nQuelle est la classe du nouvel objet et qu’est-ce qui le rend géographique ?E2. Sélectionnez les colonnes de l’objet us_states qui contiennent des données sur la population.\nObtenez le même résultat en utilisant une commande différente (bonus : essayez de trouver trois façons d’obtenir le même résultat).\nIndice : essayez d’utiliser les fonctions d’aide, telles que contains ou matches du paquet dplyr (voir ?contains).E3. Trouvez tous les États ayant les caractéristiques suivantes (bonus : trouvez et représentez-les) :Appartenir à la région du Midwest.Appartenir à la région Ouest, avoir une superficie inférieure à 250 000 km2et en 2015 une population supérieure à 5 000 000 de résidents (indice : vous devrez peut-être utiliser la fonction units::set_units() ou .numeric()).Appartenant à la région Sud, avoir une superficie supérieure à 150 000 km2et une population totale en 2015 supérieure à 7 000 000 de résidents.E4. Quelle était la population totale en 2015 dans l’ensemble de données us_states ?\nQuel était le minimum et le maximum de la population totale en 2015 ?E5. Combien d’États y -t-il dans chaque région ?E6. Quelle était la population totale minimale et maximale en 2015 dans chaque région ?\nQuelle était la population totale en 2015 dans chaque région ?E7. Effectuez une jointure entre les variables de us_states_df à us_states, et créez un nouvel objet appelé us_states_stats.\nQuelle fonction avez-vous utilisée et pourquoi ?\nQuelle variable est la clé dans les deux ensembles de données ?\nQuelle est la classe du nouvel objet ?E8. us_states_df deux lignes de plus que us_states.\nComment pouvez-vous les trouver ? (indice : essayez d’utiliser la fonction dplyr::anti_join())E9. Quelle était la densité de la population en 2015 dans chaque État ?\nQuelle était la densité de la population en 2010 dans chaque État ?E10. Estimez le changement de la densité de la population entre 2010 et 2015 dans chaque État.\nCalculez ce changement en pourcentages et cartographiez-les.E11. Changez les noms des colonnes dans us_states en minuscules. (Indice : les fonctions d’aide - tolower() et colnames() peuvent vous aider).E12. En utilisant us_states et us_states_df, créez un nouvel objet appelé us_states_sel.\nCe nouvel objet ne doit avoir que deux variables - median_income_15 et geometry.\nChangez le nom de la colonne median_income_15 en Income.E13. Calculez l’évolution du nombre de résidents vivant sous le seuil de pauvreté entre 2010 et 2015 pour chaque État. (Conseil : voir ?us_states_df pour la documentation sur les colonnes traitant du niveau de pauvreté).\nBonus : Calculez l’évolution du pourcentage de résidents vivant sous le seuil de pauvreté dans chaque État.E13. Calculez l’évolution du nombre de résidents vivant sous le seuil de pauvreté entre 2010 et 2015 pour chaque État. (Conseil : voir ?us_states_df pour la documentation sur les colonnes traitant du niveau de pauvreté).\nBonus : Calculez l’évolution du pourcentage de résidents vivant sous le seuil de pauvreté dans chaque État.E15. Créez un raster à partir de zéro avec neuf lignes et colonnes et une résolution de 0,5 degré décimal (WGS84).\nRemplissez-le de nombres aléatoires.\nSélectionnez les valeurs des cellules de chaque coin.E16. Quelle est la classe la plus commune de notre exemple de raster grain (indice : modal) ?E17. Utilisez un histogramme et un boxplot sur le fichier dem.tif du paquet spDataLarge (system.file(\"raster/dem.tif\", package = \"spDataLarge\")).","code":"\nlibrary(sf)\nlibrary(dplyr)\nlibrary(terra)\nlibrary(spData)\ndata(us_states)\ndata(us_states_df)"},{"path":"spatial-operations.html","id":"spatial-operations","chapter":"4 Géotraitements","heading":"4 Géotraitements","text":"","code":""},{"path":"spatial-operations.html","id":"prérequis-2","chapter":"4 Géotraitements","heading":"Prérequis","text":"Ce chapitre nécessité les mêmes paquets que ceux utilisés dans le chapitre 3:Vous devrez également charger deux jeux de données pour cette section 4.3","code":"\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))"},{"path":"spatial-operations.html","id":"introduction-1","chapter":"4 Géotraitements","heading":"4.1 Introduction","text":"Les opérations spatiales, y compris les jointures spatiales entre les ensembles de données vectorielles et les opérations locales et focales sur les ensembles de données raster, constituent une partie essentielle de la géocomputation.\nCe chapitre montre comment les objets spatiaux peuvent être modifiés d’une multitude de façons en fonction de leur emplacement et de leur forme.\nDe nombreuses opérations spatiales ont un équivalent non spatial (par exemple via leurs attributs), de sorte que des concepts tels que la sélection et la jonction de jeux de données démontrés dans le chapitre précédent sont applicables ici.\nCela est particulièrement vrai pour les opérations vectorielles : La section ?? sur la manipulation des tables attributaires fournit la base pour comprendre son équivalent spatial, à savoir la sélection spatial (traitée dans la section ??).\nLa jointure spatiale (section ??) et l’agrégation (section 4.2.6) ont également des contreparties non spatiales, traitées dans le chapitre précédent.Les opérations spatiales diffèrent toutefois des opérations non spatiales à plusieurs égards :\nLes jointures spatiales, par exemple, peuvent être effectuées de plusieurs manières — y compris la mise en correspondance d’entités qui se croisent ou se trouvent à une certaine distance de l’ensemble de données cible — alors que les jointures de table attributaire abordées dans la section ?? du chapitre précédent ne peuvent être effectuées que d’une seule manière (sauf lorsqu’utilise des jointures floues, comme décrit dans la documentation du paquet fuzzyjoin).\nLe type de relation spatiale entre les objets doit être pris en compte lors de l’exécution des opérations spatiales, comme décrit dans la section ??, sur les relations topologiques entre les caractéristiques vectorielles.\nUn autre aspect unique des objets spatiaux est la distance : tous les objets spatiaux sont liés par l’espace et les calculs de distance peuvent être utilisés pour explorer la force de cette relation, comme décrit dans le contexte des données vectorielles à la section ??.Les opérations spatiales sur les rasters comprennent la sélection — traité dans la section 4.3.1 — et la fusion de plusieurs ” tuiles ” raster en un seul objet, comme le montre la section ??.\nL’algèbre de raster couvre une gamme d’opérations qui modifient les valeurs des cellules, avec ou sans référence aux valeurs des cellules environnantes, ce qui est vital pour de nombreuses applications.\nLe concept d’algèbre de raster est présenté dans la section ?? ; les opérations d’algèbre de raster locales, focales et zonales sont traitées respectivement dans les sections ??, ?? et ??. Les opérations d’algèbre globales, qui génèrent des statistiques synthétiques représentant l’ensemble d’un jeu de données raster, et les calculs de distance sur les données raster, sont abordés dans la section ??.\nDans la dernière section avant les exercices (??), le processus de fusion de deux ensembles de données raster est abordé et démontré à l’aide d’un exemple reproductible.","code":""},{"path":"spatial-operations.html","id":"spatial-vec","chapter":"4 Géotraitements","heading":"4.2 Géotraitements sur des données vectorielles","text":"Cette section fournit une vue d’ensemble des opérations spatiales sur les données géographiques vectorielles représentées sous forme de simple features du package sf.\nLa section 4.3 présente les opérations spatiales sur les ensembles de données raster à l’aide des classes et des fonctions du paquet terra.","code":""},{"path":"spatial-operations.html","id":"sélection-spatiale","chapter":"4 Géotraitements","heading":"4.2.1 Sélection spatiale","text":"La sélection spatial est le processus qui consiste à prendre un objet spatial et à renvoyer un nouvel objet contenant uniquement les caractéristiques en relation dans l’espace à un autre objet.\nDe manière analogue à la sélection d’attributs (traité dans la section ??), des sélection de jeux de données sf peuvent être créés avec l’opérateur de crochets ([) en utilisant la syntaxe x[y, , op = st_intersects], où x est un objet sf à partir duquel un sous-ensemble de lignes sera retourné, y est l’objet de sous-ensemble et , op = st_intersects est un argument optionnel qui spécifie la relation topologique (également connue sous le nom de prédicat binaire) utilisée pour faire la sélection.\nLa relation topologique par défaut utilisée lorsqu’un argument op n’est pas fourni est st_intersects() : la commande x[y, ] est identique à x[y, , op = st_intersects] montrée ci-dessus mais pas à x[y, , op = st_disjoint] (la signification de ces relations topologiques et des autres est décrite dans la section suivante).\nLa fonction filter() du tidyverse peut également être utilisée mais cette approche est plus verbeuse, comme nous le verrons dans les exemples ci-dessous.\ndemonstrate spatial subsetting, use nz nz_height datasets spData package, contain geographic data 16 main regions 101 highest points New Zealand, respectively (Figure 4.1), projected coordinate system.\nfollowing code chunk creates object representing Canterbury, uses spatial subsetting return high points region:\nFIGURE 4.1: Exemple de sélection spatiale avec des triangles rouges représentant 101 points hauts en Nouvelle-Zélande, regroupés près de la région centrale de Canterbury (à gauche). Les points dans la région de Canterbury ont été créés avec l’opérateur de sélection [ (surligné en gris, à droite).\nComme pour la sélection d’attributs, la commande x[y, ] (équivalente à nz_height[canterbury, ]) sélectionne les caractéristiques d’une cible x en utilisant le contenu d’un objet source y.\nCependant, au lieu que y soit un vecteur de classe logical ou integer, pour la sélection spatiale, x et y doivent être des objets géographiques.\nPlus précisément, les objets utilisés pour la sélection spatiale de cette manière doivent avoir la classe sf ou sfc : nz et nz_height sont tous deux des jeux de données vectorielles géographiques et ont la classe sf, et le résultat de l’opération renvoie un autre objet sf représentant les caractéristiques de l’objet cible nz_height qui intersectent (dans ce cas, les points hauts qui sont situés dans) la région de canterbury.Diverses relations topologiques peuvent être utilisées pour le sélection spatiale. Elles déterminent le type de relation spatiale que les caractéristiques de l’objet cible doivent avoir avec l’objet de sélection.\nIl peut s’agir de touches (touche), crosses (croisse) ou within (dedans), comme nous le verrons bientôt dans la section ??.\nLe paramètre par défaut st_intersects est une relation topologique ‘attrape-tout’ qui retournera les éléments de la cible qui touchent, croissent ou sont within (dedans) l’objet source ‘sélectionnant’.\nComme indiqué ci-dessus, d’autres opérateurs spatiaux peuvent être spécifiés avec l’argument op =, comme le montre la commande suivante qui renvoie l’opposé de st_intersects(), les points qui ne sont pas en intersection avec Canterbury (voir la section ??) :Pour de nombreuses applications, c’est tout ce que vous aurez besoin de savoir sur les sélections spatiales avec les données vectorielles !\nSi vous êtes impatient d’en savoir plus sur les relations topologiques, au-delà de st_intersects() et st_disjoint(), passez à la section suivante (??).\nSi vous êtes intéressé par les détails, y compris les autres façons de faire des sélections, c’est par ici.Une autre façon d’effectuer une sélection spatiale est d’utiliser les objets retournés par les opérateurs topologiques.\nCes objets peuvent être utiles en soi, par exemple lors de l’exploration du réseau de relations entre des régions contiguës, mais ils peuvent également être utilisés pour sélectionner comme le montre le morceau de code ci-dessous :Le code ci-dessus crée un objet de classe sgbp (un prédicat binaire de géométrie “creuse”, une liste de longueur x dans l’opération spatiale) et le convertit ensuite en un vecteur logique sel_logical (contenant seulement les valeurs TRUE et FALSE, quelque chose qui peut aussi être utilisé par la fonction filtre de dplyr).\nLa fonction lengths() identifie les éléments de nz_height qui ont une intersection avec tout objet de y.\nDans ce cas, 1 est la plus grande valeur possible, mais pour des opérations plus complexes, peut utiliser la méthode pour sélectionner uniquement les caractéristiques qui ont une intersection avec, par exemple, 2 caractéristiques ou plus de l’objet source.Le même résultat peut être obtenu avec la fonction de sf st_filter() qui été créée pour augmenter la compatibilité entre les objets sf et les manipulation de données de dplyr :ce stade, il y trois versions identiques (à l’exception des noms de lignes) de canterbury_height, une créée en utilisant l’opérateur [, une créée via un objet de sélection intermédiaire, et une autre utilisant la fonction de commodité de sf st_filter().\n\n\nLa section suivante explore différents types de relations spatiales, également connues sous le nom de prédicats binaires, qui peuvent être utilisées pour identifier si deux éléments sont spatialement liés ou non.","code":"\ncanterbury = nz %>% filter(Name == \"Canterbury\")\ncanterbury_height = nz_height[canterbury, ]\nnz_height[canterbury, , op = st_disjoint]\nsel_sgbp = st_intersects(x = nz_height, y = canterbury)\nclass(sel_sgbp)\n#> [1] \"sgbp\" \"list\"\nsel_sgbp\n#> Sparse geometry binary predicate list of length 101, where the\n#> predicate was `intersects'\n#> first 10 elements:\n#>  1: (empty)\n#>  2: (empty)\n#>  3: (empty)\n#>  4: (empty)\n#>  5: 1\n#>  6: 1\n#>  7: 1\n#>  8: 1\n#>  9: 1\n#>  10: 1\nsel_logical = lengths(sel_sgbp) > 0\ncanterbury_height2 = nz_height[sel_logical, ]\ncanterbury_height3 = nz_height %>%\n  st_filter(y = canterbury, .predicate = st_intersects)"},{"path":"spatial-operations.html","id":"relations-topologiques","chapter":"4 Géotraitements","heading":"4.2.2 Relations topologiques","text":"Les relations topologiques décrivent les relations spatiales entre les objets.\nLes “relations topologiques binaires”, pour leur donner leur nom complet, sont des énoncés logiques (en ce sens que la réponse ne peut être que VRAI ou FAUX) sur les relations spatiales entre deux objets définis par des ensembles ordonnés de points (formant typiquement des points, des lignes et des polygones) en deux dimensions ou plus (Egenhofer Herring 1990).\nCela peut sembler plutôt abstrait et, en effet, la définition et la classification des relations topologiques reposent sur des fondements mathématiques publiés pour la première fois sous forme de livre en 1966 (Spanier 1995), le domaine de la topologie algébrique se poursuivant au 21e siècle (Dieck 2008).Malgré leur origine mathématique, les relations topologiques peuvent être comprises intuitivement en se référant à des visualisations de fonctions couramment utilisées qui testent les types courants de relations spatiales.\nLa figure 4.2 montre une variété de paires géométriques et leurs relations associées.\nLes troisième et quatrième paires de la figure 4.2 (de gauche à droite puis vers le bas) montrent que, pour certaines relations, l’ordre est important : alors que les relations equals, intersects, crosses, touches et overlaps sont symétriques, ce qui signifie que si function(x, y) est vraie, function(y, x) le sera aussi, les relations dans lesquelles l’ordre des géométries est important, comme contains et within, ne le sont pas.\nRemarquez que chaque paire de géométries possède une chaîne “DE-9IM” telle que FF2F11212, décrite dans la section suivante.\n\nFIGURE 4.2: Relations topologiques entre géométries vectorielles, inspirées des figures 1 et 2 d’Egenhofer et Herring (1990). Les relations pour lesquelles la fonction(x, y) est vraie sont imprimées pour chaque paire de géométries, x étant représenté en rose et y en bleu. La nature de la relation spatiale pour chaque paire est décrite par la chaîne de caractères du Dimensionally Extended 9-Intersection Model.\nDans sf, les fonctions testant les différents types de relations topologiques sont appelées binary predicates”, comme décrit dans la vignette Manipulating Simple Feature Geometries, qui peut être consultée avec la commande vignette(\"sf3\"), et dans la page d’aide ?geos_binary_pred.\nPour voir comment les relations topologiques fonctionnent en pratique, créons un exemple simple et reproductible, en nous appuyant sur les relations illustrées dans la Figure 4.2 et en consolidant les connaissances sur la représentation des géométries vectorielles acquises dans un chapitre précédent (Section 2.2.4).\nNotez que pour créer des données tabulaires représentant les coordonnées (x et y) des sommets du polygone, nous utilisons la fonction R de base cbind() pour créer une matrice représentant les points de coordonnées, un POLYGON, et enfin un objet sfc, comme décrit au chapitre 2) :Nous allons créer des géométries supplémentaires pour démontrer les relations spatiales à l’aide des commandes suivantes qui, lorsqu’elles sont tracées sur le polygone créé ci-dessus, se rapportent les unes aux autres dans l’espace, comme le montre la Figure 4.3.\nNotez l’utilisation de la fonction st_as_sf() et de l’argument coords pour convertir efficacement un tableau de données contenant des colonnes représentant des coordonnées en un objet sf contenant des points :\nFIGURE 4.3: Points (point_df 1 à 3), ligne et polygones arrangés pour illustrer les relations topologiques.\nUne première question simple pourrait être : quels sont les points de point_sf en intersection avec le polygone polygon_sfc ?\npeut répondre à cette question par inspection (les points 1 et 3 sont respectivement en contact et à l’intérieur du polygone).\npeut répondre à cette question avec le prédicat spatial st_intersects() comme suit:Le résultat devrait correspondre à votre intuition :\ndes résultats positifs (1) sont retournés pour le premier et le troisième point, et un résultat négatif (représenté par un vecteur vide “(empty)”) pour le deuxième en dehors de la frontière du polygone.\nCe qui peut être inattendu, c’est que le résultat se présente sous la forme d’une liste de vecteurs.\nCette sortie matrice creuse n’enregistre une relation que si elle existe, ce qui réduit les besoins en mémoire des opérations topologiques sur les objets avec de nombreuses entités.\nComme nous l’avons vu dans la section précédente, une matrice dense composée de valeurs TRUE ou FALSE est retournée lorsque sparse = FALSE :Dans la sortie ci-dessus, chaque ligne représente un élément dans l’objet cible (l’argument x) et chaque colonne représente un élément dans l’objet de sélection (y).\nDans ce cas, il n’y qu’un seul élément dans l’objet y polygon_sfc, donc le résultat, qui peut être utilisé pour la sélection comme nous l’avons vu dans la section ??, n’qu’une seule colonne.st_intersects() renvoie TRUE même dans les cas où les éléments se touchent juste : intersects est une opération topologique “fourre-tout” qui identifie de nombreux types de relations spatiales, comme l’illustre la figure 4.2.\nIl y des questions plus restrictives, par exemple : quels sont les points situés à l’intérieur du polygone, et quelles sont les caractéristiques qui sont sur ou qui contiennent une frontière partagée avec y ?\npeut répondre à ces questions de la manière suivante (résultats non montrés) :Notez que bien que le premier point touche la limite du polygone, il n’est pas à l’intérieur de celui-ci ; le troisième point est à l’intérieur du polygone mais ne touche aucune partie de sa frontière.\nL’opposé de st_intersects() est st_disjoint(), qui retourne uniquement les objets qui n’ont aucun rapport spatial avec l’objet sélectionné (ici [, 1] convertit le résultat en vecteur) :La fonction st_is_within_distance() détecte les éléments qui touchent presque l’objet de sélection. La fonction un argument supplémentaire dist.\nIl peut être utilisé pour définir la distance à laquelle les objets cibles doivent se trouver avant d’être sélectionnés.\nRemarquez que bien que le point 2 soit à plus de 0,2 unités de distance du sommet le plus proche de polygon_sfc, il est quand même sélectionné lorsque la distance est fixée à 0,2.\nEn effet, la distance est mesurée par rapport à l’arête la plus proche, dans ce cas la partie du polygone qui se trouve directement au-dessus du point 2 dans la figure ??.\n(Vous pouvez vérifier que la distance réelle entre le point 2 et le polygone est de 0,13 avec la commande st_distance(point_sf, polygon_sfc)).\nLe prédicat spatial binaire “within distance” (es à distance de) est démontré dans l’extrait de code ci-dessous, dont les résultats montrent que chaque point est à moins de 0,2 unité du polygone :","code":"\npolygon_matrix = cbind(\n  x = c(0, 0, 1, 1,   0),\n  y = c(0, 1, 1, 0.5, 0)\n)\npolygon_sfc = st_sfc(st_polygon(list(polygon_matrix)))\nline_sfc = st_sfc(st_linestring(cbind(\n  x = c(0.4, 1),\n  y = c(0.2, 0.5)\n)))\n# créer des points\npoint_df = data.frame(\n  x = c(0.2, 0.7, 0.4),\n  y = c(0.1, 0.2, 0.8)\n)\npoint_sf = st_as_sf(point_df, coords = c(\"x\", \"y\"))\nst_intersects(point_sf, polygon_sfc)\n#> Sparse geometry binary predicate... `intersects'\n#>  1: 1\n#>  2: (empty)\n#>  3: 1\nst_intersects(point_sf, polygon_sfc, sparse = FALSE)\n#>       [,1]\n#> [1,]  TRUE\n#> [2,] FALSE\n#> [3,]  TRUE\nst_within(point_sf, polygon_sfc)\nst_touches(point_sf, polygon_sfc)\nst_disjoint(point_sf, polygon_sfc, sparse = FALSE)[, 1]\n#> [1] FALSE  TRUE FALSE\nst_is_within_distance(point_sf, polygon_sfc, dist = 0.2, sparse = FALSE)[, 1]\n#> [1] TRUE TRUE TRUE"},{"path":"spatial-operations.html","id":"les-chaines-de-9im","chapter":"4 Géotraitements","heading":"4.2.3 Les chaines DE-9IM","text":"Les prédicats binaires présentés dans la section précédente reposent sur le modèle Dimensionally Extended 9-Intersection Model (DE-9IM).\nCe modèle était à l’origine intitulé ” DE + 9IM ” par ses inventeurs, en référence à la ” dimension des intersections des limites, des intérieurs et des extérieurs de deux entités ” (Clementini Di Felice 1995), mais il est désormais désigné par DE-9IM (Shen, Chen, Liu 2018).\nPour démontrer le fonctionnement des chaînes DE-9IM, examinons les différentes façons dont la première paire de géométries peut-être reliée dans la figure 4.2.\nLa figure 4.4 illustre le modèle à 9 intersections (9IM). Elle montre les intersections entre chaque combinaison possible entre l’intérieur, la limite et l’extérieur de chaque objet. Chaque composant du premier objet x est disposé en colonnes et que chaque composant de y est disposé en lignes, un graphique à facettes est créé avec les intersections entre chaque élément mises en évidence.\nFIGURE 4.4: Illustration du fonctionnement du Modèle Dimensionnel Étendu à 9 Intersections (DE-9IM). Les couleurs qui ne figurent pas dans la légende représentent le chevauchement entre les différentes composantes. Les lignes épaisses mettent en évidence les intersections bidimensionnelles, par exemple entre la limite de l’objet x et l’intérieur de l’objet y, illustrées dans la facette supérieure du milieu.\nLes chaînes DE-9IM sont dérivées de la dimension de chaque type de relation.\nDans ce cas, les intersections rouges de la figure 4.4 ont des dimensions de 0 (points), 1 (lignes) et 2 (polygones), comme le montre le tableau 4.1.TABLE 4.1: Tableau montrant les relations entre les intérieurs, les limites et les extérieurs des géométries x et y.En aplatissant cette matrice “ligne par ligne” (c’est-à-dire en concaténant la première ligne, puis la deuxième, puis la troisième), obtient la chaîne 212111212.\nUn autre exemple va permettre d’expliciter ce système :\nla relation représentée sur la figure 4.2 (la troisième paire de polygones dans la troisième colonne et la première ligne) peut être définie dans le système DE-9IM comme suit :Les intersections entre l’intérieur du grand objet x et l’intérieur, la limite et l’extérieur de y ont des dimensions respectives de 2, 1 et 2.Les intersections entre la frontière du grand objet x et l’intérieur, la frontière et l’extérieur de y ont des dimensions respectives de F, F et 1, où “F” signifie “faux”, les objets sont disjoints.Les intersections entre l’extérieur de x et l’intérieur, la limite et l’extérieur de y ont des dimensions respectives de F, F et 2 : l’extérieur du plus grand objet ne touche pas l’intérieur ou la limite de y, mais l’extérieur du plus petit et du plus grand objet couvre la même surface.Ces trois composants, une fois concaténés, créent la chaîne 212, FF1, et FF2.\nC’est le même résultat que celui obtenu par la fonction st_relate() (voir le code source de ce chapitre pour voir comment les autres géométries de la figure 4.2 ont été créées) :La compréhension des chaînes DE-9IM permet de développer de nouveaux prédicats spatiaux binaires.\nLa page d’aide ?st_relate contient des définitions de fonctions pour les relations “reine” et “tour” dans lesquelles les polygones partagent une frontière ou seulement un point, respectivement.\nLes relations “reine” signifient que les relations “frontière-frontière” (la cellule de la deuxième colonne et de la deuxième ligne de la table 4.1, ou le cinquième élément de la chaîne DE-9IM) ne doivent pas être vides, ce qui correspond au pattern F***T****, tandis que pour les relations “tour”, le même élément doit être 1 (ce qui signifie une intersection linéaire).\nCes relations sont implémentées comme suit :partir de l’objet x créé précédemment, nous pouvons utiliser les fonctions nouvellement créées pour trouver quels éléments de la grille sont une ‘reine’ et une ‘tour’ par rapport à la case centrale de la grille comme suit :\nFIGURE 4.5: Démonstration de prédicats spatiaux binaires personnalisés permettant de trouver les relations ‘reine’ (à gauche) et ‘tour’ (à droite) par rapport à la case centrale dans une grille à 9 géométries.\n","code":"\nxy2sfc = function(x, y) st_sfc(st_polygon(list(cbind(x, y))))\nx = xy2sfc(x = c(0, 0, 1, 1,   0), y = c(0, 1, 1, 0.5, 0))\ny = xy2sfc(x = c(0.7, 0.7, 0.9, 0.7), y = c(0.8, 0.5, 0.5, 0.8))\nst_relate(x, y)\n#>      [,1]       \n#> [1,] \"212FF1FF2\"\nst_queen = function(x, y) st_relate(x, y, pattern = \"F***T****\")\nst_rook = function(x, y) st_relate(x, y, pattern = \"F***1****\")\ngrid = st_make_grid(x, n = 3)\ngrid_sf = st_sf(grid)\ngrid_sf$queens = lengths(st_queen(grid, grid[5])) > 0\nplot(grid, col = grid_sf$queens)\ngrid_sf$rooks = lengths(st_rook(grid, grid[5])) > 0\nplot(grid, col = grid_sf$rooks)"},{"path":"spatial-operations.html","id":"jointure-spatiale","chapter":"4 Géotraitements","heading":"4.2.4 Jointure spatiale","text":"La jointure de deux jeux de données non spatiales repose sur une variable “clé” partagée, comme décrit dans la section ??.\nLa jointure de données spatiales applique le même concept, mais s’appuie sur les relations spatiales, décrites dans la section précédente.\nComme pour les données attributaires, la jointure ajoute de nouvelles colonnes à l’objet cible (l’argument x dans les fonctions de jointure), à partir d’un objet source (y).\nLe processus est illustré par l’exemple suivant : imaginez que vous disposez de dix points répartis au hasard sur la surface de la Terre et que vous demandez, pour les points qui se trouvent sur la terre ferme, dans quels pays se trouvent-ils ?\nLa mise en œuvre de cette idée dans un [exemple reproductible] (https://github.com/Robinlovelace/geocompr/blob/main/code/04-spatial-join.R) renforcera vos compétences en matière de traitement des données géographiques et vous montrera comment fonctionnent les jointures spatiales.\nLe point de départ consiste à créer des points dispersés de manière aléatoire sur la surface de la Terre :Le scénario illustré dans la Figure 4.6 montre que l’objet random_points (en haut à gauche) n’pas d’attributs, alors que le world (en haut à droite) des attributs, y compris les noms de pays indiqués pour un échantillon de pays dans la légende.\nLes jointures spatiales sont implémentées avec st_join(), comme illustré dans l’extrait de code ci-dessous.\nLa sortie est l’objet random_joined qui est illustré dans la Figure 4.6 (en bas à gauche).\nAvant de créer l’ensemble de données jointes, nous utilisons la sélection spatiale pour créer world_random, qui contient uniquement les pays qui contiennent des points aléatoires, afin de vérifier que le nombre de noms de pays retournés dans l’ensemble de données jointes doit être de quatre (cf. le panneau supérieur droit de la Figure 4.6).\nFIGURE 4.6: Illustration d’une jointure spatiale. Une nouvelle variable attributaire est ajoutée aux points aléatoires (en haut à gauche) de l’objet monde source (en haut à droite), ce qui donne les données représentées dans le dernier panneau.\nPar défaut, st_join() effectue une jointure à gauche (left join), ce qui signifie que le résultat est un objet contenant toutes les lignes de x, y compris les lignes sans correspondance dans y (voir la section ??), mais il peut également effectuer des jointures internes en définissant l’argument left = FALSE.\nComme pour les sélections spatiales, l’opérateur topologique par défaut utilisé par st_join() est st_intersects(), qui peut être modifié en définissant l’argument join (cf. ?st_join pour plus de détails).\nL’exemple ci-dessus montre l’ajout d’une colonne d’une couche de polygones à une couche de points, mais la même approche fonctionne indépendamment des types de géométrie.\nDans de tels cas, par exemple lorsque x contient des polygones, dont chacun correspond à plusieurs objets dans y, les jointures spatiales résulteront en des caractéristiques dupliquées, crée une nouvelle ligne pour chaque correspondance dans y.","code":"\nset.seed(2018) # définir la seed pour la reproductibilité\n(bb = st_bbox(world)) # les limites de la terre\n#>   xmin   ymin   xmax   ymax \n#> -180.0  -89.9  180.0   83.6\nrandom_df = data.frame(\n  x = runif(n = 10, min = bb[1], max = bb[3]),\n  y = runif(n = 10, min = bb[2], max = bb[4])\n)\nrandom_points = random_df %>% \n  st_as_sf(coords = c(\"x\", \"y\")) %>% # définir les coordonnés\n  st_set_crs(\"EPSG:4326\") # définir le CRS\nworld_random = world[random_points, ]\nnrow(world_random)\n#> [1] 4\nrandom_joined = st_join(random_points, world[\"name_long\"])"},{"path":"spatial-operations.html","id":"jointure-sans-chevauchement","chapter":"4 Géotraitements","heading":"4.2.5 Jointure sans chevauchement","text":"Parfois, deux jeux de données géographiques ne se touchent pas mais ont quand même une forte relation géographique.\nLes jeux de données cycle_hire et cycle_hire_osm, présent dans le paquet spData, en sont un bon exemple.\nLeur tracé montre qu’ils sont souvent étroitement liés mais qu’ils ne se touchent pas, comme le montre la figure 4.7, dont une version de base est créée avec le code suivant ci-dessous :\nNous pouvons vérifier si certains points se superposent avec st_intersects() :\nFIGURE 4.7: La distribution spatiale des points de location de vélos à Londres, basée sur les données officielles (bleu) et les données OpenStreetMap (rouge).\nImaginons que nous ayons besoin de joindre la variable “capacité” de cycle_hire_osm aux données officielles “cible” contenues dans cycle_hire.\nDans ce cas, une jointure sans chevauchement est nécessaire.\nLa méthode la plus simple est d’utiliser l’opérateur topologique st_is_within_distance(), comme démontré ci-dessous en utilisant une distance seuil de 20 m (notez que cela fonctionne avec des données projetées et non projetées).Cela montre qu’il y 438 des points dans l’objet cible cycle_hire dans la distance seuil (20 m) de cycle_hire_osm.\nComment récupérer les valeurs associées aux points respectifs de cycle_hire_osm ?\nLa solution est à nouveau avec st_join(), mais avec un argument dist supplémentaire (fixé à 20 m en dessous) :Remarquez que le nombre de lignes dans le résultat joint est supérieur à la cible.\nCela est dû au fait que certaines stations de location de vélos dans cycle_hire ont plusieurs correspondances dans cycle_hire_osm.\nPour agréger les valeurs des points qui se chevauchent et renvoyer la moyenne, nous pouvons utiliser les méthodes d’agrégation apprises au chapitre 3, ce qui donne un objet avec le même nombre de lignes que la cible :La capacité des stations proches peut être vérifiée en comparant les cartes de la capacité des données source cycle_hire_osm avec les résultats dans ce nouvel objet (cartes non montrées) :Le résultat de cette jointure utilisé une opération spatiale pour modifier les données attributaires associées aux entités simples ; la géométrie associée à chaque entité est restée inchangée.","code":"\nplot(st_geometry(cycle_hire), col = \"blue\")\nplot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = \"red\")\nany(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))\n#> [1] FALSE\nsel = st_is_within_distance(cycle_hire, cycle_hire_osm, dist = 20)\nsummary(lengths(sel) > 0)\n#>    Mode   FALSE    TRUE \n#> logical     304     438\nz = st_join(cycle_hire, cycle_hire_osm, st_is_within_distance, dist = 20)\nnrow(cycle_hire)\n#> [1] 742\nnrow(z)\n#> [1] 762\nz = z %>% \n  group_by(id) %>% \n  summarize(capacity = mean(capacity))\nnrow(z) == nrow(cycle_hire)\n#> [1] TRUE\nplot(cycle_hire_osm[\"capacity\"])\nplot(z[\"capacity\"])"},{"path":"spatial-operations.html","id":"spatial-aggr","chapter":"4 Géotraitements","heading":"4.2.6 Agrégats spatiaux","text":"Comme pour l’agrégation de données attributaires, l’agrégation de données spatiales condense les données : les sorties agrégées comportent moins de lignes que les entrées non agrégées.\nLes fonctions d’agrégation statistiques, telles que la moyenne ou la somme, résument plusieurs valeurs d’une variable et renvoient une seule valeur par variable de regroupement.\nLa section ?? montré comment aggregate() et group_by() %>% summarize() condensent les données basées sur des variables d’attributs, cette section montre comment les mêmes fonctions fonctionnent avec des objets spatiaux.\nPour revenir à l’exemple de la Nouvelle-Zélande, imaginez que vous voulez connaître la hauteur moyenne des points hauts de chaque région : c’est la géométrie de la source (y ou nz dans ce cas) qui définit comment les valeurs de l’objet cible (x ou nz_height) sont regroupées.\nCeci peut être fait en une seule ligne de code avec la méthode aggregate() de la base R :Le résultat de la commande précédente est un objet sf ayant la même géométrie que l’objet d’agrégation (spatiale) (nz), ce que vous pouvez vérifier avec la commande identical(st_geometry(nz), st_geometry(nz_agg)).\nLe résultat de l’opération précédente est illustré dans la Figure 4.8, qui montre la valeur moyenne des caractéristiques de nz_height dans chacune des 16 régions de la Nouvelle-Zélande.\nLe même résultat peut également être généré en passant la sortie de st_join() dans les fonctions ‘tidy’ group_by() et summarize() comme suit :\nFIGURE 4.8: Hauteur moyenne des 101 points culminants par régions de la Nouvelle-Zélande.\nLes entités nz_agg résultants ont la même géométrie que l’objet d’agrégation nz mais avec une nouvelle colonne résumant les valeurs de x dans chaque région en utilisant la fonction mean().\nD’autres fonctions peuvent, bien sûr, remplacer mean() comme la median(), sd() et d’autres fonctions qui retournent une seule valeur par groupe.\nRemarque : une différence entre les approches aggregate() et group_by() %>% summarize() est que la première donne des valeurs NA pour les noms de régions non correspondantes, tandis que la seconde préserve les noms de régions.\nL’approche “tidy” est plus flexible en termes de fonctions d’agrégation et de noms de colonnes des résultats.\nLes opérations d’agrégation créant de nouvelles géométries sont décrites dans la section ??.","code":"\nnz_agg = aggregate(x = nz_height, by = nz, FUN = mean)\nnz_agg2 = st_join(x = nz, y = nz_height) %>%\n  group_by(Name) %>%\n  summarize(elevation = mean(elevation, na.rm = TRUE))"},{"path":"spatial-operations.html","id":"incongruent","chapter":"4 Géotraitements","heading":"4.2.7 Jointure de couches sans superposition parfaite","text":"La congruence spatiale est un concept important lié à l’agrégation spatiale.\nUn objet d’agrégation (que nous appellerons y) est congruent avec l’objet cible (x) si les deux objets ont des frontières communes.\nC’est souvent le cas des données sur les limites administratives, où des unités plus grandes — telles que les Middle Layer Super Output Areas (MSOAs) au Royaume-Uni ou les districts dans de nombreux autres pays européens — sont composées de nombreuses unités plus petites.Les objets d’agrégation non congruent, en revanche, ne partagent pas de frontières communes avec la cible (Qiu, Zhang, Zhou 2012).\nC’est un problème pour l’agrégation spatiale (et d’autres opérations spatiales) illustrée dans la figure 4.9 : agréger le centroïde de chaque sous-zone ne donnera pas de résultats précis.\nL’interpolation surfacique résout ce problème en transférant les valeurs d’un ensemble d’unités surfaciques à un autre, à l’aide d’une gamme d’algorithmes comprenant des approches simples de pondération de la surface et des approches plus sophistiquées telles que les méthodes ” pycnophylactiques ” (Tobler 1979).\nFIGURE 4.9: Illustration des entités surfaciques congruentes (à gauche) et non congruentes (à droite) par rapport à des zones d’agrégation plus grandes (bordures bleues translucides).\nLe paquet spData contient un jeux de données nommé incongruent (polygones colorés avec des bordures noires dans le panneau de droite de la Figure 4.9) et un ensemble de données nommé aggregating_zones (les deux polygones avec la bordure bleue translucide dans le panneau de droite de la Figure 4.9).\nSupposons que la colonne valeur de incongruent se réfère au revenu régional total en millions d’euros.\nComment pouvons-nous transférer les valeurs des neuf polygones spatiaux sous-jacents dans les deux polygones de aggregating_zones ?La méthode la plus simple est l’interpolation spatiale pondérée par la surface, qui transfère les valeurs de l’objet non congruent vers une nouvelle colonne dans aggregating_zones proportionnellement à la surface de recouvrement : plus l’intersection spatiale entre les caractéristiques d’entrée et de sortie est grande, plus la valeur correspondante est grande.\nCeci est implémenté dans st_interpolate_aw(), comme démontré dans le morceau de code ci-dessous.Dans notre cas, il est utile d’additionner les valeurs des intersections qui se trouvent dans les zones d’agrégation, car le revenu total est une variable dite spatialement extensive (qui augmente avec la superficie), en supposant que le revenu est réparti uniformément dans les zones plus petites (d’où le message d’avertissement ci-dessus).\nIl en va différemment pour les variables spatialement intensives telles que le revenu moyen ou les pourcentages, qui n’augmentent pas avec la superficie.\nst_interpolate_aw() fonctionne également avec des variables spatialement intensives : mettez le paramètre extensive à FALSE et il utilisera une moyenne plutôt qu’une fonction de somme pour faire l’agrégation.","code":"\niv = incongruent[\"value\"] # garde uniquement les valeurs à transférer\nagg_aw = st_interpolate_aw(iv, aggregating_zones, ext = TRUE)\n#> Warning in st_interpolate_aw.sf(iv, aggregating_zones, ext = TRUE):\n#> st_interpolate_aw assumes attributes are constant or uniform over areas of x\nagg_aw$value\n#> [1] 19.6 25.7"},{"path":"spatial-operations.html","id":"les-relations-de-distance","chapter":"4 Géotraitements","heading":"4.2.8 Les relations de distance","text":"Alors que les relations topologiques sont binaires — une caractéristique est soit en intersection avec une autre ou non — les relations de distance sont continues.\nLa distance entre deux objets est calculée avec la fonction st_distance().\nCeci est illustré dans l’extrait de code ci-dessous, qui trouve la distance entre le point le plus élevé de Nouvelle-Zélande et le centroïde géographique de la région de Canterbury, créé dans la section ?? :\nIl y deux choses potentiellement surprenantes dans ce résultat :Il des unités, ce qui nous indique que la distance est de 100 000 mètres, et non de 100 000 pouces, ou toute autre mesure de distance.Elle est retournée sous forme de matrice, même si le résultat ne contient qu’une seule valeur.Cette deuxième caractéristique laisse entrevoir une autre fonctionnalité utile de st_distance(), sa capacité à retourner des matrices de distance entre toutes les combinaisons de caractéristiques dans les objets x et y.\nCeci est illustré dans la commande ci-dessous, qui trouve les distances entre les trois premières caractéristiques de nz_height et les régions d’Otago et de Canterbury en Nouvelle-Zélande représentées par l’objet co.Remarquez que le distance entre les deuxième et troisième éléments de nz_height et le deuxième élément de co est de zéro.\nCela démontre le fait que les distances entre les points et les polygones se réfèrent à la distance à n’importe quelle partie du polygone :\nLes deuxième et troisième points dans nz_height sont dans Otago, ce qui peut être vérifié en les traçant (résultat non montré) :","code":"\nnz_heighest = nz_height %>% top_n(n = 1, wt = elevation)\ncanterbury_centroid = st_centroid(canterbury)\nst_distance(nz_heighest, canterbury_centroid)\n#> Units: [m]\n#>        [,1]\n#> [1,] 115540\nco = filter(nz, grepl(\"Canter|Otag\", Name))\nst_distance(nz_height[1:3, ], co)\n#> Units: [m]\n#>        [,1]  [,2]\n#> [1,] 123537 15498\n#> [2,]  94283     0\n#> [3,]  93019     0\nplot(st_geometry(co)[2])\nplot(st_geometry(nz_height)[2:3], add = TRUE)"},{"path":"spatial-operations.html","id":"spatial-ras","chapter":"4 Géotraitements","heading":"4.3 Opérations spatiales sur les données raster","text":"Cette section s’appuie sur la section ??, qui met en évidence diverses méthodes de base pour manipuler des jeux de données raster. Elle illustre des opérations raster plus avancées et explicitement spatiales, et utilise les objets elev et grain créés manuellement dans la section ??.\nPour la commodité du lecteur, ces jeux de données se trouvent également dans le paquet spData.","code":""},{"path":"spatial-operations.html","id":"spatial-raster-subsetting","chapter":"4 Géotraitements","heading":"4.3.1 Sélection spatiale","text":"Le chapitre précédent (Section ??) montré comment extraire les valeurs associées à des ID de cellules spécifiques ou à des combinaisons de lignes et de colonnes.\nLes objets raster peuvent également être extraits par leur emplacement (coordonnées) et via d’autres objets spatiaux.\nPour utiliser les coordonnées pour la sélection, peut “traduire” les coordonnées en un ID de cellule avec la fonction terra cellFromXY().\nUne alternative est d’utiliser terra::extract() (attention, il existe aussi une fonction appelée extract() dans le tidyverse) pour extraire des valeurs.\nLes deux méthodes sont démontrées ci-dessous pour trouver la valeur de la cellule qui couvre un point situé aux coordonnées 0,1, 0,1.\nLes objets raster peuvent également être sélectionnés avec un autre objet raster, comme le montre le code ci-dessous :Cela revient à récupérer les valeurs du premier objet raster (dans ce cas, elev) qui se trouvent dans l’étendue d’un second objet raster (ici : clip), comme illustré dans la figure 4.10.\nFIGURE 4.10: Raster originale (à gauche). Masque raster (au milieu). Résultat du clip (à droite).\nL’exemple ci-dessus retourné les valeurs de cellules spécifiques, mais dans de nombreux cas, ce sont des sorties spatiales qui sont nécessaires.\nCela peut être fait en utilisant l’opérateur [, avec drop = FALSE, comme indiqué dans la section ??, qui montre également comment les objets raster peuvent être sélectionnés par divers objets.\nLe code ci-dessous en est un exemple en retournant les deux premières cellules (de la ligne supérieure) de elev en tant qu’objet raster (seules les 2 premières lignes de la sortie sont montrées) :Un autre cas d’utilisation courante de sélection spatiale est celle où une image raster avec des valeurs logiques (ou NA) est utilisée pour masquer une autre image raster avec la même étendue et la même résolution, comme illustré dans la Figure 4.10.\nDans ce cas, les fonctions [ et mask() peuvent être utilisées (résultats non montrés) :Dans le morceau de code ci-dessus, nous avons créé un objet masque appelé rmask avec des valeurs assignées aléatoirement à NA et TRUE.\nEnsuite, nous voulons garder les valeurs de elev qui sont TRUE dans rmask.\nEn d’autres termes, nous voulons masquer elev avec rmask.L’approche ci-dessus peut également être utilisée pour remplacer certaines valeurs (par exemple, celles qui seraient fausses) par NA.Ces opérations sont en fait des opérations booléennes locales puisque nous comparons deux rasters par cellule.\nLa sous-section suivante explore ces opérations et d’autres opérations connexes plus en détail.","code":"\nid = cellFromXY(elev, xy = matrix(c(0.1, 0.1), ncol = 2))\nelev[id]\n# the same as\nterra::extract(elev, matrix(c(0.1, 0.1), ncol = 2))\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip]\n# on peut aussi utiliser extract\n# terra::extract(elev, ext(clip))\nelev[1:2, drop = FALSE]    # sélection spatiale par ID\n#> class       : SpatRaster \n#> dimensions  : 1, 2, 1  (nrow, ncol, nlyr)\n#> ...\n# créer un masque raster\nrmask = elev\nvalues(rmask) = sample(c(NA, TRUE), 36, replace = TRUE)\n# sélection spatiale\nelev[rmask, drop = FALSE]           # avec l'opérateur [ \nmask(elev, rmask)                   # avec mask()\nelev[elev < 20] = NA"},{"path":"spatial-operations.html","id":"algèbre-raster","chapter":"4 Géotraitements","heading":"4.3.2 Algèbre raster","text":"\nLe terme “algèbre raster” été inventé à la fin des années 1970 pour décrire un “ensemble de conventions, de capacités et de techniques” pour l’analyse des données géographiques raster et (bien que moins marquées) vectorielles (Tomlin 1994).\n\nDans ce contexte, nous définissons l’algèbre raster plus strictement, comme des opérations qui modifient ou résument les valeurs des cellules raster, en référence aux cellules environnantes, aux zones ou aux fonctions statistiques s’appliquant à chaque cellule.Les opérations d’algèbre raster ont tendance à être rapides, car les jeux de données raster ne stockent qu’implicitement les coordonnées, d’où le vieil adage “raster faster vector corrector”.\nLa position des cellules dans les jeux de données raster peut être calculée à l’aide de leur position matricielle, de la résolution et de l’origine du jeu de données (stockées dans l’en-tête).\nPour le traitement, cependant, la position géographique d’une cellule n’est guère pertinente tant que nous nous assurons que la position de la cellule est toujours la même après le traitement.\nDe plus, si deux ou plusieurs jeux de données raster partagent la même étendue, projection et résolution, peut les traiter comme des matrices pour le traitement.C’est de cette manière que l’algèbre raster fonctionne avec le paquet terra.\nPremièrement, les en-têtes des jeux de données raster sont interrogés et (dans les cas où les opérations d’algèbre raster fonctionnent sur plus d’un ensemble de données) vérifiés pour s’assurer que les jeux de données sont compatibles.\nDeuxièmement, l’algèbre raster conserve ce que l’appelle la correspondance de localisation une à une, ce qui signifie que les cellules ne peuvent pas se déplacer.\nCela diffère de l’algèbre matricielle, dans laquelle les valeurs changent de position, par exemple lors de la multiplication ou de la division de matrices.L’algèbre raster (ou modélisation cartographique avec des données raster) divise les opérations sur des rasters en quatre sous-classes (Tomlin 1990), chacune travaillant sur une ou plusieurs grilles simultanément :Opérations locales ou par celluleLes opérations Focales ou de voisinage.\nLe plus souvent la valeur de la cellule de sortie est le résultat d’un bloc de cellules d’entrée de 3 x 3 cellulesLes opérations Zonales sont similaires aux opérations focales, mais la grille de pixels environnante sur laquelle les nouvelles valeurs sont calculées peut avoir des tailles et des formes irrégulières.Les opérations Globales ou par-raster ; cela signifie que la cellule de sortie dérive potentiellement sa valeur d’un ou de plusieurs rasters entiers.Cette typologie classe les opérations d’algèbre raster en fonction du nombre de cellules utilisées pour chaque étape de traitement des pixels et du type de sortie.\nPar souci d’exhaustivité, nous devons mentionner que les opérations sur des rasters peuvent également être classées par discipline, comme le terrain, l’analyse hydrologique ou la classification des images.\nLes sections suivantes expliquent comment chaque type d’opérations d’algèbre raster peut être utilisé, en se référant à des exemples documentés.","code":""},{"path":"spatial-operations.html","id":"opérations-locales","chapter":"4 Géotraitements","heading":"4.3.3 Opérations locales","text":"\nLes opérations locales comprennent toutes les opérations cellule par cellule dans une ou plusieurs couches.\nElles ont un cas typique d’algèbre raster et comprennent l’ajout ou la soustraction de valeurs d’une image raster, l’élévation au carré et la multiplication d’images raster.\nL’algèbre raster permet également des opérations logiques telles que la recherche de toutes les cellules qui sont supérieures à une valeur spécifique (5 dans notre exemple ci-dessous).\nLe paquet terra prend en charge toutes ces opérations et bien plus encore, comme le montre la figure ci-dessous (4.11):\nFIGURE 4.11: Exemples de différentes opérations locales de l’objet raster elev : additionner deux rasters, élever au carré, appliquer une transformation logarithmique et effectuer une opération logique.\nUn autre bon exemple d’opérations locales est la classification d’intervalles de valeurs numériques en groupes, comme le regroupement d’un modèle numérique d’élévation en altitudes basses (classe 1), moyennes (classe 2) et hautes (classe 3).\nEn utilisant la commande classify(), nous devons d’abord construire une matrice de classification, où la première colonne correspond à l’extrémité inférieure et la deuxième colonne à l’extrémité supérieure de la classe.\nLa troisième colonne représente la nouvelle valeur pour les plages spécifiées dans les colonnes un et deux.Ici, nous affectons les valeurs du raster dans les plages 0–12, 12–24 et 24–36 et les reclassons pour prendre les valeurs 1, 2 et 3, respectivement.La fonction classify() peut également être utilisée lorsque nous voulons réduire le nombre de classes dans nos rasters catégorisés.\nNous effectuerons plusieurs reclassements supplémentaires dans le chapitre ??’.En dehors des opérateurs arithmétiques, peut aussi utiliser les fonctions app(), tapp() et lapp().\nElles sont plus efficaces, et donc préférables pour les grands jeux de données raster.\nDe plus, elles vous permettent d’enregistrer directement un fichier de sortie.\nLa fonction app() applique une fonction à chaque cellule d’une couche matricielle et est utilisée pour résumer (par exemple, en calculant la somme) les valeurs de plusieurs couches en une seule couche.\ntapp() est une extension de app(), nous permettant de sélectionner un sous-ensemble de couches (voir l’argument index) pour lesquelles nous voulons effectuer une certaine opération.\nEnfin, la fonction lapp() permet d’appliquer une fonction à chaque cellule en utilisant les couches comme arguments – une application de lapp() est présentée ci-dessous.Le calcul du normalized difference vegetation index (NDVI) est une opération raster locale (pixel par pixel) bien connue.\nElle produit un raster dont les valeurs sont comprises entre -1 et 1 ; les valeurs positives indiquent la présence de plantes vivantes (le plus souvent > 0,2).\nLe NDVI est calculé à partir des bandes rouge et proche infrarouge (NIR) d’images de télédétection, généralement issues de systèmes satellitaires tels que Landsat ou Sentinel.\nLa végétation absorbe fortement la lumière dans le spectre de la lumière visible, et surtout dans le canal rouge, tout en réfléchissant la lumière NIR, ce qui explique la formule du NDVI :\\[\n\\begin{split}\nNDVI&= \\frac{\\text{NIR} - \\text{Red}}{\\text{NIR} + \\text{Red}}\\\\\n\\end{split}\n\\]Calculons le NDVI pour l’image satellite multispectrale du parc National de Zion.L’objet raster comporte quatre bandes de satellite - bleu, vert, rouge et proche infrarouge (NIR).\nNotre prochaine étape va être d’implémenter la formule NDVI dans une fonction R :Cette fonction accepte deux arguments numériques, nir et red, et retourne un vecteur numérique avec les valeurs NDVI.\nElle peut être utilisée comme argument fun de lapp().\nNous devons juste nous rappeler que notre fonction n’besoin que de deux bandes (et non de quatre comme dans le raster original), et qu’elles doivent être dans l’ordre NIR puis red.\nC’est pourquoi nous sélection la grille d’entrée avec multi_rast[[c(4, 3)]] avant d’effectuer tout calcul.Le résultat, présenté sur le panneau de droite de la figure 4.12, peut être comparé à l’image RVB de la même zone (panneau de gauche de la même figure).\nIl nous permet de constater que les plus grandes valeurs de NDVI sont liées aux zones de forêt dense dans les parties nord de la zone, tandis que les valeurs les plus faibles sont liées au lac au nord et aux crêtes montagneuses enneigées.\nFIGURE 4.12: Image RVB (à gauche) et valeurs NDVI (à droite) calculées pour l’exemple de l’image satellite du parc National de Zion.\nLa cartographie prédictive est une autre application intéressante des opérations raster locales.\nLa variable de réponse correspond à des points mesurés ou observés dans l’espace, par exemple, la richesse des espèces, la présence de glissements de terrain, les maladies des arbres ou le rendement des cultures.\nPar conséquent, nous pouvons facilement récupérer des variables prédictives spatiales ou aériennes à partir de divers rasters (élévation, pH, précipitations, température, couverture végétale, classe de sol, etc.)\nEnsuite, nous modélisons notre réponse en fonction de nos prédicteurs en utilisant lm(), glm(), gam() ou une technique d’apprentissage automatique.\nLes prédictions spatiales sur les objets raster peuvent donc être réalisées en appliquant des coefficients estimés aux valeurs de chaque cellule, et en additionnant les valeurs raster de sortie (voir chapitre ??).","code":"\nelev + elev\nelev^2\nlog(elev)\nelev > 5\nrcl = matrix(c(0, 12, 1, 12, 24, 2, 24, 36, 3), ncol = 3, byrow = TRUE)\nrcl\n#>      [,1] [,2] [,3]\n#> [1,]    0   12    1\n#> [2,]   12   24    2\n#> [3,]   24   36    3\nrecl = classify(elev, rcl = rcl)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nndvi_fun = function(nir, red){\n  (nir - red) / (nir + red)\n}\nndvi_rast = lapp(multi_rast[[c(4, 3)]], fun = ndvi_fun)"},{"path":"spatial-operations.html","id":"operations-focales","chapter":"4 Géotraitements","heading":"4.3.4 Operations focales","text":"\nAlors que les fonctions locales opèrent sur une cellule, bien que pouvant provenir de plusieurs couches, les opérations focales prennent en compte une cellule centrale (focale) et ses voisines.\nLe voisinage (également appelé noyau, filtre ou fenêtre mobile) utilisé est généralement de le taille 3 par 3 cellules (c’est-à-dire la cellule centrale et ses huit voisines), mais peut prendre toute autre forme (pas nécessairement rectangulaire) définie par l’utilisateur.\nUne opération focale applique une fonction d’agrégation à toutes les cellules du voisinage spécifié, utilise la sortie correspondante comme nouvelle valeur pour la cellule centrale, puis passe à la cellule centrale suivante (figure 4.13).\nCette opération est également appelée filtrage spatial et convolution (Burrough, McDonnell, Lloyd 2015).Dans R, nous pouvons utiliser la fonction focal() pour effectuer un filtrage spatial.\nNous définissons la forme de la fenêtre mobile avec une matrice dont les valeurs correspondent aux poids (voir le paramètre w dans le code ci-dessous).\nEnsuite, le paramètre fun nous permet de spécifier la fonction que nous souhaitons appliquer à ce voisinage.\nIci, nous choisissons le minimum, mais toute autre fonction de résumé, y compris sum(), mean(), ou var() peut être utilisée.Cette fonction accepte également des arguments supplémentaires, par exemple, si elle doit supprimer les NAs dans le processus (na.rm = TRUE) ou non (na.rm = FALSE).\nFIGURE 4.13: Raster d’entrée (gauche) et raster de sortie (droite) suite à une opération focale - trouver la valeur minimale dans des fenêtres mobiles 3 par 3.\nNous pouvons rapidement vérifier si le résultat correspond à nos attentes.\nEn effet, dans notre exemple, la valeur minimale doit toujours se situer dans le coin supérieur gauche de la fenêtre mobile (rappelez-vous que nous avons créé le raster d’entrée en incrémentant les valeurs des cellules d’une unité par ligne, en commençant par le coin supérieur gauche).\nDans cet exemple, la matrice de pondération est composée uniquement de 1, ce qui signifie que chaque cellule le même poids sur la sortie, mais cela peut être modifié.Les fonctions ou filtres focaux jouent un rôle dominant dans le traitement des images.\nLes filtres “passe-bas” (low-pass) ou de lissage utilisent la fonction moyenne pour éliminer les valeurs extrêmes.\nDans le cas de données catégorielles, peut remplacer la moyenne par le mode, qui est la valeur la plus courante.\nEn revanche, les filtres “passe-haut” accentuent les entités.\nLes filtres Laplace et Sobel de détection de lignes peuvent servir d’exemple ici.\nConsultez la page d’aide focal() pour savoir comment les utiliser dans R (ils seront également utilisés dans les exercices à la fin de ce chapitre).Le traitement des données numériques de terrain, le calcul des caractéristiques topographiques telles que la pente, l’aspect et les directions d’écoulement, repose sur des fonctions focales.\nLa fonction de terra terrain() peut être utilisé pour calculer ces métriques, bien que certains algorithmes de traitement des données numériques de terrain, y compris la méthode de Zevenbergen et Thorne pour calculer la pente, n’y soient pas implémentés.\nDe nombreux autres algorithmes — notamment les courbures, les zones contributives et les indices d’humidité — sont mis en œuvre dans des logiciels libres de systèmes d’information géographique (SIG) de bureau.\nLe chapitre ?? montre comment accéder à ces fonctionnalités SIG à partir de R.","code":"\nr_focal = focal(elev, w = matrix(1, nrow = 3, ncol = 3), fun = min)"},{"path":"spatial-operations.html","id":"opérations-zonales","chapter":"4 Géotraitements","heading":"4.3.5 Opérations Zonales","text":"\nTout comme les opérations focales, les opérations zonales appliquent une fonction d’agrégation à plusieurs cellules.\nCependant, un deuxième raster, généralement avec des valeurs catégorielles, définit les filtres zonaux (ou ‘zones’) dans le cas des opérations zonales, en opposition à une fenêtre de voisinage prédéfinie dans le cas de l’opération focale.\nPar conséquent, les cellules définissant le filtre zonal ne doivent pas nécessairement être voisines.\nNotre raster grain en est un bon exemple, comme l’illustre le panneau de droite de la figure 3.2 : différentes tailles de granulométrie sont réparties de manière irrégulière dans le raster.\nEnfin, le résultat d’une opération zonale est un tableau récapitulatif groupé par zone, c’est pourquoi cette opération est également connue sous le nom de statistiques zonales dans le monde des SIG.\nCeci est à l’opposé des opérations focales qui retournent un objet matriciel.Le code suivant utilise la fonction zonal() pour calculer l’altitude moyenne associée à chaque classe de taille de grain.ceci renvoie les statistiques pour chaque catégorie, ici l’altitude moyenne pour chaque classe de granulométrie.\nRemarque : il est aussi possible d’obtenir un raster avec les statistiques calculées pour chaque zone en mettant l’argument .raster à TRUE.","code":"\nz = zonal(elev, grain, fun = \"mean\")\nz\n#>   grain elev\n#> 1  clay 14.8\n#> 2  silt 21.2\n#> 3  sand 18.7"},{"path":"spatial-operations.html","id":"opérations-globales-et-distances","chapter":"4 Géotraitements","heading":"4.3.6 Opérations globales et distances","text":"Les opérations globales sont un cas particulier des opérations zonales, l’ensemble des données raster représentant une seule zone.\nLes opérations globales les plus courantes sont des statistiques descriptives pour l’ensemble des données raster, telles que le minimum ou le maximum, que nous avons déjà abordées dans la section ??.En dehors de cela, les opérations globales sont également utiles pour le calcul des rasters de distance et de poids.\nDans le premier cas, peut calculer la distance entre chaque cellule et une cellule cible spécifique.\nPar exemple, peut vouloir calculer la distance à la côte la plus proche (voir aussi terra::distance()).\npeut aussi vouloir prendre en compte la topographie, c’est-à-dire qu’n’est pas seulement intéressé par la distance pure mais qu’voudrait aussi éviter de traverser des chaînes de montagnes en allant vers la côte.\nPour ce faire, nous pouvons pondérer la distance par l’altitude de sorte que chaque mètre d’altitude supplémentaire “prolonge” la distance euclidienne.\nLes calculs de visibilité et de bassin visuel appartiennent également à la famille des opérations globales (dans les exercices du chapitre ??, vous calculerez un raster de bassin visuel).","code":""},{"path":"spatial-operations.html","id":"les-contreparties-de-lalgèbre-raster-dans-le-traitement-vectoriel","chapter":"4 Géotraitements","heading":"4.3.7 Les contreparties de l’algèbre raster dans le traitement vectoriel","text":"De nombreuses opérations d’algèbre raster ont une contrepartie dans le traitement vectoriel (Liu Mason 2009).\nLe calcul d’une distance raster (opération globale) en ne considérant qu’une distance maximale (opération focale logique) est l’équivalent d’une opération de mise en mémoire tampon vectorielle (section 5.2.5).\nLe reclassement de données raster (fonction locale ou zonale selon l’entrée) est équivalent à la dissolution de données vectorielles (section ??).\nLa superposition de deux données matricielles (opération locale), dont l’une contient des valeurs NULL ou NA représentant un masque, est similaire au découpage vectoriel (Section `(ref?)(clipping)).\nL’intersection de deux couches est tout à fait similaire au détourage spatial (section ??).\nLa différence est que ces deux couches (vectorielles ou matricielles) partagent simplement une zone de chevauchement (voir la figure 5.8 pour un exemple).\nCependant, faites attention à la formulation.\nParfois, les mêmes mots ont des significations légèrement différentes pour les modèles de données rasters et vectorielles.\nDans le cas des données vectorielles, l’agrégation consiste à dissoudre les polygones, tandis que dans le cas des données rasters, elle consiste à augmenter la résolution.\nEn fait, pourrait considérer que dissoudre ou agréger des polygones revient à diminuer la résolution.\nCependant, les opérations zonales semble être le meilleur équivalent raster par rapport à la modification de la résolution des cellules.\nLes opérations zonales peuvent dissoudre les cellules d’un raster en fonction des zones (catégories) d’un autre raster en utilisant une fonction d’agrégation (voir ci-dessus).","code":""},{"path":"spatial-operations.html","id":"fusionner-des-rasters","chapter":"4 Géotraitements","heading":"4.3.8 Fusionner des rasters","text":"\nSupposons que nous voulions calculer le NDVI (voir la section ??), et que nous voulions en plus calculer les attributs du terrain à partir des données d’altitude pour des observations dans une zone d’étude.\nCes calculs reposent sur des informations de télédétection.\nL’imagerie correspondante est souvent divisée en tuiles couvrant une étendue spatiale spécifique, et fréquemment, une zone d’étude couvre plus d’une tuile.\nDans ce cas, nous devons fusionner les tuiles couvertes par notre zone d’étude.\nLe plus simple est alors de fusionner ces scènes, c’est-à-dire les mettre côte à côte.\nCela est possible, par exemple, avec les données numériques d’altitude (SRTM, ASTER).\nDans l’extrait de code suivant, nous téléchargeons d’abord les données d’élévation SRTM pour l’Autriche et la Suisse (pour les codes pays, voir la fonction geodata country_codes()).\nDans une seconde étape, nous fusionnons les deux rasters en un seul.La commande merge() de terra combine deux images, et dans le cas où elles se chevauchent, elle utilise la valeur du premier raster.\n\n\n\n\n\ncette approche de fusion est peu utile lorsque les valeurs qui se chevauchent ne correspondent pas les unes aux autres.\nC’est souvent le cas lorsque vous voulez combiner des images spectrales provenant de scènes qui ont été prises à des dates différentes.\nLa commande merge() fonctionnera toujours mais vous verrez une frontière nette dans l’image résultante.\nD’autre part, la commande mosaic() vous permet de définir une fonction pour la zone de recouvrement.\nPar exemple, nous pourrions calculer la valeur moyenne – cela pourrait lisser la bordure claire dans le résultat fusionné, mais ne la fera probablement pas disparaître.\n\n\n\n\n\nPour une introduction plus détaillée à la télédétection avec R, il est possible de consulter Wegmann, Leutner, Dech (2016).\n\n","code":"\naut = geodata::elevation_30s(country = \"AUT\", path = tempdir())\nch = geodata::elevation_30s(country = \"CHE\", path = tempdir())\naut_ch = merge(aut, ch)"},{"path":"spatial-operations.html","id":"exercises-1","chapter":"4 Géotraitements","heading":"4.4 Exercises","text":"E1. Il été établi dans la section 4.2 que Canterbury était la région de Nouvelle-Zélande contenant la plupart des 100 points les plus élevés du pays.\nCombien de ces points culminants en contient-elle ?Bonus: Représentez le résultat en utilisant la fonction plot() en montrant toute la Nouvelle-Zélande, la région canterbury surlignée en jaune, les points hauts de Canterbury représentés par des points noirsE2. Dans quelle région se trouve le deuxième plus grand nombre de points nz_height, et combien en compte-t-elle ?E3. En généralisant la question à toutes les régions : combien les 16 régions de la Nouvelle-Zélande contiennent des points qui font partie des 100 plus hauts points du pays ? Quelles régions ?Bonus: créer un tableau listant ces régions dans l’ordre du nombre de points et de leurs noms.E4. Testez vos connaissances des prédicats spatiaux en découvrant et en représentant graphiquement les relations entre les États américains et d’autres objets spatiaux.Le point de départ de cet exercice est de créer un objet représentant l’état du Colorado aux USA. Faites-le avec la commande\ncolorado = us_states[us_states$NAME == \"Colorado\",] (base R) ou avec la fonction filter() (tidyverse) et affichez l’objet résultant dans le contexte des états américains.Créez un nouvel objet représentant tous les états qui ont une intersection géographique avec le Colorado et tracez le résultat (astuce : la façon la plus concise de le faire est d’utiliser la méthode de sous-ensemble [).Créez un autre objet représentant tous les objets qui touchent (ont une frontière commune avec) le Colorado et tracez le résultat (conseil : n’oubliez pas que vous pouvez utiliser l’argument op = st_intersects et d’autres relations spatiales pendant les opérations de sous-ensembles spatiaux dans R de base).Bonus : créez une ligne droite du centroïde du District de Columbia, près de la côte Est, au centroïde de la Californie, près de la côte Ouest des Etats-Unis (astuce : les fonctions st_centroid(), st_union() et st_cast() décrites au Chapitre 5 peuvent vous aider) et identifiez les états que cette longue ligne Est-Ouest traverse.E5. Utilisez le dem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\")), et reclassifiez l’altitude en trois classes : basse (<300), moyenne et haute (>500).\nEnsuite, Chargez le raster NDVI (ndvi = rast(system.file(\"raster/ndvi.tif\", package = \"spDataLarge\"))) et calculez le NDVI moyen et l’altitude moyenne pour chaque classe altitudinale.E6. Appliquez un filtre de détection de ligne à rast(system.file(\"ex/logo.tif\", package = \"terra\")).\nAffichez le résultat.\nAstuce : lisez ?terra::focal().E7. Calculez l’indice Normalized Difference Water Index (NDWI ; (green - nir)/(green + nir)) d’une image Landsat.\nUtilisez l’image Landsat fournie par le paquet spDataLarge (system.file(\"raster/landsat.tif\", package = \"spDataLarge\")).\nCalculez également une corrélation entre le NDVI et le NDWI pour cette zone.E8. Un billet de StackOverflow montre comment calculer les distances à la côte la plus proche en utilisant raster::distance().\nEssayez de faire quelque chose de similaire mais avec terra::distance() : récupérez le modèle numérique de terrain espagnole, et obtenez un raster qui représente les distances à la côte à travers le pays (astuce : utilisez geodata::elevation_30s()).\nConvertissez les distances résultantes de mètres en kilomètres.\nRemarque : il peut être judicieux d’augmenter la taille des cellules de l’image matricielle d’entrée pour réduire le temps de calcul pendant cette opération.E9. Essayez de modifier l’approche utilisée dans l’exercice ci-dessus en pondérant le raster de distance avec le raster d’altitude ; chaque 100 mètres d’altitude devrait augmenter la distance à la côte de 10 km.\nEnsuite, calculez et visualisez la différence entre le raster créé en utilisant la distance euclidienne (E7) et le raster pondéré par l’altitude.","code":"\nlibrary(sf)\nlibrary(dplyr)\ndata(nz, package = \"spData\")\ndata(nz_height, package = \"spData\")"},{"path":"geometric-operations.html","id":"geometric-operations","chapter":"5 Opèrations géométriques","heading":"5 Opèrations géométriques","text":"","code":""},{"path":"geometric-operations.html","id":"prérequis-3","chapter":"5 Opèrations géométriques","heading":"Prérequis","text":"Ce chapitre utilise les mêmes paquets que le chapitre 4 mais avec l’ajout de spDataLarge, qui été installé dans le chapitre 2:","code":"\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(spData)\nlibrary(spDataLarge)"},{"path":"geometric-operations.html","id":"introduction-2","chapter":"5 Opèrations géométriques","heading":"5.1 Introduction","text":"Jusqu’à présent, ce livre abordé la structure des jeux de données géographiques (chapitre 2), et la manière de les manipuler en fonction de leurs attributs non géographiques (chapitre 3) et de leurs relations spatiales (chapitre 4).\nCe chapitre se concentre sur la manipulation des éléments géographiques des objets géographiques, par exemple en simplifiant et en convertissant les géométries vectorielles, en recadrant les rasters et en convertissant les objets vectoriels en rasters et les rasters en vecteurs.\nAprès l’avoir lu — et avoir fait les exercices à la fin — vous devriez comprendre et contrôler la colonne géométrique des objets sf ainsi que l’étendue et l’emplacement géographique des pixels représentés dans les rasters par rapport à d’autres objets géographiques.La section 5.2 couvre la transformation des géométries vectorielles avec des opérations “unaires” (ou fonction avec un argument) et “binaires” (fonction avec plus d’un argument).\nLes opérations unaires portent sur une seule géométrie de manière isolée, notamment la simplification (de lignes et de polygones), la création de tampons et de centroïdes, et le déplacement/la mise à l’échelle/la rotation de géométries uniques à l’aide de ” transformations affines ” (sections 5.2.1 à @ref(transformations affines)).\nLes transformations binaires modifient une géométrie en fonction de la forme d’une autre, y compris l’écrêtage et les unions géométriques (), traités respectivement dans les sections @ref(écrêtage) et @ref(unions géométriques).\nLes transformations de type (d’un polygone à une ligne, par exemple) sont présentées dans la section 5.2.8.La section 5.3 couvre les transformations géométriques sur les objets rasters.\nIl s’agit de modifier la taille et le nombre des pixels, et de leur attribuer de nouvelles valeurs.\nElle enseigne comment modifier la résolution (également appelée agrégation et désagrégation), l’étendue et l’origine d’un objet matriciel.\nCes opérations sont particulièrement utiles si l’souhaite aligner des rasters provenant de sources diverses.\nLes objets rasters alignés partagent une correspondance biunivoque entre les pixels, ce qui permet de les traiter à l’aide d’opérations d’algèbre raster, décrites dans la section ??. La dernière section 6 relie les objets vectoriels et rasters.\nElle montre comment les valeurs matricielles peuvent être “masquées” et “extraites” par des géométries vectorielles.\nIl est important de noter qu’elle montre comment ” polygoniser ” les données raster et ” rastériser ” les veceurs, ce qui rend les deux modèles de données plus interchangeables.","code":""},{"path":"geometric-operations.html","id":"geo-vec","chapter":"5 Opèrations géométriques","heading":"5.2 Opérations géométriques sur les données vectorielles","text":"Cette section traite des opérations qui, d’une manière ou d’une autre, modifient la géométrie des objets vectoriels (sf).\nElle est plus avancée que les opérations sur les données spatiales présentées dans le chapitre précédent (dans la section 4.2), parce qu’ici nous allons plus loin dans la géométrie :\nles fonctions présentées dans cette section fonctionnent sur les objets de la classe sfc en plus des objets de la classe sf.","code":""},{"path":"geometric-operations.html","id":"simplification","chapter":"5 Opèrations géométriques","heading":"5.2.1 Simplification","text":"\nLa simplification est un processus de généralisation des objets vectoriels (lignes et polygones) généralement destiné à être utilisé dans des cartes à plus petite échelle.\nUne autre raison de simplifier les objets est de réduire la quantité de mémoire, d’espace disque et de bande passante qu’ils consomment :\nil peut être judicieux de simplifier des géométries complexes avant de les publier sous forme de cartes interactives.\nLe paquet sf fournit st_simplify(), qui utilise l’implémentation GEOS de l’algorithme de Douglas-Peucker pour réduire le nombre de sommets.\nst_simplify() utilise la dTolerance pour contrôler le niveau de généralisation des unités de la carte (voir Douglas Peucker 1973 pour plus de détails).\nLa figure 5.1 illustre la simplification d’une géométrie LINESTRING représentant la Seine et ses affluents.\nLa géométrie simplifiée été créée par la commande suivante :\nFIGURE 5.1: Comparaison de la géométrie originale et simplifiée de la Seine.\nL’objet seine_simp résultant est une copie de l’objet original seine mais avec moins de vertices.\nLe résultat étant visuellement plus simple (Figure 5.1, à droite) et consommant moins de mémoire que l’objet original, comme vérifié ci-dessous :La simplification est également applicable aux polygones.\nCeci est illustré par l’utilisation de us_states, représentant les États-Unis contigus.\nComme nous le montrons dans le chapitre ??, GEOS suppose que les données sont dans un CRS projeté et cela pourrait conduire à des résultats inattendus lors de l’utilisation d’un CRS géographique.\nPar conséquent, la première étape consiste à projeter les données dans un CRS projeté adéquat, tel que le US National Atlas Equal Area (epsg = 2163) (à gauche sur la figure 5.2) :st_simplify() works equally well projected polygons:Une limitation de st_simplify() est qu’il simplifie les objets sur une base géométrique.\nCela signifie que la “topologie” est perdue, ce qui donne lieu à des polygones se superposant ou séparés par des vides, comme le montre la figure 5.2 (panneau du milieu).\nms_simplify() de rmapshaper fournit une alternative qui surmonte ce problème.\nPar défaut, il utilise l’algorithme de Visvalingam, qui surmonte certaines limitations de l’algorithme de Douglas-Peucker (Visvalingam Whyatt 1993).\n\nL’extrait de code suivant utilise cette fonction pour simplifier us_states2163.\nLe résultat n’que 1% des sommets de l’entrée (fixée à l’aide de l’argument keep) mais son nombre d’objets reste intact car nous avons fixé keep_shapes = TRUE :22Enfin, la comparaison visuelle de l’ensemble de données originales et des deux versions simplifiées montre des différences entre les sorties des algorithmes de Douglas-Peucker (st_simplify) et de Visvalingam (ms_simplify) (Figure 5.2) :\nFIGURE 5.2: Simplification des polygones, comparant la géométrie originale des États-Unis continentaux avec des versions simplifiées, générées avec les fonctions des paquets sf (au centre) et rmapshaper (à droite).\n","code":"\nseine_simp = st_simplify(seine, dTolerance = 2000)  # 2000 m\nobject.size(seine)\n#> 18096 bytes\nobject.size(seine_simp)\n#> 9112 bytes\nus_states2163 = st_transform(us_states, \"EPSG:2163\")\nus_states2163 = us_states2163 %>% \n  mutate(AREA = as.numeric(AREA)) \nus_states_simp1 = st_simplify(us_states2163, dTolerance = 100000)  # 100 km\n# proportion des points à garder (0-1; par defaut 0.05)\nus_states_simp2 = rmapshaper::ms_simplify(us_states2163, keep = 0.01,\n                                          keep_shapes = TRUE)"},{"path":"geometric-operations.html","id":"centroïdes","chapter":"5 Opèrations géométriques","heading":"5.2.2 Centroïdes","text":"\nLes opérations de centroïdes identifient le centre des objets géographiques.\nComme pour les mesures statistiques de tendance centrale (y compris les définitions de la moyenne et de la médiane), il existe de nombreuses façons de définir le centre géographique d’un objet.\nToutes créent des représentations par un point unique d’objets vectoriels plus complexes.Le centroïde géographique est sans doute l’opération la plus couramment utilisée.\nCe type d’opération (souvent jute appelé “centroïde”) représente le centre de masse d’un objet spatial (pensez à une assiette en équilibre sur votre doigt).\nLes centroïdes géographiques ont de nombreuses utilisations, par exemple pour créer une représentation ponctuelle simple de géométries complexes, ou pour estimer les distances entre polygones.\nIls peuvent être calculés à l’aide de la fonction sf st_centroid(), comme le montre le code ci-dessous, qui génère les centroïdes géographiques de régions de Nouvelle-Zélande et d’affluents de la Seine, illustrés par des points noirs sur la figure 5.3.Parfois, le centroïde géographique se trouve en dehors des limites de l’objet parent (pensez à un beignet).\nDans ce cas, les opérations dites de point sur la surface peuvent être utilisées pour garantir que le point se trouvera dans l’objet parent (par exemple, pour étiqueter des objets de type multipolygones irréguliers tels que des îles), comme l’illustrent les points rouges de la figure 5.3.\nRemarquez que ces points rouges se trouvent toujours sur leurs objets parents.\nIls ont été créés avec st_point_on_surface() comme suit :23\nFIGURE 5.3: Centroïdes (points noirs) et points sur la surface (points rouges) des ensembles de données des régions de Nouvelle-Zélande (à gauche) et de la Seine (à droite).\nIl existe d’autres types de centroïdes, notamment le centre de Chebyshev et le centre visuel.\nNous ne les explorerons pas ici, mais il est possible de les calculer à l’aide de R, comme nous le verrons dans le chapitre ??.","code":"\nnz_centroid = st_centroid(nz)\nseine_centroid = st_centroid(seine)\nnz_pos = st_point_on_surface(nz)\nseine_pos = st_point_on_surface(seine)"},{"path":"geometric-operations.html","id":"bufferstampons","chapter":"5 Opèrations géométriques","heading":"5.2.3 Buffers/tampons","text":"\nLes buffers ou tampons sont des polygones représentant la zone située à une distance donnée d’une caractéristique géométrique :\nQue le type d’origine soit un point, une ligne ou un polygone, la sortie est toujours un polygone.\nContrairement à la simplification (qui est souvent utilisée pour la visualisation et la réduction de la taille des fichiers), la mise en mémoire tampon est généralement utilisée pour l’analyse des données géographiques.\nCombien de points se trouvent à une distance donnée de cette ligne ?\nQuels groupes démographiques se trouvent à une distance de déplacement de ce nouveau magasin ?\nIl est possible de répondre à ce genre de questions et de les visualiser en créant des tampons autour des entités géographiques d’intérêt.La figure 5.4 illustre des buffers de différentes tailles (5 et 50 km) entourant la Seine et ses affluents.\nLes commandes ci-dessous, utilisées pour créer ces buffers, montrent que la commande st_buffer() nécessite au moins deux arguments : une géométrie d’entrée et une distance, fournie dans les unités du SRC (dans ce cas, les mètres) :\nFIGURE 5.4: Tampons de 5 km autour du jeu de données de la Seine (à gauche) et de 50 km (à droite). Notez les couleurs, qui reflètent le fait qu’un tampon est créé par élément géométrique.\n","code":"\nseine_buff_5km = st_buffer(seine, dist = 5000)\nseine_buff_50km = st_buffer(seine, dist = 50000)"},{"path":"geometric-operations.html","id":"application-affine","chapter":"5 Opèrations géométriques","heading":"5.2.4 Application affine","text":"\nUne application affine est une transformation qui préserve les lignes et le parallélisme.\nCependant, les angles ou la longueur ne sont pas nécessairement préservés.\nLes transformations affines comprennent, entre autres, le déplacement (translation), la mise à l’échelle et la rotation.\nEn outre, il est possible d’utiliser n’importe quelle combinaison de celles-ci.\nLes applications affines sont une partie essentielle de la géocomputation.\nPar exemple, le décalage est nécessaire pour le placement d’étiquettes, la mise à l’échelle est utilisée dans les cartogrammes de zones non contiguës (voir la section ??), et de nombreuses transformations affines sont appliquées lors de la reprojection ou de l’amélioration de la géométrie créée à partir d’une carte déformée ou mal projetée.\nLe paquet sf implémente la transformation affine pour les objets des classes sfg et sfc.Le décalage déplace chaque point de la même distance en unités cartographiques.\nCela peut être fait en ajoutant un vecteur numérique à un objet vectoriel.\nPar exemple, le code ci-dessous déplace toutes les coordonnées y de 100 000 mètres vers le nord, mais laisse les coordonnées x intactes (panneau gauche de la figure 5.5).La mise à l’échelle agrandit ou rétrécit les objets par un facteur.\nElle peut être appliquée de manière globale ou locale.\nLa mise à l’échelle globale augmente ou diminue toutes les valeurs des coordonnées par rapport aux coordonnées d’origine, tout en gardant intactes les relations topologiques de toutes les géométries.\nElle peut être effectuée par soustraction ou multiplication d’un objet sfg ou sfc.Le changement à l’échelle locale traite les géométries indépendamment et nécessite des points autour desquels les géométries vont être mises à l’échelle, par exemple des centroïdes.\nDans l’exemple ci-dessous, chaque géométrie est réduite d’un facteur deux autour des centroïdes (panneau central de la figure 5.5).\nPour cela, chaque objet est d’abord décalé de manière à ce que son centre ait les coordonnées 0, 0 ((nz_sfc - nz_centroid_sfc)).\nEnsuite, les tailles des géométries sont réduites de moitié (* 0.5).\nEnfin, le centroïde de chaque objet est ramené aux coordonnées des données d’entrée (+ nz_centroid_sfc).La rotation de coordonnées bidimensionnelles nécessite une matrice de rotation :\\[\nR =\n\\begin{bmatrix}\n\\cos \\theta & -\\sin \\theta \\\\  \n\\sin \\theta & \\cos \\theta \\\\\n\\end{bmatrix}\n\\]Elle fait tourner les points dans le sens des aiguilles d’une montre.\nLa matrice de rotation peut être implémentée dans R comme suit :La fonction rotation accepte un argument - un angle de rotation en degrés.\nLa rotation peut être effectuée autour de points sélectionnés, comme les centroïdes (panneau de droite de la figure 5.5).\nVoir vignette(\"sf3\") pour plus d’exemples.\nFIGURE 5.5: Illustrations des transformations affines : décalage, échelle et rotation.\nEnfin, les géométries nouvellement créées peuvent remplacer les anciennes avec la fonction st_set_geometry() :","code":"\nnz_sfc = st_geometry(nz)\nnz_shift = nz_sfc + c(0, 100000)\nnz_centroid_sfc = st_centroid(nz_sfc)\nnz_scale = (nz_sfc - nz_centroid_sfc) * 0.5 + nz_centroid_sfc\nrotation = function(a){\n  r = a * pi / 180 #degrées en radians\n  matrix(c(cos(r), sin(r), -sin(r), cos(r)), nrow = 2, ncol = 2)\n} \nnz_rotate = (nz_sfc - nz_centroid_sfc) * rotation(30) + nz_centroid_sfc\nnz_scale_sf = st_set_geometry(nz, nz_scale)"},{"path":"geometric-operations.html","id":"clipping","chapter":"5 Opèrations géométriques","heading":"5.2.5 Découper","text":"\nLe découpage spatial est une forme de sélection spatiale qui implique des changements dans les colonnes géométriques d’au moins certaines des entités affectées.Le découpage ne peut s’appliquer qu’à des éléments plus complexes que des points :\nles lignes, les polygones et leurs équivalents “multi”.\nPour illustrer le concept, nous allons commencer par un exemple simple :\ndeux cercles superposés dont le point central est distant d’une unité et dont le rayon est de un (Figure 5.6).\nFIGURE 5.6: cercles superposés.\nImaginez que vous voulez sélectionner non pas un cercle ou l’autre, mais l’espace couvert par les deux x et y.\nCela peut être fait en utilisant la fonction st_intersection(), illustrée en utilisant des objets nommés x et y qui représentent les cercles de gauche et de droite (Figure 5.7).\nFIGURE 5.7: Cercles superposés avec une couleur grise pour indiquer l’intersection entre eux\nLe passage de code suivant montre comment cela fonctionne pour toutes les combinaisons du diagramme de Venn représentant x et y, inspiré de la Figure 5.1 du livre R Data Science (Grolemund Wickham 2016).\nFIGURE 5.8: Équivalents spatiaux des opérateurs logiques.\n","code":"\nb = st_sfc(st_point(c(0, 1)), st_point(c(1, 1))) # créer 2 points\nb = st_buffer(b, dist = 1) # convertir les points en cercles\nplot(b, border = \"grey\")\ntext(x = c(-0.5, 1.5), y = 1, labels = c(\"x\", \"y\"), cex = 3) # ajout du texte\nx = b[1]\ny = b[2]\nx_and_y = st_intersection(x, y)\nplot(b, border = \"grey\")\nplot(x_and_y, col = \"lightgrey\", border = \"grey\", add = TRUE) # surface intersectée"},{"path":"geometric-operations.html","id":"sélection-et-découpage","chapter":"5 Opèrations géométriques","heading":"5.2.6 Sélection et découpage","text":"Le découpage d’objets peut modifier leur géométrie, mais il peut également sélectionner des objets, en ne renvoyant que les entités qui intersectent (ou intersectent partiellement) un objet de découpage/sélection.\nPour illustrer ce point, nous allons sélectionner les points qui incluent dans le cadre englobant (bounding box) des cercles x et y de la figure 5.8.\nCertains points seront à l’intérieur d’un seul cercle, d’autres à l’intérieur des deux et d’autres encore à l’intérieur d’aucun.\nst_sample() est utilisé ci-dessous pour générer une distribution simple et aléatoire de points à l’intérieur de l’étendue des cercles x et y, ce qui donne le résultat illustré dans la Figure 5.9, ce qui soulève la question suivante : comment sous-ensembler les points pour ne renvoyer que le point qui intersecte à la fois x et y ?\nFIGURE 5.9: Points distribués de manière aléatoire dans le cadre englobant les cercles x et y. Les points qui croisent les deux objets x et y sont mis en évidence.\nLe code ci-dessous montre trois façons d’obtenir le même résultat.\nNous pouvons utiliser directement l’intersection index{vecteur!intersection} dexety(représentée parx_et_ydans l'extrait de code précédent) comme objet de sélection, comme le montre la première ligne du morceau de code ci-dessous. Nous pouvons également trouver l'intersection entre les points d'entrée représentés parpet l'objet de sélection et de découpagex_et_y, comme le montre la deuxième ligne du code ci-dessous. Cette deuxième approche renvoie les entités qui ont une intersection partielle avecx_and_ymais avec des géométries modifiées pour les entités dont les surfaces recoupent celle de l'objet de sélection. La troisième approche consiste à créer un objet de sélection en utilisant le prédicat spatial binairest_intersects()`, introduit dans le chapitre précédent.\nLes résultats sont identiques (à l’exception de différences superficielles dans les noms d’attributs), mais l’implémentation diffère substantiellement :Bien que l’exemple ci-dessus soit plutôt trivial et fourni à des fins éducatives plutôt qu’appliquées, et que nous encouragions le lecteur à reproduire les résultats pour approfondir sa compréhension de la manipulation des objets vectoriels géographiques dans R, il soulève une question importante : quelle implémentation utiliser ?\nEn général, les implémentations les plus concises doivent être privilégiées, ce qui signifie la première approche ci-dessus.\nNous reviendrons sur la question du choix entre différentes implémentations d’une même technique ou d’un même algorithme au chapitre ??.","code":"\nbb = st_bbox(st_union(x, y))\nbox = st_as_sfc(bb)\nset.seed(2017)\np = st_sample(x = box, size = 10)\nx_and_y = st_intersection(x, y)\np_xy1 = p[x_and_y]\np_xy2 = st_intersection(p, x_and_y)\nsel_p_xy = st_intersects(p, x, sparse = FALSE)[, 1] &\n  st_intersects(p, y, sparse = FALSE)[, 1]\np_xy3 = p[sel_p_xy]"},{"path":"geometric-operations.html","id":"gunions-de-géométries","chapter":"5 Opèrations géométriques","heading":"5.2.7 GUnions de géométries","text":"\nComme nous l’avons vu dans la section ??, l’agrégation spatiale peut dissoudre silencieusement les géométries des polygones se touchant dans le même groupe.\nCela est démontré dans le code ci-dessous dans lequel 49 us_states sont agrégés en 4 régions à l’aide des fonctions de R base et du tidyverse (voir les résultats dans la figure 5.10) :\nFIGURE 5.10: Agrégation spatiale sur des polygones contigus, illustrée par l’agrégation de la population des États américains en régions, la population étant représentée par une couleur. Notez que l’opération dissout automatiquement les frontières entre les états.\nQue se passe-t-il au niveau des géométries ?\nEn coulisses, aggregate() et summarize() combinent les géométries et dissolvent les frontières entre elles en utilisant st_union().\nCeci est démontré par le code ci-dessous qui crée une union des Etats-Unis de l’Ouest :La fonction peut prendre deux géométries et les unir, comme le montre ll code ci-dessous qui crée un bloc occidental uni incorporant le Texas (défi : reproduire et représenter le résultat) :","code":"\nregions = aggregate(x = us_states[, \"total_pop_15\"], by = list(us_states$REGION),\n                    FUN = sum, na.rm = TRUE)\nregions2 = us_states %>% group_by(REGION) %>%\n  summarize(pop = sum(total_pop_15, na.rm = TRUE))\nus_west = us_states[us_states$REGION == \"West\", ]\nus_west_union = st_union(us_west)\ntexas = us_states[us_states$NAME == \"Texas\", ]\ntexas_union = st_union(us_west_union, texas)"},{"path":"geometric-operations.html","id":"type-trans","chapter":"5 Opèrations géométriques","heading":"5.2.8 Transformations de type","text":"\nLa transformation d’un type de géométrie en un autre (casting) est une opération puissante.\nElle est implémentée dans la fonction st_cast() du package sf.\nIl est important de noter que la fonction st_cast() se comporte différemment selon qu’il s’agit d’un objet géométrique simple (sfg), d’une colonne géométrique simple (sfc) ou d’un objet simple.Créons un multipoint pour illustrer le fonctionnement des transformations de type géométrique sur des objets de géométrie simple (sfg) :Dans ce cas, st_cast() peut être utile pour transformer le nouvel objet en linestring (ligne) ou en polygone (Figure 5.11) :\nFIGURE 5.11: Exemples de lignes et de polygones créés à partir d’une géométrie multipoint\nLa conversion de multipoint en ligne est une opération courante qui crée un objet ligne à partir d’observations ponctuelles ordonnées, telles que des mesures GPS ou des sources géolocalisés.\nCela permet d’effectuer des opérations spatiales telles que la longueur du chemin parcouru.\nLa conversion de multipoint ou de linestring en polygone est souvent utilisée pour calculer une surface, par exemple à partir de l’ensemble des mesures GPS prises autour d’un lac ou des coins d’un terrain à bâtir.Le processus de transformation peut également être inversé en utilisant st_cast() :La transformation en différent types géométrique des colonnes géométriques d’entités simples (sfc) et des objets d’entités simples fonctionnent de la même manière que pour les géométries simples (sfg) dans la plupart des cas.\nUne différence importante est la conversion des multi-types en non-multi-types.\nÀ la suite de ce processus, les multi-objets, sf ou sfg sont divisés en plusieurs non-multi-objets.Le tableau 5.1 montre les transformations de type géométrique possibles sur les objets d’entités simples.\nLes géométries d’entités simples (représentées par la première colonne du tableau) peuvent être transformées en plusieurs types de géométrie, représentés par les colonnes du tableau 5.1\nPlusieurs des transformations ne sont pas possibles, par exemple, vous ne pouvez pas convertir un point unique en un multilinestring ou un polygone (ainsi les cellules [1, 4:5] dans le tableau sont NA).\nCertaines transformations divisent l’objet d’entrée: passe d’un élément unique en un objet à éléments multiples.\nLorsqu’une géométrie multipoint constituée de cinq paires de coordonnées est transformée en géométrie “POINT”, par exemple, la sortie contiendra cinq entités.\nTABLE 5.1: Transformation de type de géométrie sur des entités simples (voir section 2.1) avec un type d’entrée par ligne et type de sortie par colonne\nEssayons d’appliquer des transformations de type géométrique sur un nouvel objet, multilinestring_sf, à titre d’exemple (à gauche sur la Figure 5.12) :Vous pouvez l’imaginer comme un réseau routier ou fluvial.\nLe nouvel objet n’qu’une seule ligne qui définit toutes les lignes.\nCela limite le nombre d’opérations qui peuvent être faites, par exemple, cela empêche d’ajouter des noms à chaque segment de ligne ou de calculer les longueurs des lignes individuelles.\nLa fonction st_cast() peut être utilisée dans cette situation, car elle sépare un mutlilinestring en trois linestrings :\nFIGURE 5.12: Exemples de transformation de type de géométrie entre MULTILINESTRING (à gauche) et LINESTRING (à droite).\nLe nouvel objet permet la création d’attributs (voir la section 3.2.5) et la mesure de la longueur :","code":"\nmultipoint = st_multipoint(matrix(c(1, 3, 5, 1, 3, 1), ncol = 2))\nlinestring = st_cast(multipoint, \"LINESTRING\")\npolyg = st_cast(multipoint, \"POLYGON\")\nmultipoint_2 = st_cast(linestring, \"MULTIPOINT\")\nmultipoint_3 = st_cast(polyg, \"MULTIPOINT\")\nall.equal(multipoint, multipoint_2)\n#> [1] TRUE\nall.equal(multipoint, multipoint_3)\n#> [1] TRUE\nmultilinestring_list = list(matrix(c(1, 4, 5, 3), ncol = 2), \n                            matrix(c(4, 4, 4, 1), ncol = 2),\n                            matrix(c(2, 4, 2, 2), ncol = 2))\nmultilinestring = st_multilinestring((multilinestring_list))\nmultilinestring_sf = st_sf(geom = st_sfc(multilinestring))\nmultilinestring_sf\n#> Simple feature collection with 1 feature and 0 fields\n#> Geometry type: MULTILINESTRING\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5\n#> CRS:           NA\n#>                             geom\n#> 1 MULTILINESTRING ((1 5, 4 3)...\nlinestring_sf2 = st_cast(multilinestring_sf, \"LINESTRING\")\nlinestring_sf2\n#> Simple feature collection with 3 features and 0 fields\n#> Geometry type: LINESTRING\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5\n#> CRS:           NA\n#>                    geom\n#> 1 LINESTRING (1 5, 4 3)\n#> 2 LINESTRING (4 4, 4 1)\n#> 3 LINESTRING (2 2, 4 2)\nlinestring_sf2$name = c(\"Riddle Rd\", \"Marshall Ave\", \"Foulke St\")\nlinestring_sf2$length = st_length(linestring_sf2)\nlinestring_sf2\n#> Simple feature collection with 3 features and 2 fields\n#> Geometry type: LINESTRING\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 5\n#> CRS:           NA\n#>                    geom         name length\n#> 1 LINESTRING (1 5, 4 3)    Riddle Rd   3.61\n#> 2 LINESTRING (4 4, 4 1) Marshall Ave   3.00\n#> 3 LINESTRING (2 2, 4 2)    Foulke St   2.00"},{"path":"geometric-operations.html","id":"geo-ras","chapter":"5 Opèrations géométriques","heading":"5.3 Opérations géométriques sur les données raster","text":"\nLes opérations géométriques sur des raster comprennent le décalage, le retournement, la mise en miroir, la mise à l’échelle, la rotation ou la déformation des images.\nCes opérations sont nécessaires pour une variété d’applications, y compris le géoréférencement, utilisé pour permettre aux images d’être superposées sur une carte précise avec un CRS connu (Liu Mason 2009).\nIl existe une variété de techniques de géoréférencement, notamment :Géorectification basée sur des points de contrôle au sol connusOrthorectification, qui tient également compte de la topographie locale.L’enregistrement d’images est utilisé pour combiner des images de la même chose mais prises par différents capteurs en alignant une image sur une autre (en termes de système de coordonnées et de résolution).R est plutôt inadapté pour les deux premiers points car ceux-ci nécessitent souvent une intervention manuelle, c’est pourquoi ils sont généralement réalisés à l’aide d’un logiciel SIG dédié (voir également le chapitre : ??).\nEn revanche, l’alignement de plusieurs images est possible dans R et cette section montre entre autres comment le faire.\nCela implique souvent de modifier l’étendue, la résolution et l’origine d’une image.\nUne projection correspondante est bien sûr également nécessaire, mais elle est déjà traitée dans la section ??.Dans tous les cas, il existe d’autres raisons d’effectuer une opération géométrique sur une seule image raster.\nPar exemple, dans le chapitre ?? nous définissons les zones métropolitaines en Allemagne comme des pixels de 20 km2 avec plus de 500.000 habitants.\nLa trame d’habitants d’origine cependant une résolution de 1 km2, c’est pourquoi nous allons diminuer (agréger) la résolution d’un facteur 20 (voir le chapitre ??).\nUne autre raison d’agréger une image matricielle est simplement de réduire le temps d’exécution ou d’économiser de l’espace disque.\nBien entendu, cela n’est possible que si la tâche à accomplir permet une résolution plus grossière.\nParfois, une résolution plus grossière est suffisante!","code":""},{"path":"geometric-operations.html","id":"intersections-géométriques","chapter":"5 Opèrations géométriques","heading":"5.3.1 Intersections géométriques","text":"\nDans la section 4.3.1, nous avons montré comment extraire des valeurs d’un raster superposé à d’autres objets spatiaux.\nPour récupérer une sortie spatiale, nous pouvons utiliser pratiquement la même syntaxe de sélection.\nLa seule différence est que nous devons préciser que nous souhaitons conserver la structure matricielle en mettant l’argument drop à FALSE.\nCeci retournera un objet raster contenant les cellules dont les points médians se chevauchent avec clip.Pour la même opération, nous pouvons également utiliser les commandes intersect() et crop().","code":"\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nclip = rast(xmin = 0.9, xmax = 1.8, ymin = -0.45, ymax = 0.45,\n            resolution = 0.3, vals = rep(1, 9))\nelev[clip, drop = FALSE]\n#> class       : SpatRaster \n#> dimensions  : 2, 1, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : 1, 1.5, -0.5, 0.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : memory \n#> name        : elev \n#> min value   :   18 \n#> max value   :   24"},{"path":"geometric-operations.html","id":"étendue-et-origine","chapter":"5 Opèrations géométriques","heading":"5.3.2 Étendue et origine","text":"\nLors de la fusion ou de l’exécution de l’algèbre raster sur des rasters, leur résolution, leur projection, leur origine et/ou leur étendue doivent correspondre. Sinon, comment ajouter les valeurs d’un raster ayant une résolution de 0,2 degré décimal à un second raster ayant une résolution de 1 degré décimal ?\nLe même problème se pose lorsque nous souhaitons fusionner des images satellite provenant de différents capteurs avec des projections et des résolutions différentes.\nNous pouvons traiter de telles disparités en alignant les trames.Dans le cas le plus simple, deux images ne diffèrent que par leur étendue.\nLe code suivant ajoute une ligne et deux colonnes de chaque côté de l’image raster tout en fixant toutes les nouvelles valeurs à une altitude de 1000 mètres (Figure 5.13).\nFIGURE 5.13: Trame originale (à gauche) et la même trame (à droite) agrandie d’une ligne en haut et en bas et de deux colonnes à gauche et à droite.\nPerforming algebraic operation two objects differing extents R, terra package returns error.Cependant, nous pouvons aligner l’étendue de deux rasters avec extend().\nAu lieu d’indiquer à la fonction le nombre de lignes ou de colonnes à ajouter (comme nous l’avons fait précédemment), nous lui permettons de le déterminer en utilisant un autre objet raster.\nIci, nous étendons l’objet elev à l’étendue de elev_2.\nLes lignes et colonnes nouvellement ajoutées reçoivent NA.L’origine d’un raster est le coin de la cellule le plus proche des coordonnées (0, 0).\nLa fonction origin() renvoie les coordonnées de l’origine.\nDans l’exemple ci-dessous, un coin de cellule existe avec les coordonnées (0, 0), mais ce n’est pas toujours le cas.Si deux rasters ont des origines différentes, leurs cellules ne se chevauchent pas complètement, ce qui rends l’algèbre raster impossible.\nPour changer l’origine – utilisez origin().24\nLa figure 5.14 révèle l’effet de la modification de l’origine de cette manière.\nFIGURE 5.14: Rasters avec des valeurs identiques mais des origines différentes.\nNotez que le changement de résolution (section suivante) modifie souvent aussi l’origine.","code":"\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_2 = extend(elev, c(1, 2))\nelev_3 = elev + elev_2\n#> Error: [+] extents do not match\nelev_4 = extend(elev, elev_2)\norigin(elev_4)\n#> [1] 0 0\n# changer l'origine\norigin(elev_4) = c(0.25, 0.25)"},{"path":"geometric-operations.html","id":"agrégation-et-désagrégation","chapter":"5 Opèrations géométriques","heading":"5.3.3 Agrégation et désagrégation","text":"\nLes jeux de données raster peuvent également différer en ce qui concerne leur résolution.\nPour faire correspondre les résolutions, peut soit diminuer (aggregate()) soit augmenter (disagg()) la résolution des rasters.25\nÀ titre d’exemple, nous modifions ici la résolution spatiale de dem (trouvé dans le paquet spDataLarge) par un facteur 5 (Figure 5.15).\nDe plus, la valeur de la cellule de sortie doit correspondre à la moyenne des cellules d’entrée (notez que l’pourrait également utiliser d’autres fonctions, telles que median(), sum(), etc ):\nFIGURE 5.15: Raster original (gauche). Raster agrégé (droite).\nLa fonction disagg() augmente la résolution des objets matriciels, en fournissant deux méthodes pour assigner des valeurs aux cellules nouvellement créées : la méthode par défaut (method = \"near\") donne simplement à toutes les cellules de sortie la valeur de la cellule d’entrée, et donc duplique les valeurs, ce qui conduit à une sortie “en bloc”.\nLa méthode bilinear utilise les quatre centres de pixels les plus proches de l’image d’entrée (points de couleur saumon sur la figure 5.16) pour calculer une moyenne pondérée par la distance (flèches sur la figure 5.16.\nLa valeur de la cellule de sortie est représentée par un carré dans le coin supérieur gauche de la figure 5.16).\nFIGURE 5.16: La moyenne pondérée par la distance des quatre cellules d’entrée les plus proches détermine la sortie lors de l’utilisation de la méthode bilinéaire pour la désagrégation.\nEn comparant les valeurs de dem et dem_disagg, constate qu’elles ne sont pas identiques (vous pouvez aussi utiliser compareGeom() ou .equal()).\nCependant, il ne fallait pas s’y attendre, puisque la désagrégation est une simple technique d’interpolation.\nIl est important de garder à l’esprit que la désagrégation permet d’obtenir une résolution plus fine ; les valeurs correspondantes, cependant, ne peuvent qu’êtres aussi précises que leur source de résolution initiale.","code":"\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ndem_agg = aggregate(dem, fact = 5, fun = mean)\ndem_disagg = disagg(dem_agg, fact = 5, method = \"bilinear\")\nidentical(dem, dem_disagg)\n#> [1] FALSE"},{"path":"geometric-operations.html","id":"rééchantillonnage","chapter":"5 Opèrations géométriques","heading":"5.3.4 Rééchantillonnage","text":"\nLes méthodes d’agrégation et de désagrégation ci-dessus ne conviennent que lorsque nous voulons modifier la résolution de notre raster par le facteur d’agrégation/désagrégation.\nCependant, que faire lorsque nous avons deux ou plusieurs raster avec des résolutions et des origines différentes ?\nC’est le rôle du rééchantillonnage - un processus de calcul des valeurs pour les nouveaux emplacements des pixels.\nEn bref, ce processus prend les valeurs de notre raster original et recalcule de nouvelles valeurs pour un raster cible avec une résolution et une origine personnalisées.Il existe plusieurs méthodes pour estimer les valeurs d’un raster avec différentes résolutions/origines, comme le montre la figure 5.17.\nCes méthodes comprennent :Plus proche voisin - attribue la valeur de la cellule la plus proche du raster original à la cellule du raster cible.\nCette méthode est rapide et convient généralement aux raster de catégories.Interpolation bilinéaire - affecte une moyenne pondérée des quatre cellules les plus proches de l’image originale à la cellule de l’image cible (Figure 5.16). La méthode la plus rapide pour les rasters continusInterpolation cubique - utilise les valeurs des 16 cellules les plus proches de la trame d’origine pour déterminer la valeur de la cellule de sortie, en appliquant des fonctions polynomiales du troisième ordre. Elle est aussi utilisée pour les raster continus. Elle permet d’obtenir une surface plus lissée que l’interpolation bilinéaire, mais elle est également plus exigeante en termes de calcul.Interpolation par spline cubique - utilise également les valeurs des 16 cellules les plus proches de la trame d’origine pour déterminer la valeur de la cellule de sortie, mais applique des splines cubiques (fonctions polynomiales du troisième ordre par morceaux) pour obtenir les résultats. Elle est utilisée pour les trames continuesRééchantillonnage par fenêtré de Lanczos - utilise les valeurs des 36 cellules les plus proches de la trame d’origine pour déterminer la valeur de la cellule de sortie. Il est tilisé pour les raster continues^ [Une explication plus détaillée de cette méthode peut être trouvée sur https://gis.stackexchange.com//14361/20955.]Les explications ci-dessus mettent en évidence le fait que seul le rééchantillonnage par voisin le plus proche est adapté aux rasters contenant des catégories, alors que toutes les méthodes peuvent être utilisées (avec des résultats différents) pour les matrices continues.\nEn outre, chaque méthode successive nécessite plus de temps de traitement.Pour appliquer le rééchantillonnage, le package terra fournit une fonction resample().\nElle accepte un raster d’entrée (x), un raster avec des propriétés spatiales cibles (y), et une méthode de rééchantillonnage (method).Nous avons besoin d’un raster avec des propriétés spatiales cibles pour voir comment la fonction resample() fonctionne.\nPour cet exemple, nous créons target_rast, mais vous utiliserez souvent un objet raster déjà existant.Ensuite, nous devons fournir nos deux objets rasters comme deux premiers arguments et l’une des méthodes de rééchantillonnage décrites ci-dessus.La figure 5.17 montre une comparaison de différentes méthodes de rééchantillonnage sur l’objet dem.\nFIGURE 5.17: Comparaison visuelle du raster d’entré et de cinq méthodes de rééchantillonnage différentes.\nComme vous le verrez dans la section ??, la reprojection de raster est un cas particulier de rééchantillonnage lorsque notre raster cible un CRS différent de la trame d’origine.La plupart des opérations géométriques dans terra sont conviviales, plutôt rapides, et fonctionnent sur de grands objets rasters.\nCependant, il peut y avoir des cas où terra n´est pas le plus performant, que ce soit pour des objets rasters étendus ou pour de nombreux fichiers rasters, et où des alternatives doivent être envisagées.Les alternatives les plus établies sont fournies par la bibliothèque GDAL.\nElle contient plusieurs fonctions utilitaires, dont :gdalinfo - liste diverses informations sur un fichier raster, y compris sa résolution, son CRS, sa boîte de délimitation, et plus encore.gdal_translate - convertit les données raster entre différents formats de fichiers.gdal_rasterize - Convertit les données vectorielles en fichiers raster.gdalwarp - permet le mosaïquage, le rééchantillonnage, le recadrage et la reprojection de données matricielles.","code":"\ntarget_rast = rast(xmin = 794600, xmax = 798200, \n                   ymin = 8931800, ymax = 8935400,\n                   resolution = 150, crs = \"EPSG:32717\")\ndem_resampl = resample(dem, y = target_rast, method = \"bilinear\")"},{"path":"geometric-operations.html","id":"exercises-2","chapter":"5 Opèrations géométriques","heading":"5.4 Exercises","text":"E1. Générer et représenter des versions simplifiées de l’ensemble de données nz.\nExpérimentez avec différentes valeurs de keep (allant de 0,5 à 0,00005) pour ms_simplify() et dTolerance (de 100 à 100 000) pour st_simplify().À partir de quelle valeur la forme du résultat commence-t-elle à se dégrader pour chaque méthode, rendant la Nouvelle-Zélande méconnaissable ?Avancé : Qu’est-ce qui est différent dans le type de géométrie des résultats de st_simplify() par rapport au type de géométrie de ms_simplify() ? Quels problèmes cela crée-t-il et comment peut-les résoudre ?E2. Dans le premier exercice du chapitre Opérations sur les données spatiales, il été établi que la région de Canterbury comptait 70 des 101 points les plus élevés de Nouvelle-Zélande.\nEn utilisant st_buffer(), combien de points dans nz_height sont à moins de 100 km de Canterbury ?E3. Trouvez le centroïde géographique de la Nouvelle-Zélande.\nquelle distance se trouve-t-il du centroïde géographique de Canterbury ?E4. La plupart des cartes du monde sont orientées du nord vers le haut.\nUne carte du monde orientée vers le sud pourrait être créée par une réflexion (une des transformations affines non mentionnées dans ce chapitre) de la géométrie de l’objet world.\nComment faire ?\nAstuce : vous devez utiliser un vecteur à deux éléments pour cette transformation.\nBonus : créez une carte de votre pays à l’envers.E5. Sélectionnez le point dans p qui est contenu dans x et y.En utilisant les opérateurs de sélection de base.En utilisant un objet intermédiaire créé avec st_intersection().E6. Calculez la longueur des limites des États américains en mètres.\nQuel État la frontière la plus longue et quel État la plus courte ?\nIndice : La fonction st_length calcule la longueur d’une géométrie LINESTRING ou MULTILINESTRING.E7. Lire le fichier srtm.tif dans R (srtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))).\nCe raster une résolution de 0.00083 par 0.00083 degrés.\nChangez sa résolution à 0,01 par 0,01 degrés en utilisant toutes les méthodes disponibles dans le paquet terra.\nVisualisez les résultats.\nPouvez-vous remarquer des différences entre les résultats de ces différentes méthodes de rééchantillonnage ?","code":""},{"path":"raster-vector.html","id":"raster-vector","chapter":"6 Interactions raster-vecteur","heading":"6 Interactions raster-vecteur","text":"Ce chapitre nécessite les paquets suivants :","code":"\nlibrary(dplyr)\nlibrary(terra)\nlibrary(sf)"},{"path":"raster-vector.html","id":"introduction-3","chapter":"6 Interactions raster-vecteur","heading":"6.1 Introduction","text":"\nCe chapitre porte sur les interactions entre les modèles de données géographiques raster et vectorielles, introduites au chapitre 2.\nIl comprend quatre techniques principales :\nle découpage et les masques de données raster à l’aide d’objets vectoriels (chapitre ??) ;\nl’extraction de valeurs raster à l’aide de différents types de données vectorielles (section ??) ;\net la conversion raster-vecteur (sections 6.4 et ??).\nLes concepts ci-dessus sont démontrés à l’aide des données utilisées dans les chapitres précédents afin de comprendre leurs applications potentielles dans le monde réel.","code":""},{"path":"raster-vector.html","id":"découpage-de-raster","chapter":"6 Interactions raster-vecteur","heading":"6.2 Découpage de raster","text":"\nDe nombreux projets de données géographiques impliquent l’intégration de données provenant de nombreuses sources différentes, telles que des images de télédétection (rasters) et des limites administratives (vecteurs).\nSouvent, l’étendue des jeux de données raster en entrée est plus grande que la zone d’intérêt.\nDans ce cas, le cropping (découpage) et le masking (masque) sont utiles pour unifier l’étendue spatiale des données d’entrée.\nCes deux opérations réduisent l’utilisation de la mémoire des objets et les ressources informatiques associées pour les étapes d’analyse ultérieures, et peuvent constituer une étape de prétraitement nécessaire avant de créer des cartes attrayantes impliquant des données rasters.Nous allons utiliser deux objets pour illustrer le recadrage d’un raster :Un objet SpatRaster srtm représentant l’altitude (mètres au-dessus du niveau de la mer) dans le sud-ouest de l’Utah.Un objet vectoriel (sf) zion représentant le parc national de Zion.Les objets cibles et les objets de recadrage doivent avoir la même projection.\nL’extrait de code suivant lit donc les jeux de données du paquet spDataLarge (installé au chapitre 2) puis il reprojette zion (voir le chapitre ?? pour en savoir plus sur la reprojection) :Nous allons utiliser crop() du paquet terra pour découper le raster srtm.\nElle réduit l’étendue rectangulaire de l’objet passé en premier argument en fonction de l’étendue de l’objet passé en second argument, comme le montre la commande ci-dessous (qui génère la figure 6.1(B) — notez la plus petite étendue du fond de l’image) :\nLa fonction terra mask() est liée à crop(), qui définit les valeurs situées en dehors des limites de l’objet passé en second argument à NA.\nLa commande suivante masque donc toutes les cellules situées à l’extérieur des limites du parc national de Zion (figure 6.1(C)) :La fonction terra mask() est liée à crop(), elle définit les valeurs situées en dehors des limites de l’objet passé en second argument à NA.\nLa commande suivante masque donc toutes les cellules situées à l’extérieur des limites du parc national de Zion (figure 6.1(C)) :En modifiant les paramètres de mask(), obtient des résultats différents.\nEn réglant updatevalue = 0, par exemple, tous les pixels à l’extérieur du parc national seront mis à 0.\nSi vous définissez inverse = TRUE, vous masquerez tout ce qui se trouve à l’intérieur des limites du parc (voir ?mask pour plus de détails) (Figure 6.1(D)).\nFIGURE 6.1: Illustration du découpage et de l’application de masque sur des rasters.\n","code":"\nsrtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nzion = read_sf(system.file(\"vector/zion.gpkg\", package = \"spDataLarge\"))\nzion = st_transform(zion, crs(srtm))\nsrtm_cropped = crop(srtm, vect(zion))\nsrtm_masked = mask(srtm, vect(zion))\nsrtm_cropped = crop(srtm, vect(zion))\nsrtm_final = mask(srtm_cropped, vect(zion))\nsrtm_inv_masked = mask(srtm, vect(zion), inverse = TRUE)"},{"path":"raster-vector.html","id":"extraction-de-raster","chapter":"6 Interactions raster-vecteur","heading":"6.3 Extraction de raster","text":"\nL’extraction de raster est le processus d’identification et de retour des valeurs associées d’une image raster “cible” à des emplacements spécifiques, en fonction d’un objet “sélecteur” géographique (généralement vectoriel).\nLes résultats dépendent du type de sélecteur utilisé (points, lignes ou polygones) et des arguments passés à la fonction terra::extract(), qui sera utilisée pour démontrer l’extraction raster.\nL’inverse de l’extraction raster — l’attribution de valeurs de cellules basées sur des objets vectoriels — est la rasterisation, décrite dans la section 6.4’.L’exemple le plus simple consiste à extraire la valeur d’une cellule matricielle à des points spécifiques.\nDans ce , nous utiliserons zion_points, qui contient un échantillon de 30 emplacements dans le Parc National de Zion (Figure 6.2).\nLa commande suivante extrait les valeurs d’élévation de srtm et crée un cadre de données avec les ID des points (une valeur par ligne du vecteur) et les valeurs srtm associées pour chaque point.\nMaintenant, nous pouvons ajouter l’objet résultant à notre jeu de données zion_points avec la fonction cbind() :\nFIGURE 6.2: Localisation des points utilisés pour l’extraction de la trame.\nL’extraction raster fonctionne également avec des sélecteurs de type ligne.\nElle extrait alors une valeur pour chaque cellule matricielle touchée par une ligne.\nCependant, elle n’est pas recommandée pour obtenir des valeurs le long des transects car il est difficile d’obtenir la distance correcte entre chaque paire de valeurs extraites.Dans ce cas, une meilleure approche consiste à diviser la ligne en plusieurs points, puis à extraire les valeurs de ces points.\nPour le démontrer, le code ci-dessous crée zion_transect, une ligne droite allant du nord-ouest au sud-est du parc national de Zion, illustrée sur la figure 6.3() (voir la section ?? pour un récapitulatif du modèle de données vectorielles) :L’utilité de l’extraction des hauteurs à partir d’un sélecteur linéaire est illustrée en imaginant que vous planifiez une randonnée.\nLa méthode présentée ci-dessous fournit un “profil d’élévation” de l’itinéraire (la ligne n’pas besoin d’être droite), utile pour estimer la durée de la randonnée en cas de longues montées.La première étape est d’ajouter un id unique pour chaque transect.\nEnsuite, avec la fonction st_segmentize(), nous pouvons ajouter des points le long de nos lignes en spécifiant une densité de points (dfMaxLength) et les convertir en points avec st_cast().Maintenant, nous avons un grand nombre de points et nous voulons calculer la distance entre le premier point de nos transects et chacun des points suivants.\nDans ce cas, nous n’avons qu’un seul transect, mais le code, en principe, devrait fonctionner sur n’importe quel nombre de transects :Enfin, nous pouvons extraire les valeurs d’élévation pour chaque point de nos transects et combiner ces informations avec notre objet principal.Le zion_transect résultant peut être utilisé pour créer des profils d’élévation, comme illustré sur la figure 6.3(B).\nFIGURE 6.3: Location line used raster extraction (left) elevation along line (right).\nLe dernier type d’objet vectoriel géographique pour l’extraction de raster est le polygone.\nComme les lignes, les polygones ont tendance à retourner de nombreuses valeurs matricielles par polygone.\nCeci est démontré dans la commande ci-dessous, qui résulte en un jeux de données avec les noms de colonnes ID (le numéro de ligne du polygone) et srtm (valeurs d’élévation associées)Ces résultats peuvent être utilisés pour générer des statistiques synthétiques pour les valeurs matricielles par polygone, par exemple pour caractériser une seule région ou pour comparer plusieurs régions.\nLa génération de statistiques résumées est démontrée dans le code ci-dessous, qui crée l’objet zion_srtm_df contenant des statistiques résumées pour les valeurs d’élévation dans le Parc National de Zion (voir Figure 6.4()) :L’extrait de code précédent utilisé le tidyverse pour fournir des statistiques sommaires pour les valeurs des cellules par ID de polygone, comme décrit dans le chapitre 3.\nLes résultats fournissent des résumés utiles, par exemple que la hauteur maximale dans le parc est d’environ 2 661 mètres au-dessus du niveau de la mer (d’autres statistiques sommaires, comme l’écart-type, peuvent également être calculées de cette manière).\nÉtant donné qu’il n’y qu’un seul polygone dans l’exemple, un tableau de données avec une seule ligne est renvoyé ; cependant, la méthode fonctionne lorsque plusieurs polygones sélecteurs sont utilisés.La même approche fonctionne pour compter les occurrences de valeurs raster catégorielles dans les polygones.\nCeci est illustré avec un jeu de données de couverture du sol (nlcd) du paquet spDataLarge dans la Figure 6.4(B), et démontré dans le code ci-dessous :\nFIGURE 6.4: Extraction de données raster continues (à gauche) et catégorielles (à droite).\n","code":"\ndata(\"zion_points\", package = \"spDataLarge\")\nelevation = terra::extract(srtm, vect(zion_points))\nzion_points = cbind(zion_points, elevation)\nzion_transect = cbind(c(-113.2, -112.9), c(37.45, 37.2)) %>%\n  st_linestring() %>% \n  st_sfc(crs = crs(srtm)) %>% \n  st_sf()\nzion_transect$id = 1:nrow(zion_transect)\nzion_transect = st_segmentize(zion_transect, dfMaxLength = 250)\nzion_transect = st_cast(zion_transect, \"POINT\")\nzion_transect = zion_transect %>% \n  group_by(id) %>% \n  mutate(dist = st_distance(geometry)[, 1]) \nzion_elev = terra::extract(srtm, vect(zion_transect))\nzion_transect = cbind(zion_transect, zion_elev)\nzion_srtm_values = terra::extract(x = srtm, y = vect(zion))\ngroup_by(zion_srtm_values, ID) %>% \n  summarize(across(srtm, list(min = min, mean = mean, max = max)))\n#> # A tibble: 1 × 4\n#>      ID srtm_min srtm_mean srtm_max\n#>   <dbl>    <int>     <dbl>    <int>\n#> 1     1     1122     1818.     2661\nnlcd = rast(system.file(\"raster/nlcd.tif\", package = \"spDataLarge\"))\nzion2 = st_transform(zion, st_crs(nlcd))\nzion_nlcd = terra::extract(nlcd, vect(zion2))\nzion_nlcd %>% \n  group_by(ID, levels) %>%\n  count()\n#> # A tibble: 7 × 3\n#> # Groups:   ID, levels [7]\n#>      ID levels         n\n#>   <dbl> <fct>      <int>\n#> 1     1 Developed   4205\n#> 2     1 Barren     98285\n#> 3     1 Forest    298299\n#> 4     1 Shrubland 203701\n#> # … with 3 more rows"},{"path":"raster-vector.html","id":"rasterization","chapter":"6 Interactions raster-vecteur","heading":"6.4 Rasterisation","text":"\nLa rastérisation est la conversion d’objets vectoriels en objets rasters.\nEn général, le raster produit est utilisé pour l’analyse quantitative (par exemple, les analyses de terrain) ou la modélisation.\nComme nous l’avons vu au chapitre 2, le modèle de données raster possède certaines caractéristiques qui le rendent propice à certaines méthodes.\nEn outre, le processus de rastérisation peut contribuer à simplifier les jeux de données car les valeurs résultantes ont toutes la même résolution spatiale : la rastérisation peut être considérée comme un type particulier d’agrégation de données géographiques.Le paquet terra contient la fonction rasterize() pour effectuer ce travail.\nSes deux premiers arguments sont, x, un objet vectoriel à rasteriser et, y, un objet ‘template raster’ définissant l’étendue, la résolution et le CRS de la sortie.\nLa résolution géographique de l’objet raster en entrée un impact majeur sur les résultats : si elle est trop faible (la taille de la cellule est trop grande), le résultat peut manquer toute la variabilité géographique des données vectorielles ; si elle est trop élevée, les temps de calcul peuvent être excessifs.\nIl n’existe pas de règles simples à suivre pour décider de la résolution géographique appropriée, qui dépend fortement de l’utilisation prévue des résultats.\nSouvent, la résolution cible est imposée à l’utilisateur, par exemple lorsque le résultat d’une rastérisation doit être aligné sur des rasters existants.Pour mieux expliciter la rastérisation, nous allons utiliser un modèle de raster qui la même étendue et le même CRS que les données vectorielles d’entrée cycle_hire_osm_projected (un ensemble de données sur les points de location de vélos à Londres est illustré dans la Figure 6.5()) et une résolution spatiale de 1000 mètres :La rastérisation est une opération très flexible : les résultats dépendent non seulement de la nature du modèle de raster, mais aussi du type de vecteur d’entrée (par exemple, points, polygones) et d’une variété d’arguments pris par la fonction rasterize().Pour illustrer cette flexibilité, nous allons essayer trois approches différentes de la rastérisation.\nPremièrement, nous créons un raster représentant la présence ou l’absence de points d’attache de vélos (connu sous le nom de rasters de présence/absence).\nDans ce cas, rasterize() ne requiert qu’un seul argument en plus de x et y (les objets vecteur et raster mentionnés plus haut) : une valeur à transférer dans toutes les cellules non vides spécifiées par field (résultats illustrés Figure : 6.5(B)).L’argument fun spécifie des statistiques résumées utilisées pour convertir plusieurs observations proches en cellules associées dans l’objet raster.\nPar défaut, fun = \"last\" est utilisé mais d’autres options telles que fun = \"length\" peuvent être utilisées, dans ce cas pour compter le nombre de points de locations de vélos dans chaque cellule de la grille (les résultats de cette opération sont illustrés dans la figure 6.5(C)).La nouvelle sortie, ch_raster2, montre le nombre de points de location de vélos dans chaque cellule de la grille.\nLes points de location de vélos ont des nombres différents de vélos décrits par la variable capacité, ce qui soulève la question suivante : quelle est la capacité de chaque cellule de la grille ?\nPour le calculer, nous devons “additionner” le champ (\"capacité\"), ce qui donne la sortie illustrée dans la Figure 6.5(D), calculée avec la commande suivante (d’autres fonctions de résumé telles que la moyenne peuvent être utilisées) :\nFIGURE 6.5: Exemples de rastérisation de points.\nUn autre jeu de données basé sur les polygones et les frontières de la Californie (créé ci-dessous) illustre la rastérisation des lignes.\nAprès avoir transformé les objets de type polygone dans un multilinestring, un modèle de raster est créé avec une résolution de 0,5 degré :Lorsque l’considère la rasterisation de lignes ou de polygones, un argument supplémentaire utile est touches.\nPar défaut, il est FALSE, mais lorsqu’il est changé en TRUE – toutes les cellules qui sont touchées par une ligne ou une bordure de polygone obtiennent une valeur.\nLa rastérisation de lignes avec touches = TRUE est démontré dans le code ci-dessous (Figure 6.6()).Comparez-la à une rastérisation de polygone, avec touches = FALSE par défaut, qui ne sélectionne que les cellules dont les centroïdes sont à l’intérieur du polygone de sélection, comme illustré sur la figure 6.6(B).\nFIGURE 6.6: Examples line polygon rasterizations.\n","code":"\ncycle_hire_osm = spData::cycle_hire_osm\ncycle_hire_osm_projected = st_transform(cycle_hire_osm, \"EPSG:27700\")\nraster_template = rast(ext(cycle_hire_osm_projected), resolution = 1000,\n                       crs = st_crs(cycle_hire_osm_projected)$wkt)\nch_raster1 = rasterize(vect(cycle_hire_osm_projected), raster_template,\n                       field = 1)\nch_raster2 = rasterize(vect(cycle_hire_osm_projected), raster_template, \n                       fun = \"length\")\nch_raster3 = rasterize(vect(cycle_hire_osm_projected), raster_template, \n                       field = \"capacity\", fun = sum)\ncalifornia = dplyr::filter(us_states, NAME == \"California\")\ncalifornia_borders = st_cast(california, \"MULTILINESTRING\")\nraster_template2 = rast(ext(california), resolution = 0.5,\n                        crs = st_crs(california)$wkt)\ncalifornia_raster1 = rasterize(vect(california_borders), raster_template2,\n                               touches = TRUE)\ncalifornia_raster2 = rasterize(vect(california), raster_template2) "},{"path":"raster-vector.html","id":"vectorisation-spatiale","chapter":"6 Interactions raster-vecteur","heading":"6.5 Vectorisation spatiale","text":"\nLa vectorisation spatiale est le pendant de la rastérisation (section 6.4), mais dans le sens inverse.\nElle consiste à convertir des données matricielles spatialement continues en données vectorielles spatialement discrètes telles que des points, des lignes ou des polygones.La forme la plus simple de vectorisation consiste à convertir les centroïdes des cellules matricielles en points.\n.points() fait exactement cela pour toutes les cellules de grille raster non-NA (Figure 6.7). Notez qu'ici nous avons également utilisést_as_sf()pour convertir l'objet résultant en classesf`.\nFIGURE 6.7: Raster point representation elev object.\nUn autre type courant de vectorisation spatiale est la création de courbes de niveau représentant des lignes de hauteur continue ou des températures (isothermes) par exemple.\nNous utiliserons un vrai modèle numérique d’élévation (MNE) car le raster artificiel elev produit des lignes parallèles (tâche pour le lecteur : vérifier cela et expliquer pourquoi cela se produit).\nLes lignes de contour peuvent être créées avec la fonction terra .contour(), qui est elle-même une fonction wrapper autour de filled.contour(), comme démontré ci-dessous (non montré) :Les contours peuvent également être ajoutés aux tracés existants avec des fonctions telles que contour(), rasterVis::contourplot() ou tmap::tm_iso().\nComme l’illustre la figure 6.8, les isolignes peuvent être étiquetées.\nFIGURE 6.8: MNE avec ombrage des collines, montrant le flanc sud du Mont Mongon superposé avec des lignes de contour.\nLe dernier type de vectorisation implique la conversion de rasters en polygones.\nCeci peut être fait avec terra::.polygons(), qui convertit chaque cellule matricielle en un polygone composé de cinq coordonnées, qui sont toutes stockées en mémoire (ce qui explique pourquoi les matrices sont souvent rapides comparées aux vecteurs !)Ceci est illustré ci-dessous en convertissant l’objet grain en polygones et en dissolvant ensuite les frontières entre les polygones ayant les mêmes valeurs d’attributs (voir aussi l’argument dissolve dans .polygons()).\nFIGURE 6.9: Illustration de la vectorisation d’un raster (à gauche) en polygone (au centre) et de l’agrégation de polygones (à droite).\n","code":"\nelev = rast(system.file(\"raster/elev.tif\", package = \"spData\"))\nelev_point = as.points(elev) %>% \n  st_as_sf()\ndem = rast(system.file(\"raster/dem.tif\", package = \"spDataLarge\"))\ncl = as.contour(dem)\nplot(dem, axes = FALSE)\nplot(cl, add = TRUE)\ngrain = rast(system.file(\"raster/grain.tif\", package = \"spData\"))\ngrain_poly = as.polygons(grain) %>% \n  st_as_sf()"},{"path":"raster-vector.html","id":"exercises-3","chapter":"6 Interactions raster-vecteur","heading":"6.6 Exercises","text":"exercises use vector (zion_points) raster dataset (srtm) spDataLarge package.\nalso use polygonal ‘convex hull’ derived vector dataset (ch) represent area interest:E1. Crop srtm raster using (1) zion_points dataset (2) ch dataset.\ndifferences output maps?\nNext, mask srtm using two datasets.\nCan see difference now?\ncan explain ?E2. Firstly, extract values srtm points represented zion_points.\nNext, extract average values srtm using 90 buffer around point zion_points compare two sets values.\nextracting values buffers suitable points alone?E3. Subset points higher 3100 meters New Zealand (nz_height object) create template raster resolution 3 km extent new point dataset.\nUsing two new objects:Count numbers highest points grid cell.Find maximum elevation grid cell.E4. Aggregate raster counting high points New Zealand (created previous exercise), reduce geographic resolution half (cells 6 6 km) plot result.Resample lower resolution raster back original resolution 3 km. results changed?Name two advantages disadvantages reducing raster resolution.E5. Polygonize grain dataset filter squares representing clay.Name two advantages disadvantages vector data raster data.useful convert rasters vectors work?","code":"\nlibrary(sf)\nlibrary(terra)\nlibrary(spData)\nzion_points_path = system.file(\"vector/zion_points.gpkg\", package = \"spDataLarge\")\nzion_points = read_sf(zion_points_path)\nsrtm = rast(system.file(\"raster/srtm.tif\", package = \"spDataLarge\"))\nch = st_combine(zion_points) %>%\n  st_convex_hull() %>% \n  st_as_sf()"}]
